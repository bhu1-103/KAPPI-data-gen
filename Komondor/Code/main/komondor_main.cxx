
#line 52 "komondor_main.cc"
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <vector>
#include <map>
#include <string>     // std::string, std::to_string
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>


#line 1 ".././COST/cost.h"

























#ifndef queue_t
#define queue_t SimpleQueue
#endif

#include <stdarg.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <deque>
#include <vector>
#include <assert.h>


#line 1 ".././COST/priority_q.h"























#ifndef PRIORITY_QUEUE_H
#define PRIORITY_QUEUE_H
#include <stdio.h>
#include <string.h>














template < class ITEM >
class SimpleQueue 
{
 public:
  SimpleQueue() :m_head(NULL) {};
  void EnQueue(ITEM*);
  ITEM* DeQueue();
  void Delete(ITEM*);
  ITEM* NextEvent() const { return m_head; };
  const char* GetName();
 protected:
  ITEM* m_head;
};

template <class ITEM>
const char* SimpleQueue<ITEM>::GetName()
{
  static const char* name = "SimpleQueue";
  return name;
}

template <class ITEM>
void SimpleQueue<ITEM>::EnQueue(ITEM* item)
{
  if( m_head==NULL || item->time < m_head->time )
  {
    if(m_head!=NULL)m_head->prev=item;
    item->next=m_head;
    m_head=item;
    item->prev=NULL;
    return;
  }
    
  ITEM* i=m_head;
  while( i->next!=NULL && item->time > i->next->time)
    i=i->next;
  item->next=i->next;
  if(i->next!=NULL)i->next->prev=item;
  i->next=item;
  item->prev=i;

}

template <class ITEM>
ITEM* SimpleQueue<ITEM> ::DeQueue()
{
  if(m_head==NULL)return NULL;
  ITEM* item = m_head;
  m_head=m_head->next;
  if(m_head!=NULL)m_head->prev=NULL;
  return item;
}

template <class ITEM>
void SimpleQueue<ITEM>::Delete(ITEM* item)
{
  if(item==NULL) return;

  if(item==m_head)
  {
    m_head=m_head->next;
    if(m_head!=NULL)m_head->prev=NULL;
  }
  else
  {
    item->prev->next=item->next;
    if(item->next!=NULL)
      item->next->prev=item->prev;
  }

}

template <class ITEM>
class GuardedQueue : public SimpleQueue<ITEM>
{
 public:
  void Delete(ITEM*);
  void EnQueue(ITEM*);
  bool Validate(const char*);
};
template <class ITEM>
void GuardedQueue<ITEM>::EnQueue(ITEM* item)
{

  ITEM* i=SimpleQueue<ITEM>::m_head;
  while(i!=NULL)
  {
    if(i==item)
    {
      pthread_printf("queue error: item %f(%p) is already in the queue\n",item->time,item);
    }
    i=i->next;
  }
  SimpleQueue<ITEM>::EnQueue(item);
}

template <class ITEM>
void GuardedQueue<ITEM>::Delete(ITEM* item)
{
  ITEM* i=SimpleQueue<ITEM>::m_head;
  while(i!=item&&i!=NULL)
    i=i->next;
  if(i==NULL)
    pthread_printf("error: cannot find the to-be-deleted event %f(%p)\n",item->time,item);
  else
    SimpleQueue<ITEM>::Delete(item);
}

template <class ITEM>
bool GuardedQueue<ITEM>::Validate(const char* s)
{
  char out[1000],buff[100];

  ITEM* i=SimpleQueue<ITEM>::m_head;
  bool qerror=false;

  sprintf(out,"queue error %s : ",s);
  while(i!=NULL)
  {
    sprintf(buff,"%f ",i->time);
    strcat(out,buff);
    if(i->next!=NULL)
      if(i->next->prev!=i)
      {
	qerror=true;
	sprintf(buff," {broken} ");
	strcat(out,buff);
      }
    if(i==i->next)
    {
      qerror=true;
      sprintf(buff,"{loop}");
      strcat(out,buff);
      break;
    }
    i=i->next;
  }
  if(qerror)
    printf("%s\n",out);
  return qerror;
}

template <class ITEM>
class ErrorQueue : public SimpleQueue<ITEM>
{
 public:
  ITEM* DeQueue(double);
  const char* GetName();
};

template <class ITEM>
const char* ErrorQueue<ITEM>::GetName()
{
  static const char* name = "ErrorQueue";
  return name;
}

template <class ITEM>
ITEM* ErrorQueue<ITEM> ::DeQueue(double stoptime)
{
  

  if(drand48()>0.5)
    return SimpleQueue<ITEM>::DeQueue();

  int s=0;
  ITEM* e;
  e=SimpleQueue<ITEM>::m_head;
  while(e!=NULL&&e->time<stoptime)
  {
    s++;
    e=e->next;
  }
  e=SimpleQueue<ITEM>::m_head;
  s=(int)(s*drand48());
  while(s!=0)
  {
    e=e->next;
    s--;
  }
  Delete(e);
  return e;
}

template < class ITEM >
class HeapQueue 
{
 public:
  HeapQueue();
  ~HeapQueue();
  void EnQueue(ITEM*);
  ITEM* DeQueue();
  void Delete(ITEM*);
  const char* GetName();
  ITEM* NextEvent() const { return num_of_elems?elems[0]:NULL; };
 private:
  void SiftDown(int);
  void PercolateUp(int);
  void Validate(const char*);
        
  ITEM** elems;
  int num_of_elems;
  int curr_max;
};

template <class ITEM>
const char* HeapQueue<ITEM>::GetName()
{
  static const char* name = "HeapQueue";
  return name;
}

template <class ITEM>
void HeapQueue<ITEM>::Validate(const char* s)
{
  int i,j;
  char out[1000],buff[100];
  for(i=0;i<num_of_elems;i++)
    if(  ((2*i+1)<num_of_elems&&elems[i]->time>elems[2*i+1]->time) ||
	 ((2*i+2)<num_of_elems&&elems[i]->time>elems[2*i+2]->time) )
    {
      sprintf(out,"queue error %s : ",s);
      for(j=0;j<num_of_elems;j++)
      {
	if(i!=j)
	  sprintf(buff,"%f(%d) ",elems[j]->time,j);
	else
	  sprintf(buff,"{%f(%d)} ",elems[j]->time,j);
	strcat(out,buff);
      }
      printf("%s\n",out);
    }
}
template <class ITEM>
HeapQueue<ITEM>::HeapQueue()
{
  curr_max=16;
  elems=new ITEM*[curr_max];
  num_of_elems=0;
}
template <class ITEM>
HeapQueue<ITEM>::~HeapQueue()
{
  delete [] elems;
}
template <class ITEM>
void HeapQueue<ITEM>::SiftDown(int node)
{
  if(num_of_elems<=1) return;
  int i=node,k,c1,c2;
  ITEM* temp;
        
  do{
    k=i;
    c1=c2=2*i+1;
    c2++;
    if(c1<num_of_elems && elems[c1]->time < elems[i]->time)
      i=c1;
    if(c2<num_of_elems && elems[c2]->time < elems[i]->time)
      i=c2;
    if(k!=i)
    {
      temp=elems[i];
      elems[i]=elems[k];
      elems[k]=temp;
      elems[k]->pos=k;
      elems[i]->pos=i;
    }
  }while(k!=i);
}
template <class ITEM>
void HeapQueue<ITEM>::PercolateUp(int node)
{
  int i=node,k,p;
  ITEM* temp;
        
  do{
    k=i;
    if( (p=(i+1)/2) != 0)
    {
      --p;
      if(elems[i]->time < elems[p]->time)
      {
	i=p;
	temp=elems[i];
	elems[i]=elems[k];
	elems[k]=temp;
	elems[k]->pos=k;
	elems[i]->pos=i;
      }
    }
  }while(k!=i);
}

template <class ITEM>
void HeapQueue<ITEM>::EnQueue(ITEM* item)
{
  if(num_of_elems>=curr_max)
  {
    curr_max*=2;
    ITEM** buffer=new ITEM*[curr_max];
    for(int i=0;i<num_of_elems;i++)
      buffer[i]=elems[i];
    delete[] elems;
    elems=buffer;
  }
        
  elems[num_of_elems]=item;
  elems[num_of_elems]->pos=num_of_elems;
  num_of_elems++;
  PercolateUp(num_of_elems-1);
}

template <class ITEM>
ITEM* HeapQueue<ITEM>::DeQueue()
{
  if(num_of_elems<=0)return NULL;
        
  ITEM* item=elems[0];
  num_of_elems--;
  elems[0]=elems[num_of_elems];
  elems[0]->pos=0;
  SiftDown(0);
  return item;
}

template <class ITEM>
void HeapQueue<ITEM>::Delete(ITEM* item)
{
  int i=item->pos;

  num_of_elems--;
  elems[i]=elems[num_of_elems];
  elems[i]->pos=i;
  SiftDown(i);
  PercolateUp(i);
}



#define CQ_MAX_SAMPLES 25

template <class ITEM>
class CalendarQueue 
{
 public:
  CalendarQueue();
  const char* GetName();
  ~CalendarQueue();
  void enqueue(ITEM*);
  ITEM* dequeue();
  void EnQueue(ITEM*);
  ITEM* DeQueue();
  ITEM* NextEvent() const { return m_head;}
  void Delete(ITEM*);
 private:
  long last_bucket,number_of_buckets;
  double bucket_width;
        
  void ReSize(long);
  double NewWidth();

  ITEM ** buckets;
  long total_number;
  double bucket_top;
  long bottom_threshold;
  long top_threshold;
  double last_priority;
  bool resizable;

  ITEM* m_head;
  char m_name[100];
};


template <class ITEM>
const char* CalendarQueue<ITEM> :: GetName()
{
  sprintf(m_name,"Calendar Queue (bucket width: %.2e, size: %ld) ",
	  bucket_width,number_of_buckets);
  return m_name;
}
template <class ITEM>
CalendarQueue<ITEM>::CalendarQueue()
{
  long i;
        
  number_of_buckets=16;
  bucket_width=1.0;
  bucket_top=bucket_width;
  total_number=0;
  last_bucket=0;
  last_priority=0.0;
  top_threshold=number_of_buckets*2;
  bottom_threshold=number_of_buckets/2-2;
  resizable=true;
        
  buckets= new ITEM*[number_of_buckets];
  for(i=0;i<number_of_buckets;i++)
    buckets[i]=NULL;
  m_head=NULL;

}
template <class ITEM>
CalendarQueue<ITEM>::~CalendarQueue()
{
  delete [] buckets;
}
template <class ITEM>
void CalendarQueue<ITEM>::ReSize(long newsize)
{
  long i;
  ITEM** old_buckets=buckets;
  long old_number=number_of_buckets;
        
  resizable=false;
  bucket_width=NewWidth();
  buckets= new ITEM*[newsize];
  number_of_buckets=newsize;
  for(i=0;i<newsize;i++)
    buckets[i]=NULL;
  last_bucket=0;
  total_number=0;

  
        
  ITEM *item;
  for(i=0;i<old_number;i++)
  {
    while(old_buckets[i]!=NULL)
    {
      item=old_buckets[i];
      old_buckets[i]=item->next;
      enqueue(item);
    }
  }
  resizable=true;
  delete[] old_buckets;
  number_of_buckets=newsize;
  top_threshold=number_of_buckets*2;
  bottom_threshold=number_of_buckets/2-2;
  bucket_top=bucket_width*((long)(last_priority/bucket_width)+1)+bucket_width*0.5;
  last_bucket = long(last_priority/bucket_width) % number_of_buckets;

}
template <class ITEM>
ITEM* CalendarQueue<ITEM>::DeQueue()
{
  ITEM* head=m_head;
  m_head=dequeue();
  return head;
}
template <class ITEM>
ITEM* CalendarQueue<ITEM>::dequeue()
{
  long i;
  for(i=last_bucket;;)
  {
    if(buckets[i]!=NULL&&buckets[i]->time<bucket_top)
    {
      ITEM * item=buckets[i];
      buckets[i]=buckets[i]->next;
      total_number--;
      last_bucket=i;
      last_priority=item->time;
                        
      if(resizable&&total_number<bottom_threshold)
	ReSize(number_of_buckets/2);
      item->next=NULL;
      return item;
    }
    else
    {
      i++;
      if(i==number_of_buckets)i=0;
      bucket_top+=bucket_width;
      if(i==last_bucket)
	break;
    }
  }
        
  
  long smallest;
  for(smallest=0;smallest<number_of_buckets;smallest++)
    if(buckets[smallest]!=NULL)break;

  if(smallest >= number_of_buckets)
  {
    last_priority=bucket_top;
    return NULL;
  }

  for(i=smallest+1;i<number_of_buckets;i++)
  {
    if(buckets[i]==NULL)
      continue;
    else
      if(buckets[i]->time<buckets[smallest]->time)
	smallest=i;
  }
  ITEM * item=buckets[smallest];
  buckets[smallest]=buckets[smallest]->next;
  total_number--;
  last_bucket=smallest;
  last_priority=item->time;
  bucket_top=bucket_width*((long)(last_priority/bucket_width)+1)+bucket_width*0.5;
  item->next=NULL;
  return item;
}
template <class ITEM>
void CalendarQueue<ITEM>::EnQueue(ITEM* item)
{
  
  if(m_head==NULL)
  {
    m_head=item;
    return;
  }
  if(m_head->time>item->time)
  {
    enqueue(m_head);
    m_head=item;
  }
  else
    enqueue(item);
}
template <class ITEM>
void CalendarQueue<ITEM>::enqueue(ITEM* item)
{
  long i;
  if(item->time<last_priority)
  {
    i=(long)(item->time/bucket_width);
    last_priority=item->time;
    bucket_top=bucket_width*(i+1)+bucket_width*0.5;
    i=i%number_of_buckets;
    last_bucket=i;
  }
  else
  {
    i=(long)(item->time/bucket_width);
    i=i%number_of_buckets;
  }

        
  

  if(buckets[i]==NULL||item->time<buckets[i]->time)
  {
    item->next=buckets[i];
    buckets[i]=item;
  }
  else
  {

    ITEM* pos=buckets[i];
    while(pos->next!=NULL&&item->time>pos->next->time)
    {
      pos=pos->next;
    }
    item->next=pos->next;
    pos->next=item;
  }
  total_number++;
  if(resizable&&total_number>top_threshold)
    ReSize(number_of_buckets*2);
}
template <class ITEM>
void CalendarQueue<ITEM>::Delete(ITEM* item)
{
  if(item==m_head)
  {
    m_head=dequeue();
    return;
  }
  long j;
  j=(long)(item->time/bucket_width);
  j=j%number_of_buckets;
        
  

  
  

  ITEM** p = &buckets[j];
  
  ITEM* i=buckets[j];
    
  while(i!=NULL)
  {
    if(i==item)
    { 
      (*p)=item->next;
      total_number--;
      if(resizable&&total_number<bottom_threshold)
	ReSize(number_of_buckets/2);
      return;
    }
    p=&(i->next);
    i=i->next;
  }   
}
template <class ITEM>
double CalendarQueue<ITEM>::NewWidth()
{
  long i, nsamples;
        
  if(total_number<2) return 1.0;
  if(total_number<=5)
    nsamples=total_number;
  else
    nsamples=5+total_number/10;
  if(nsamples>CQ_MAX_SAMPLES) nsamples=CQ_MAX_SAMPLES;
        
  long _last_bucket=last_bucket;
  double _bucket_top=bucket_top;
  double _last_priority=last_priority;
        
  double AVG[CQ_MAX_SAMPLES],avg1=0,avg2=0;
  ITEM* list,*next,*item;
        
  list=dequeue(); 
  long real_samples=0;
  while(real_samples<nsamples)
  {
    item=dequeue();
    if(item==NULL)
    {
      item=list;
      while(item!=NULL)
      {
	next=item->next;
	enqueue(item);
	item=next;      
      }

      last_bucket=_last_bucket;
      bucket_top=_bucket_top;
      last_priority=_last_priority;

                        
      return 1.0;
    }
    AVG[real_samples]=item->time-list->time;
    avg1+=AVG[real_samples];
    if(AVG[real_samples]!=0.0)
      real_samples++;
    item->next=list;
    list=item;
  }
  item=list;
  while(item!=NULL)
  {
    next=item->next;
    enqueue(item);
    item=next;      
  }
        
  last_bucket=_last_bucket;
  bucket_top=_bucket_top;
  last_priority=_last_priority;
        
  avg1=avg1/(double)(real_samples-1);
  avg1=avg1*2.0;
        
  
  long count=0;
  for(i=0;i<real_samples-1;i++)
  {
    if(AVG[i]<avg1&&AVG[i]!=0)
    {
      avg2+=AVG[i];
      count++;
    }
  }
  if(count==0||avg2==0)   return 1.0;
        
  avg2 /= (double) count;
  avg2 *= 3.0;
        
  return avg2;
}

#endif /*PRIORITY_QUEUE_H*/

#line 38 ".././COST/cost.h"


#line 1 ".././COST/corsa_alloc.h"
































#ifndef corsa_allocator_h
#define corsa_allocator_h

#include <typeinfo>
#include <string>

class CorsaAllocator
{
private:
    struct DT{
#ifdef CORSA_DEBUG
	DT* self;
#endif
	DT* next;
    };
public:
    CorsaAllocator(unsigned int );         
    CorsaAllocator(unsigned int, int);     
    ~CorsaAllocator();		
    void *alloc();		
    void free(void*);
    unsigned int datasize() 
    {
#ifdef CORSA_DEBUG
	return m_datasize-sizeof(DT*);
#else
	return m_datasize; 
#endif
    }
    int size() { return m_size; }
    int capacity() { return m_capacity; }			
    
    const char* GetName() { return m_name.c_str(); }
    void SetName( const char* name) { m_name=name; } 

private:
    CorsaAllocator(const CorsaAllocator& ) {}  
    void Setup(unsigned int,int); 
    void InitSegment(int);
  
    unsigned int m_datasize;
    char** m_segments;	          
    int m_segment_number;         
    int m_segment_max;      
    int m_segment_size;	          
				  
    DT* m_free_list; 
    int m_size;
    int m_capacity;

    int m_free_times,m_alloc_times;
    int m_max_allocs;

    std::string m_name;
};
#ifndef CORSA_NODEF
CorsaAllocator::CorsaAllocator(unsigned int datasize)
{
    Setup(datasize,256);	  
}

CorsaAllocator::CorsaAllocator(unsigned int datasize, int segsize)
{
    Setup(datasize,segsize);
}

CorsaAllocator::~CorsaAllocator()
{
    #ifdef CORSA_DEBUG
    printf("%s -- alloc: %d, free: %d, max: %d\n",GetName(),
	   m_alloc_times,m_free_times,m_max_allocs);
    #endif

    for(int i=0;i<m_segment_number;i++)
	delete[] m_segments[i];	   
    delete[] m_segments;			
}

void CorsaAllocator::Setup(unsigned int datasize,int seg_size)
{

    char buffer[50];
    sprintf(buffer,"%s[%d]",typeid(*this).name(),datasize);
    m_name = buffer;

#ifdef CORSA_DEBUG
    datasize+=sizeof(DT*);  
#endif

    if(datasize<sizeof(DT))datasize=sizeof(DT);
    m_datasize=datasize;
    if(seg_size<16)seg_size=16;    
    m_segment_size=seg_size;			
    m_segment_number=1;		   
    m_segment_max=seg_size;	   
    m_segments= new char* [ m_segment_max ] ;   
    m_segments[0]= new char [m_segment_size*m_datasize];  

    m_size=0;
    m_capacity=0;
    InitSegment(0);

    m_free_times=m_alloc_times=m_max_allocs=00;
}

void CorsaAllocator::InitSegment(int s)
{
    char* p=m_segments[s];
    m_free_list=reinterpret_cast<DT*>(p);
    for(int i=0;i<m_segment_size-1;i++,p+=m_datasize)
    {
	reinterpret_cast<DT*>(p)->next=
	    reinterpret_cast<DT*>(p+m_datasize);
    }
    reinterpret_cast<DT*>(p)->next=NULL;
    m_capacity+=m_segment_size;
}

void* CorsaAllocator::alloc()
{
    #ifdef CORSA_DEBUG
    m_alloc_times++;
    if(m_alloc_times-m_free_times>m_max_allocs)
	m_max_allocs=m_alloc_times-m_free_times;
    #endif
    if(m_free_list==NULL)	
    
    {
	int i;
	if(m_segment_number==m_segment_max)	
	
	
	{
	    m_segment_max*=2;		
	    char** buff;
	    buff=new char* [m_segment_max];   
#ifdef CORSA_DEBUG
	    if(buff==NULL)
	    {
		printf("CorsaAllocator runs out of memeory.\n");
		exit(1);
	    }
#endif
	    for(i=0;i<m_segment_number;i++)
		buff[i]=m_segments[i];	
	    delete [] m_segments;		
	    m_segments=buff;
	}
	m_segment_size*=2;
	m_segments[m_segment_number]=new char[m_segment_size*m_datasize];
#ifdef CORSA_DEBUG
	    if(m_segments[m_segment_number]==NULL)
	    {
		printf("CorsaAllocator runs out of memeory.\n");
		exit(1);
	    }
#endif
	InitSegment(m_segment_number);
	m_segment_number++;
    }

    DT* item=m_free_list;		
    m_free_list=m_free_list->next;
    m_size++;

#ifdef CORSA_DEBUG
    item->self=item;
    char* p=reinterpret_cast<char*>(item);
    p+=sizeof(DT*);
    
    return static_cast<void*>(p);
#else
    return static_cast<void*>(item);
#endif
}

void CorsaAllocator::free(void* data)
{
#ifdef CORSA_DEBUG
    m_free_times++;
    char* p=static_cast<char*>(data);
    p-=sizeof(DT*);
    DT* item=reinterpret_cast<DT*>(p);
    
    if(item!=item->self)
    {
	if(item->self==(DT*)0xabcd1234)
	    printf("%s: packet at %p has already been released\n",GetName(),p+sizeof(DT*)); 
	else
	    printf("%s: %p is probably not a pointer to a packet\n",GetName(),p+sizeof(DT*));
    }
    assert(item==item->self);
    item->self=(DT*)0xabcd1234;
#else
    DT* item=static_cast<DT*>(data);
#endif

    item->next=m_free_list;
    m_free_list=item;
    m_size--;
}
#endif /* CORSA_NODEF */

#endif /* corsa_allocator_h */

#line 39 ".././COST/cost.h"


class trigger_t {};
typedef double simtime_t;

#ifdef COST_DEBUG
#define Printf(x) Print x
#else
#define Printf(x)
#endif



class TimerBase;



struct CostEvent
{
  double time;
  CostEvent* next;
  union {
    CostEvent* prev;
    int pos;  
  };
  TimerBase* object;
  int index;
  unsigned char active;
};



class TimerBase
{
 public:
  virtual void activate(CostEvent*) = 0;
  inline virtual ~TimerBase() {}	
};

class TypeII;



class CostSimEng
{
 public:

  class seed_t
      {
       public:
	void operator = (long seed) { srand48(seed); };
      };
  seed_t		Seed;
  CostSimEng()
      : stopTime( 0), clearStatsTime( 0), m_clock( 0.0)
      {
        if( m_instance == NULL)
	  m_instance = this;
        else
	  printf("Error: only one simulation engine can be created\n");
      }
  virtual		~CostSimEng()	{ }
  static CostSimEng	*Instance()
      {
        if(m_instance==NULL)
        {
	  printf("Error: a simulation engine has not been initialized\n");
	  m_instance = new CostSimEng;
        }
        return m_instance;
      }
  CorsaAllocator	*GetAllocator(unsigned int datasize)
      {
    	for(unsigned int i=0;i<m_allocators.size();i++)
    	{
	  if(m_allocators[i]->datasize()==datasize)return m_allocators[i];
    	} 
    	CorsaAllocator* allocator=new CorsaAllocator(datasize);
    	char buffer[25];
    	sprintf(buffer,"EventAllocator[%d]",datasize);
    	allocator->SetName(buffer);
    	m_allocators.push_back(allocator);
    	return allocator;
      }
  void		AddComponent(TypeII*c)
      {
        m_components.push_back(c);
      }
  void		ScheduleEvent(CostEvent*e)
      {
	if( e->time < m_clock)
	  assert(e->time>=m_clock);
        
        m_queue.EnQueue(e);
      }
  void		CancelEvent(CostEvent*e)
      {
        
        m_queue.Delete(e);
      }
  double	Random( double v=1.0)	{ return v*drand48();}
  int		Random( int v)		{ return (int)(v*drand48()); }
  double	Exponential(double mean)	{ return -mean*log(Random());}
  virtual void	Start()		{}
  virtual void	Stop()		{}
  void		Run();
  double	SimTime()	{ return m_clock; } 
  void		StopTime( double t)	{ stopTime = t; }
  double	StopTime() const	{ return stopTime; }
  void		ClearStatsTime( double t)	{ clearStatsTime = t; }
  double	ClearStatsTime() const	{ return clearStatsTime; }
  virtual void	ClearStats()	{}
 private:
  double	stopTime;
  double	clearStatsTime;	
  double	eventRate;
  double	runningTime;
  long		eventsProcessed;
  double	m_clock;
  queue_t<CostEvent>	m_queue;
  std::vector<TypeII*>	m_components;
  static CostSimEng	*m_instance;
  std::vector<CorsaAllocator*>	m_allocators;
};




class TypeII
{
 public: 
  virtual void Start() {};
  virtual void Stop() {};
  inline virtual ~TypeII() {}		
  TypeII()
      {
        m_simeng=CostSimEng::Instance();
        m_simeng->AddComponent(this);
      }

#ifdef COST_DEBUG
  void Print(const bool, const char*, ...);
#endif
    
  double Random(double v=1.0) { return v*drand48();}
  int Random(int v) { return (int)(v*drand48());}
  double Exponential(double mean) { return -mean*log(Random());}
  inline double SimTime() const { return m_simeng->SimTime(); }
  inline double StopTime() const { return m_simeng->StopTime(); }
 private:
  CostSimEng* m_simeng;
}; 

#ifdef COST_DEBUG
void TypeII::Print(const bool flag, const char* format, ...)
{
  if(flag==false) return;
  va_list ap;
  va_start(ap, format);
  printf("[%.10f] ",SimTime());
  vprintf(format,ap);
  va_end(ap);
}
#endif

CostSimEng* CostSimEng::m_instance = NULL;

void CostSimEng::Run()
{
  double	nextTime = (clearStatsTime != 0.0 && clearStatsTime < stopTime) ? clearStatsTime : stopTime;

  m_clock = 0.0;
  eventsProcessed = 0l;
  std::vector<TypeII*>::iterator iter;
      
  struct timeval start_time;    
  gettimeofday( &start_time, NULL);

  Start();

  for( iter = m_components.begin(); iter != m_components.end(); iter++)
    (*iter)->Start();

  CostEvent* e=m_queue.DeQueue();
  while( e != NULL)
  {
    if( e->time >= nextTime)
    {
      if( nextTime == stopTime)
	break;
      
      printf( "Clearing statistics @ %f\n", nextTime);
      nextTime = stopTime;
      ClearStats();
    }
    
    assert( e->time >= m_clock);
    m_clock = e->time;
    e->object->activate( e);
    eventsProcessed++;
    e = m_queue.DeQueue();
  }
  m_clock = stopTime;
  for(iter = m_components.begin(); iter != m_components.end(); iter++)
    (*iter)->Stop();
	    
  Stop();

  struct timeval stop_time;    
  gettimeofday(&stop_time,NULL);

  runningTime = stop_time.tv_sec - start_time.tv_sec +
      (stop_time.tv_usec - start_time.tv_usec) / 1000000.0;
  eventRate = eventsProcessed/runningTime;
  
  
  printf("# -------------------------------------------------------------------------\n");	
  printf("# CostSimEng with %s, stopped at %f\n", m_queue.GetName(), stopTime);	
  printf("# %ld events processed in %.3f seconds, event processing rate: %.0f\n",	
  eventsProcessed, runningTime, eventRate);
  
}







#line 64 "komondor_main.cc"



#line 1 "../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 66 "komondor_main.cc"



#line 1 "../structures/logical_nack.h"

















































#ifndef _AUX_LOGICAL_NACK_
#define _AUX_LOGICAL_NACK_

struct LogicalNack
{
	int source_id;		
	int packet_type;	
	int packet_id;		
	int loss_reason;	
	int node_id_a;		
	int node_id_b;		
	double ber;			
	double sinr;		

	


	void PrintNackInfo(void){
		printf("source_id = %d - packet_id = %d - loss_reason = %d - node_id_a = %d - node_id_b = %d\n",
			source_id, packet_id, loss_reason, node_id_a, node_id_b);
	}
};

#endif


#line 68 "komondor_main.cc"


#line 1 "../structures/notification.h"













































 



#ifndef _AUX_NOTIFICATION_
#define _AUX_NOTIFICATION_


struct TxInfo
{

	int num_packets_aggregated;				
	int *list_id_aggregated;				
	double *timestamp_frames_aggregated;	

	
	double data_duration;		
	double ack_duration;		
	double rts_duration;		
	double cts_duration;		

	double preoccupancy_duration;	
	double total_tx_power;			
	double tx_power;				
	double tx_gain;					
	double pd;						
	double bits_ofdm_sym; 			
	double data_rate; 				
	int modulation_schemes[4];		
	double x;						
	double y;						
	double z;						
	double nav_time;				

	bool flag_change_in_tx_power;	

	
	int bss_color;				
	int srg;					
	bool txop_sr_identified;	

	





	void PrintTxInfo(int packet_id, int destination_id, double tx_duration){
		printf("packet_id = %d - destination_id = %d - tx_duration = %f - tx_power = %f pw"
			" - position = (%.2f, %.2f, %.2f)\n",
			packet_id, destination_id, tx_duration, tx_power, x, y, z);
	}

	



	void SetSizeOfIdsAggregatedArray(int num_packets_aggregated){
		list_id_aggregated = new int[num_packets_aggregated];
		for(int t = 0; t < num_packets_aggregated; ++t){
			list_id_aggregated[t] = 0;
		}
	}

	



	void SetSizeOfTimestampAggregatedArray(int num_packets_aggregated){
		timestamp_frames_aggregated = new double[num_packets_aggregated];
		for(int t = 0; t < num_packets_aggregated; ++t){
			timestamp_frames_aggregated[t] = 0;
		}
	}

	



	void SetSizeOfMCS(int channels_groups){
		
		for(int s = 0; s < channels_groups; ++s){
			modulation_schemes[s] = MODULATION_NONE;
		}
	}

};


struct Notification
{
	
	int packet_id;				
	int packet_type;			
	int source_id;				
	int destination_id;			
	double tx_duration;			
	int left_channel;			
	int right_channel;			
	int frame_length;			
	int modulation_id;			
	double timestamp;			
	double timestamp_generated;	
	TxInfo tx_info; 			

	


	void PrintNotification(void){
		printf("source_id = %d - packet_type = %d - left_channel = %d - right_channel = %d - pkt_length = %d -",
			source_id, packet_type, left_channel, right_channel, frame_length);
		printf("tx_info: ");
		tx_info.PrintTxInfo(packet_id, destination_id, tx_duration);
	}

};

#endif


#line 69 "komondor_main.cc"


#line 1 "../structures/wlan.h"













































 



#ifndef _AUX_WLAN_
#define _AUX_WLAN_

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string.h>

#line 1 "../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 57 "../structures/wlan.h"


#line 1 "../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 58 "../structures/wlan.h"



struct Wlan
{
	int wlan_id;			
	std::string wlan_code;	
	int num_stas;			
	int ap_id;				
	int *list_sta_id;		

	int spatial_reuse_enabled;	

	



	void SetSizeOfSTAsArray(int num_stas){
		list_sta_id = new int[num_stas];
		for(int s = 0; s < num_stas; ++s){
			list_sta_id[s] = NODE_ID_NONE;
		}
	}

	



	int FindStaInList(int sta_id){
		int found(0);
		for(int s = 0; s < num_stas; ++s){
			if(list_sta_id[s] == sta_id) found = 1;
		}
		return found;
	}

	


	void PrintStaIds(){
		for(int s = 0; s < num_stas; s++){
			printf("%d  ", list_sta_id[s]);
		}
		printf("\n");
	}

	



	void WriteStaIds(Logger logger){
		if (logger.save_logs){
			for(int s = 0; s < num_stas; s++){
				fprintf(logger.file, "%d  ", list_sta_id[s]);
			}
		}
	}

	


	void PrintWlanInfo(){
		printf("%s WLAN %s:\n", LOG_LVL3, wlan_code.c_str());
		printf("%s wlan_id: %d\n", LOG_LVL4, wlan_id);
		printf("%s num_stas: %d\n", LOG_LVL4, num_stas);
		printf("%s ap_id: %d\n", LOG_LVL4, ap_id);
		printf("%s list of STAs IDs: ", LOG_LVL4);
		PrintStaIds();
	}

	




	void WriteWlanInfo(Logger logger, std::string header_str){
		if (logger.save_logs){
			fprintf(logger.file, "%s WLAN %s:\n", header_str.c_str(), wlan_code.c_str());
			fprintf(logger.file, "%s - wlan_id: %d\n", header_str.c_str(), wlan_id);
			fprintf(logger.file, "%s - num_stas: %d\n", header_str.c_str(), num_stas);
			fprintf(logger.file, "%s - ap_id: %d\n", header_str.c_str(), ap_id);
			fprintf(logger.file, "%s - list of STAs IDs: ", header_str.c_str());
			WriteStaIds(logger);
			fprintf(logger.file, "\n");
		}
	}
};

#endif


#line 70 "komondor_main.cc"



#line 1 "../methods/output_generation_methods.h"
	












































 





#include <math.h>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 57 "../methods/output_generation_methods.h"


#line 1 "../methods/../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 58 "../methods/output_generation_methods.h"


#line 1 "../methods/../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../methods/../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../methods/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../methods/../structures/../methods/power_channel_methods.h"


#line 1 "../methods/../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../methods/../structures/../methods/power_channel_methods.h"


#line 1 "../methods/../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../methods/../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../methods/../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 59 "../methods/output_generation_methods.h"


#line 1 "../methods/../structures/wlan.h"













































 



#ifndef _AUX_WLAN_
#define _AUX_WLAN_

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string.h>

#line 1 "../methods/../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 57 "../methods/../structures/wlan.h"


#line 1 "../methods/../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 58 "../methods/../structures/wlan.h"



struct Wlan
{
	int wlan_id;			
	std::string wlan_code;	
	int num_stas;			
	int ap_id;				
	int *list_sta_id;		

	int spatial_reuse_enabled;	

	



	void SetSizeOfSTAsArray(int num_stas){
		list_sta_id = new int[num_stas];
		for(int s = 0; s < num_stas; ++s){
			list_sta_id[s] = NODE_ID_NONE;
		}
	}

	



	int FindStaInList(int sta_id){
		int found(0);
		for(int s = 0; s < num_stas; ++s){
			if(list_sta_id[s] == sta_id) found = 1;
		}
		return found;
	}

	


	void PrintStaIds(){
		for(int s = 0; s < num_stas; s++){
			printf("%d  ", list_sta_id[s]);
		}
		printf("\n");
	}

	



	void WriteStaIds(Logger logger){
		if (logger.save_logs){
			for(int s = 0; s < num_stas; s++){
				fprintf(logger.file, "%d  ", list_sta_id[s]);
			}
		}
	}

	


	void PrintWlanInfo(){
		printf("%s WLAN %s:\n", LOG_LVL3, wlan_code.c_str());
		printf("%s wlan_id: %d\n", LOG_LVL4, wlan_id);
		printf("%s num_stas: %d\n", LOG_LVL4, num_stas);
		printf("%s ap_id: %d\n", LOG_LVL4, ap_id);
		printf("%s list of STAs IDs: ", LOG_LVL4);
		PrintStaIds();
	}

	




	void WriteWlanInfo(Logger logger, std::string header_str){
		if (logger.save_logs){
			fprintf(logger.file, "%s WLAN %s:\n", header_str.c_str(), wlan_code.c_str());
			fprintf(logger.file, "%s - wlan_id: %d\n", header_str.c_str(), wlan_id);
			fprintf(logger.file, "%s - num_stas: %d\n", header_str.c_str(), num_stas);
			fprintf(logger.file, "%s - ap_id: %d\n", header_str.c_str(), ap_id);
			fprintf(logger.file, "%s - list of STAs IDs: ", header_str.c_str());
			WriteStaIds(logger);
			fprintf(logger.file, "\n");
		}
	}
};

#endif


#line 60 "../methods/output_generation_methods.h"


#ifndef _OUT_METHODS_
#define _OUT_METHODS_

int total_data_packets_sent (0);				
double total_num_packets_generated (0);			
double total_throughput (0);					
int ix_wlan_min_throughput (99999);				
double min_throughput (999999999999999999);		
double max_throughput (0);						
double proportional_fairness(0);				
double jains_fairness (0);						
double jains_fairness_aux (0);					
int total_rts_lost_slotted_bo (0);				
int total_rts_cts_sent (0);						
double total_prob_slotted_bo_collision (0);		
int total_num_tx_init_not_possible (0);			
double total_delay (0);							
double max_delay (0);							
double min_delay (9999999999);					
double total_bandiwdth_tx (0);					
double av_expected_backoff (0);					
double av_expected_waiting_time (0);			








void ComputeSimulationStatistics(Performance *performance_report, Configuration *configuration_per_node,
		int total_nodes_number, int total_wlans_number){

	for(int m=0; m < total_nodes_number; ++m){
		
		if( configuration_per_node[m].capabilities.node_type == NODE_TYPE_AP ){
			
			total_data_packets_sent = total_data_packets_sent + performance_report[m].data_packets_sent;
			
			total_throughput = total_throughput + performance_report[m].throughput;
			
			total_num_packets_generated = total_num_packets_generated + performance_report[m].num_packets_generated;
			
			total_rts_lost_slotted_bo = total_rts_lost_slotted_bo + performance_report[m].rts_lost_slotted_bo;
			
			total_rts_cts_sent = total_rts_cts_sent + performance_report[m].rts_cts_sent;
			
			total_prob_slotted_bo_collision = total_prob_slotted_bo_collision + performance_report[m].prob_slotted_bo_collision;
			
			total_num_tx_init_not_possible = total_num_tx_init_not_possible + performance_report[m].num_tx_init_not_possible;
			
			proportional_fairness = proportional_fairness + log10(performance_report[m].throughput);
			
			jains_fairness_aux = jains_fairness_aux + pow(performance_report[m].throughput, 2);
			
			total_delay = total_delay + performance_report[m].average_delay;
			
			if(performance_report[m].average_delay > max_delay) max_delay = performance_report[m].average_delay;
			
			if(performance_report[m].average_delay < min_delay) min_delay = performance_report[m].average_delay;
			
			av_expected_backoff = av_expected_backoff + performance_report[m].expected_backoff;
			
			av_expected_waiting_time = av_expected_waiting_time + performance_report[m].average_waiting_time;
			
			total_bandiwdth_tx = total_bandiwdth_tx + performance_report[m].bandwidth_used_txing;
			
			if(performance_report[m].throughput < min_throughput) {
				ix_wlan_min_throughput = m;
				min_throughput = performance_report[m].throughput;
			}
			
			if(performance_report[m].throughput > max_throughput) max_throughput = performance_report[m].throughput;
		}
	}
	av_expected_backoff = av_expected_backoff / total_wlans_number;
	av_expected_waiting_time = av_expected_waiting_time / total_wlans_number;
	jains_fairness = pow(total_throughput, 2) / (total_nodes_number/2 * jains_fairness_aux); 
}














void PrintAndWriteSimulationStatistics(int print_system_logs, int save_system_logs, Logger &logger_simulation,
		Performance *performance_report, Configuration *configuration_per_node, int total_nodes_number,
		int total_wlans_number, double simulation_time_komondor) {

	
	ComputeSimulationStatistics(performance_report, configuration_per_node, total_nodes_number, total_wlans_number);

	
	if (print_system_logs) {
		printf("\n%s General Statistics (NEW FUNCTION):\n", LOG_LVL1);
		printf("%s Average throughput per WLAN = %.3f Mbps\n",
			LOG_LVL2, (total_throughput * pow(10,-6) / total_wlans_number));
		printf("%s Min. throughput = %.2f Mbps (%.2f pkt/s)\n",
			LOG_LVL3, min_throughput * pow(10,-6), min_throughput / (configuration_per_node[0].frame_length
			* configuration_per_node[0].max_num_packets_aggregated));
		printf("%s Max. throughput = %.2f Mbps (%.2f pkt/s)\n",
			LOG_LVL3, max_throughput * pow(10,-6), max_throughput / (configuration_per_node[0].frame_length
			* configuration_per_node[0].max_num_packets_aggregated));
		printf("%s Total throughput = %.2f Mbps\n", LOG_LVL3, total_throughput * pow(10,-6));
		printf("%s Total number of packets sent = %d\n", LOG_LVL3, total_data_packets_sent);
		printf("%s Average number of data packets successfully sent per WLAN = %.2f\n",
			LOG_LVL4, ((double) total_data_packets_sent/ (double) total_wlans_number));
		printf("%s Average number of RTS packets lost due to slotted BO = %f (%.3f %% loss)\n",
			LOG_LVL4, (double) total_rts_lost_slotted_bo/(double) total_wlans_number,
			((double) total_rts_lost_slotted_bo *100/ (double) total_rts_cts_sent));
		printf("%s Average number of packets sent per WLAN = %d\n", LOG_LVL3, (total_data_packets_sent/total_wlans_number));
		printf("%s Proportional Fairness = %.2f\n", LOG_LVL2, proportional_fairness);
		printf("%s Jain's Fairness = %.2f\n",  LOG_LVL2, jains_fairness);
		printf("%s Prob. collision by slotted BO = %.3f\n", LOG_LVL2, total_prob_slotted_bo_collision / total_wlans_number);
		printf("%s Av. delay = %.2f ms\n", LOG_LVL2, total_delay * pow(10,3) / total_wlans_number);
		printf("%s Max. delay = %.2f ms\n", LOG_LVL3, max_delay * pow(10,3));
		printf("%s Av. expected waiting time = %.2f ms\n", LOG_LVL3, av_expected_waiting_time * pow(10,3));
		printf("%s Average bandwidth used for transmitting = %.2f MHz\n",
			LOG_LVL2, total_bandiwdth_tx / (double) total_wlans_number);
		printf("%s Time channel was idle = %.2f s (%f%%)\n",  LOG_LVL2, performance_report[0].sum_time_channel_idle,
			(100*performance_report[0].sum_time_channel_idle/simulation_time_komondor));
		printf("\n\n");
	}

	printf("\n");

	
	if (save_system_logs) {
		
		fprintf(logger_simulation.file,"\n%s General Statistics (NEW FUNCTION):\n", LOG_LVL1);
		fprintf(logger_simulation.file,"%s Average throughput per WLAN = %.2f Mbps\n", LOG_LVL2, (total_throughput * pow(10,-6)/total_wlans_number));
		fprintf(logger_simulation.file,"%s Total throughput = %.2f Mbps\n", LOG_LVL3, total_throughput * pow(10,-6));
		fprintf(logger_simulation.file,"%s Total number of packets sent = %d\n", LOG_LVL3, total_data_packets_sent);
		fprintf(logger_simulation.file,"%s Average number of data packets successfully sent per WLAN = %.2f\n",
			LOG_LVL4, ( (double) total_data_packets_sent/ (double) total_wlans_number));
		fprintf(logger_simulation.file,"%s Average number of RTS packets lost due to slotted BO = %.2f (%.2f %% loss)\n",
			LOG_LVL4,
			(double) total_rts_lost_slotted_bo/(double) total_wlans_number,
			((double) total_rts_lost_slotted_bo *100/ (double) total_rts_cts_sent));
		fprintf(logger_simulation.file,"%s Average number of packets sent per WLAN = %d\n", LOG_LVL3, (total_data_packets_sent/total_wlans_number));
		fprintf(logger_simulation.file,"%s Proportional Fairness = %.2f\n", LOG_LVL2, proportional_fairness);
		fprintf(logger_simulation.file,"%s Jain's Fairness = %.2f\n",  LOG_LVL2, jains_fairness);
		fprintf(logger_simulation.file,"\n");
	}

}














void GenerateScriptOutput(int simulation_index, Performance *performance_report, Configuration *configuration_per_node,
	Logger &logger_script, int total_wlans_number, int	total_nodes_number, Wlan *wlan_container, double simulation_time_komondor) {

	
	switch(simulation_index){

		case 0:{
			
			fprintf(logger_script.file, ";%.2f;%.2f;%f;%f\n",
				performance_report[0].throughput * pow(10,-6),
				performance_report[2].throughput * pow(10,-6),
				performance_report[0].prob_slotted_bo_collision,
				performance_report[2].prob_slotted_bo_collision);
			break;
		}

		case 1:{
			
			fprintf(logger_script.file, ";%.2f;%.2f;%f;%.2f;%d;%.2f\n",
				(total_throughput * pow(10,-6)/total_wlans_number),
				proportional_fairness,
				jains_fairness,
				min_throughput * pow(10,-6),
				ix_wlan_min_throughput,
				total_bandiwdth_tx / (double) total_wlans_number);
			break;
		}

		case 2:{
			
			fprintf(logger_script.file, ";%.1f;%d;%d;%d;%d;%d;%d;%d\n",
				performance_report[0].throughput * pow(10,-6),
				performance_report[0].rts_cts_sent,
				performance_report[0].rts_cts_lost,
				performance_report[0].rts_lost_slotted_bo,
				performance_report[0].data_packets_sent,
				performance_report[0].data_packets_lost,
				performance_report[0].num_tx_init_tried,
				performance_report[0].num_tx_init_not_possible);
			break;
		}

		case 3:{
			
			fprintf(logger_script.file, ";%.2f;%.3f;%.5f\n",
				av_expected_backoff / SLOT_TIME,
				(total_throughput * pow(10,-6)/total_wlans_number),
				total_prob_slotted_bo_collision / total_wlans_number);
			break;
		}

		case 4:{
			
			fprintf(logger_script.file, ";%.5f",
				total_prob_slotted_bo_collision / total_wlans_number);
			for(int w = 0; w < total_wlans_number; ++w) {
				fprintf(logger_script.file, ";%.3f", performance_report[w*2].throughput * pow(10,-6));
			}
			fprintf(logger_script.file, "\n");
			break;
		}

		case 5:{
			
			for(int w = 0; w < total_wlans_number; ++w) {
				fprintf(logger_script.file, ";%.5f", performance_report[w*2].prob_slotted_bo_collision);
			}
			for(int w = 0; w < total_wlans_number; ++w) {
				fprintf(logger_script.file, ";%.3f", performance_report[w*2].throughput * pow(10,-6));
			}
			fprintf(logger_script.file, "\n");
			break;
		}

		case 6:{
			
			fprintf(logger_script.file, ";%d;%d;%.0f;%.0f;%.2f;%.2f;"
				"%.4f;%.4f;%.2f;%.2f;%.4f;%.4f;%.4f;%.4f;%.4f;%.4f;%.2f;%.2f\n",
				performance_report[0].num_packets_generated,
				performance_report[2].num_packets_generated,
				performance_report[0].throughput / (configuration_per_node[0].frame_length *
					configuration_per_node[0].max_num_packets_aggregated),
				performance_report[2].throughput / (configuration_per_node[2].frame_length *
					configuration_per_node[2].max_num_packets_aggregated),
				performance_report[0].average_rho,
				performance_report[2].average_rho,
				performance_report[0].average_delay * pow(10,3),
				performance_report[2].average_delay * pow(10,3),
				performance_report[0].average_utilization,
				performance_report[2].average_utilization,
				performance_report[0].prob_slotted_bo_collision,
				performance_report[2].prob_slotted_bo_collision,
				performance_report[0].average_waiting_time / SLOT_TIME,
				performance_report[2].average_waiting_time / SLOT_TIME,
				(double) performance_report[0].num_packets_dropped * 100/ performance_report[0].num_packets_generated,
				(double) performance_report[2].num_packets_dropped * 100/ performance_report[2].num_packets_generated,
				(double) (performance_report[0].data_frames_acked / performance_report[0].data_packets_acked),
				(double) (performance_report[2].data_frames_acked / performance_report[2].data_packets_acked));
			break;
		}

		case 7:{
			
			fprintf(logger_script.file, ";%.0f;%d;%d;%d;%d;%d;%d;%d;%f;%f;%f;%f;%f\n",
				performance_report[0].throughput / (configuration_per_node[0].frame_length *
					configuration_per_node[0].max_num_packets_aggregated),
				performance_report[0].rts_cts_sent,
				performance_report[0].rts_cts_lost,
				performance_report[0].rts_lost_slotted_bo,
				performance_report[0].data_packets_sent,
				performance_report[0].data_packets_lost,
				performance_report[0].num_tx_init_tried,
				performance_report[0].num_tx_init_not_possible,
				performance_report[0].average_delay * pow(10,3),
				performance_report[0].average_waiting_time / SLOT_TIME,
				performance_report[0].prob_slotted_bo_collision,
				(double) performance_report[0].num_packets_dropped * 100/ performance_report[0].num_packets_generated,
				(double) performance_report[0].data_frames_acked / performance_report[0].data_packets_acked
				);
			break;
		}

		case 8:{
			
			fprintf(logger_script.file, ";%d;%.0f;%.2f;"
				"%.4f;%.2f;%.4f;%.4f;%.4f;%.4f\n",
				performance_report[0].num_packets_generated,
				performance_report[0].throughput / (configuration_per_node[0].frame_length *
					configuration_per_node[0].max_num_packets_aggregated),
				performance_report[0].average_rho,
				performance_report[0].average_delay * pow(10,3),
				performance_report[0].average_utilization,
				performance_report[0].prob_slotted_bo_collision,
				performance_report[0].average_waiting_time / SLOT_TIME,
				(double) (performance_report[0].num_packets_dropped * 100/ performance_report[0].num_packets_generated),
				(double) (performance_report[0].data_frames_acked / performance_report[0].data_packets_acked)
				);
			break;
		}

		case 9:{
			
			fprintf(logger_script.file, ";%.2f;%.2f;%.2f;%d;%.4f;%.4f;%.4f;%.2f;%.2f;%.2f;%f;%f;%f\n",
				total_throughput/(configuration_per_node[0].frame_length *
					configuration_per_node[0].max_num_packets_aggregated * total_wlans_number),
				(total_throughput * pow(10,-6)/total_wlans_number),
				min_throughput/(configuration_per_node[0].frame_length *
					configuration_per_node[0].max_num_packets_aggregated),
				ix_wlan_min_throughput,
				proportional_fairness,
				jains_fairness,
				total_prob_slotted_bo_collision / total_wlans_number,
				total_delay * pow(10,3) / total_wlans_number,
				max_delay * pow(10,3),
				total_bandiwdth_tx / (double) total_wlans_number,
				av_expected_waiting_time * pow(10,3),
				min_delay * pow(10,3),
				max_throughput/(configuration_per_node[0].frame_length *
					configuration_per_node[0].max_num_packets_aggregated)
				);
			break;
		}

		
		case 10:{
            
            char tpt_per_device[250] = "{";
            char aux_tpt_per_device[50];
            
            char rssi_per_device[250] = "{";
            char aux_rssi_per_device[50];
            int counter_nodes_visited = 0;
            for(int i = 0; i < total_nodes_number; i ++) {
                if(configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
                    
                    if(i > 0 && counter_nodes_visited < total_nodes_number) strcat(tpt_per_device, ",");
                    sprintf(aux_tpt_per_device, "%.2f", performance_report[i].throughput * pow(10,-6));
                    strcat(tpt_per_device, aux_tpt_per_device);
                    
                    
                    
                    ++counter_nodes_visited;
                    for(int w = 0; w < total_wlans_number; w ++) {
                        if(wlan_container[w].ap_id == configuration_per_node[i].capabilities.node_id) {
                            for(int s = 0; s < wlan_container[w].num_stas; s ++) {
                                
                                char sta_details[250] = "";
                                
                                sprintf(aux_rssi_per_device, "%.2f", ConvertPower(PW_TO_DBM, performance_report[counter_nodes_visited].received_power_array[i]));
                                strcat(rssi_per_device, aux_rssi_per_device);
                                strcat(sta_details, aux_rssi_per_device);
                                strcat(sta_details, ";");
                                
                                ++counter_nodes_visited;
                                if(counter_nodes_visited < total_nodes_number) {
                                    strcat(rssi_per_device, ",");
                                }
                            }
                        }
                    }
                }
            }
            strcat(tpt_per_device, "}");
            strcat(rssi_per_device, "}");
            
            fprintf(logger_script.file, ";%s;%s\n", tpt_per_device,rssi_per_device);
			break;
		}

		
		case 11:{
			if (total_nodes_number == 2 || total_nodes_number == 3) {
				
				fprintf(logger_script.file, ";%.2f\n",
					performance_report[0].throughput * pow(10,-6));
			} else if (total_nodes_number == 4) {
				
				fprintf(logger_script.file, ";%.2f;%.2f\n",
					performance_report[0].throughput * pow(10,-6),
					performance_report[2].throughput * pow(10,-6));
			} else if (total_nodes_number == 6) {
				
				fprintf(logger_script.file, ";%.2f;%.2f;%.2f\n",
					performance_report[0].throughput * pow(10,-6),
					performance_report[2].throughput * pow(10,-6),
					performance_report[4].throughput * pow(10,-6));
			} else if (total_nodes_number == 18) {
				
				fprintf(logger_script.file, ";%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f"
					";%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f"
					";%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f\n",
				
				performance_report[0].throughput * pow(10,-6),
				performance_report[2].throughput * pow(10,-6),
				performance_report[4].throughput * pow(10,-6),
				performance_report[6].throughput * pow(10,-6),
				performance_report[8].throughput * pow(10,-6),
				performance_report[10].throughput * pow(10,-6),
				performance_report[12].throughput * pow(10,-6),
				performance_report[14].throughput * pow(10,-6),
				performance_report[16].throughput * pow(10,-6),
				
				((performance_report[0].total_time_transmitting_in_num_channels[0]
				- performance_report[0].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[2].total_time_transmitting_in_num_channels[0]
				- performance_report[2].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[4].total_time_transmitting_in_num_channels[0]
				- performance_report[4].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[6].total_time_transmitting_in_num_channels[0]
				- performance_report[6].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[8].total_time_transmitting_in_num_channels[0]
				- performance_report[8].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[10].total_time_transmitting_in_num_channels[0]
				- performance_report[10].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[12].total_time_transmitting_in_num_channels[0]
				- performance_report[12].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[14].total_time_transmitting_in_num_channels[0]
				- performance_report[14].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				((performance_report[16].total_time_transmitting_in_num_channels[0]
				- performance_report[16].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
				
				performance_report[0].average_waiting_time * pow(10,3),
				performance_report[2].average_waiting_time * pow(10,3),
				performance_report[4].average_waiting_time * pow(10,3),
				performance_report[6].average_waiting_time * pow(10,3),
				performance_report[8].average_waiting_time * pow(10,3),
				performance_report[10].average_waiting_time * pow(10,3),
				performance_report[12].average_waiting_time * pow(10,3),
				performance_report[14].average_waiting_time * pow(10,3),
				performance_report[16].average_waiting_time * pow(10,3));
			} else {
				printf("Error in Komondor :: Stop(): be care of the desired generated logs (script)\n");
			}
			break;
		}

		
		case 12:{
			
			fprintf(logger_script.file, ";%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f"
				";%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f"
				";%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f\n",
			
			performance_report[0].throughput * pow(10,-6),
			performance_report[2].throughput * pow(10,-6),
			performance_report[4].throughput * pow(10,-6),
			performance_report[6].throughput * pow(10,-6),
			performance_report[8].throughput * pow(10,-6),
			performance_report[10].throughput * pow(10,-6),
			performance_report[12].throughput * pow(10,-6),
			performance_report[14].throughput * pow(10,-6),
			performance_report[16].throughput * pow(10,-6),
			performance_report[18].throughput * pow(10,-6),
			
			((performance_report[0].total_time_transmitting_in_num_channels[0]
			- performance_report[0].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[2].total_time_transmitting_in_num_channels[0]
			- performance_report[2].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[4].total_time_transmitting_in_num_channels[0]
			- performance_report[4].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[6].total_time_transmitting_in_num_channels[0]
			- performance_report[6].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[8].total_time_transmitting_in_num_channels[0]
			- performance_report[8].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[10].total_time_transmitting_in_num_channels[0]
			- performance_report[10].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[12].total_time_transmitting_in_num_channels[0]
			- performance_report[12].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[14].total_time_transmitting_in_num_channels[0]
			- performance_report[14].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[16].total_time_transmitting_in_num_channels[0]
			- performance_report[16].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			((performance_report[18].total_time_transmitting_in_num_channels[0]
			- performance_report[18].total_time_lost_in_num_channels[0])*100/simulation_time_komondor),
			
			performance_report[0].average_waiting_time * pow(10,3),
			performance_report[2].average_waiting_time * pow(10,3),
			performance_report[4].average_waiting_time * pow(10,3),
			performance_report[6].average_waiting_time * pow(10,3),
			performance_report[8].average_waiting_time * pow(10,3),
			performance_report[10].average_waiting_time * pow(10,3),
			performance_report[12].average_waiting_time * pow(10,3),
			performance_report[14].average_waiting_time * pow(10,3),
			performance_report[16].average_waiting_time * pow(10,3),
			performance_report[18].average_waiting_time * pow(10,3));
			break;
		}

		
		case 13: {
			
			
			char label_per_device[250] = "{";
			
			char tpt_per_device[250] = "{";
			char aux_tpt_per_device[50];
			
			char rssi_per_device[250] = "{";
			char aux_rssi_per_device[50];
			
			char data_loss_ratio_per_device[250] = "{";
			char aux_data_loss_ratio_per_device[50];
			
			char rtscts_loss_ratio_per_device[250] = "{";
			char aux_rtscts_loss_ratio_per_device[50];
			
			char time_in_nav_per_device[250] = "{";
			char aux_time_in_nav_per_device[50];
			char aux_time_in_nav_per_sta[50];

			int counter_nodes_visited = 0;
			for(int i = 0; i < total_nodes_number; i ++) {
				
				strcat(label_per_device, configuration_per_node[i].capabilities.node_code.c_str());
				if (i < total_nodes_number - 1) strcat(label_per_device, ",");
				if(configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
					
					sprintf(aux_tpt_per_device, "%.2f,", performance_report[i].throughput * pow(10,-6));
					strcat(tpt_per_device, aux_tpt_per_device);
					
					strcat(rssi_per_device, "Inf,");
					
					sprintf(aux_data_loss_ratio_per_device, "%.2f,", (double)
						100*performance_report[i].data_packets_lost/performance_report[i].data_packets_sent);
					strcat(data_loss_ratio_per_device, aux_data_loss_ratio_per_device);
					
					sprintf(aux_rtscts_loss_ratio_per_device, "%.2f,", (double)
						100*performance_report[i].rts_cts_lost/performance_report[i].rts_cts_sent);
					strcat(rtscts_loss_ratio_per_device, aux_rtscts_loss_ratio_per_device);
					
					++counter_nodes_visited;
					for(int w = 0; w < total_wlans_number; w ++) {
						if(wlan_container[w].ap_id == configuration_per_node[i].capabilities.node_id) {
							for(int s = 0; s < wlan_container[w].num_stas; s ++) {
								
								char sta_details[250] = "";
								
								sprintf(aux_tpt_per_device, "%.2f", performance_report[i].throughput_per_sta[s] * pow(10,-6));
								strcat(tpt_per_device, aux_tpt_per_device);
								strcat(sta_details, aux_tpt_per_device);
								strcat(sta_details, ";");
								
								sprintf(aux_rssi_per_device, "%.2f", ConvertPower(PW_TO_DBM,
									performance_report[counter_nodes_visited].received_power_array[i]));
								strcat(rssi_per_device, aux_rssi_per_device);
								strcat(sta_details, aux_rssi_per_device);
								strcat(sta_details, ";");
								
								sprintf(aux_data_loss_ratio_per_device, "%.2f", (double)
									100*performance_report[i].data_packets_lost_per_sta[s]/
									performance_report[i].data_packets_sent_per_sta[s]);
								strcat(data_loss_ratio_per_device, aux_data_loss_ratio_per_device);
								strcat(sta_details, aux_data_loss_ratio_per_device);
								strcat(sta_details, ";");
								
								sprintf(aux_rtscts_loss_ratio_per_device, "%.2f", (double)
									100*performance_report[i].rts_cts_lost_per_sta[s]/
									performance_report[i].rts_cts_sent_per_sta[s]);
								strcat(rtscts_loss_ratio_per_device, aux_rtscts_loss_ratio_per_device);
								strcat(sta_details, aux_rtscts_loss_ratio_per_device);
								strcat(sta_details, ";");
								
								sprintf(aux_time_in_nav_per_sta, "%.2f", performance_report[i+s+1].time_in_nav/simulation_time_komondor*100);
								strcat(sta_details,aux_time_in_nav_per_sta);
								
								++counter_nodes_visited;
								if(counter_nodes_visited < total_nodes_number){
									strcat(tpt_per_device, ",");
									strcat(rssi_per_device, ",");
									strcat(data_loss_ratio_per_device, ",");
									strcat(rtscts_loss_ratio_per_device, ",");}
								

							}
						}
					}
				}
				
				sprintf(aux_time_in_nav_per_device, "%.2f", performance_report[i].time_in_nav/simulation_time_komondor*100);
				strcat(time_in_nav_per_device, aux_time_in_nav_per_device);
				if(i < total_nodes_number-1) strcat(time_in_nav_per_device, ",");
			}
			strcat(label_per_device, "}");
			strcat(tpt_per_device, "}");
			strcat(rssi_per_device, "}");
			strcat(data_loss_ratio_per_device, "}");
			strcat(rtscts_loss_ratio_per_device, "}");
			strcat(time_in_nav_per_device, "}");

			
			fprintf(logger_script.file, ";%s;%s;%s;%s;%s;%s\n", label_per_device, tpt_per_device,rssi_per_device,
				data_loss_ratio_per_device,rtscts_loss_ratio_per_device,time_in_nav_per_device);

			break;
		}

		
		case 14: {
			
			char tpt_array[250] = "";
			char aux_tpt[50];
			
			char airtime_array[250] = "";
			char aux_airtime[50];
			
			char sairtime_array[250] = "";
			char aux_sairtime[50];
			
			char max_power_in_ap_per_wlan[1000] = "";
			char aux_power_in_ap[250];

			for(int i = 0; i < total_nodes_number; i ++) {
				if (configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
					
					sprintf(aux_tpt, "%.2f", performance_report[i].throughput * pow(10,-6));
					strcat(tpt_array, aux_tpt);
					strcat(tpt_array, ";");
					
					sprintf(aux_airtime, "%.2f", ((performance_report[i].total_time_transmitting_in_num_channels[0]
					 - performance_report[i].total_time_lost_in_num_channels[i])*100/simulation_time_komondor));
					strcat(airtime_array, aux_airtime);
					strcat(airtime_array, ";");
					
					sprintf(aux_sairtime, "%.2f", (performance_report[i].total_time_transmitting_in_num_channels[0]*100/simulation_time_komondor));
					strcat(sairtime_array, aux_sairtime);
					strcat(sairtime_array, ";");
					
					
					strcat(max_power_in_ap_per_wlan, "{");
					for(int w = 0; w < total_wlans_number; w ++) {
						
						
						sprintf(aux_power_in_ap, "%.2f", ConvertPower(PW_TO_DBM,
							performance_report[i].max_received_power_in_ap_per_wlan[w]));
						strcat(max_power_in_ap_per_wlan, aux_power_in_ap);
						
						if (w < total_wlans_number-1) strcat(max_power_in_ap_per_wlan, ",");
					}
					strcat(max_power_in_ap_per_wlan, "};");
				}
			}

			fprintf(logger_script.file, ";%s%s%s%s\n", tpt_array, airtime_array, sairtime_array, max_power_in_ap_per_wlan);
			break;

		}

        
        case 15: {
            
            
            char tpt_per_device[1500] = "{";
            char aux_tpt_per_device[1500];
            
            char airtime_per_bss[1500] = "{";
            char aux_airtime[1500];
            
            char rssi_per_device[2000] = "{";
            char aux_rssi_per_device[2000];
            
            char power_per_ap[1500] = "{";
            char aux_power_per_ap[1500];
            
            char sinr_per_device[1500] = "{";
            char aux_sinr_per_device[1500];
            
            
            int counter_nodes_visited = 0;
            int counter_bss_visited = 0;
            
            int first_channel_selected = 0;
            int last_channel_selected = 0;
            for(int i = 0; i < total_nodes_number; i ++) {
                if(configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
                    first_channel_selected = performance_report[i].min_channel_allowed;
                    last_channel_selected = performance_report[i].max_channel_allowed;
                    
                    sprintf(aux_tpt_per_device, "%.2f,", performance_report[i].throughput * pow(10,-6));
                    strcat(tpt_per_device, aux_tpt_per_device);
                    
                    for (int j = 0; j < last_channel_selected-first_channel_selected+1; ++j) {
                        if (j < last_channel_selected-first_channel_selected) {
                            sprintf(aux_airtime, "%.2f,", (performance_report[i].total_time_spectrum_per_channel[first_channel_selected+j] * 100 /simulation_time_komondor));
                            strcat(airtime_per_bss, aux_airtime);
                        } else {
                            sprintf(aux_airtime, "%.2f", (performance_report[i].total_time_spectrum_per_channel[first_channel_selected+j] * 100 /simulation_time_komondor));
                            strcat(airtime_per_bss, aux_airtime);
                        }
                    }
                    sprintf(aux_airtime, ";");
                    strcat(airtime_per_bss, aux_airtime);
                    
                    
                    strcat(rssi_per_device, "Inf,");
                    
                    ++counter_nodes_visited;
                    ++counter_bss_visited;
                    
                    int counter_aps_visited = 0;
                    for(int j = 0; j < total_nodes_number; j ++) {
                        
                        if (configuration_per_node[j].capabilities.node_type == NODE_TYPE_AP) {
                            ++counter_aps_visited;
                            if (i == j) {
                                sprintf(aux_power_per_ap, "Inf");
                            } else {
                                sprintf(aux_power_per_ap, "%.2f", ConvertPower(PW_TO_DBM,
                                        performance_report[i].received_power_array[j]));
                            }
                            strcat(power_per_ap, aux_power_per_ap);
                            if (counter_aps_visited < total_wlans_number) {
                                strcat(power_per_ap, ",");
                            } else {
                                if (counter_bss_visited < total_wlans_number) {
                                    strcat(power_per_ap, ";\n");
                                } else {
                                    strcat(power_per_ap, "}");
                                }
                            }
                        }
                    }
                    for(int w = 0; w < total_wlans_number; w ++) {
                        
                        if(wlan_container[w].ap_id == configuration_per_node[i].capabilities.node_id) {
                            for(int s = 0; s < wlan_container[w].num_stas; s ++) {
                                
                                sprintf(aux_tpt_per_device, "%.2f", performance_report[i].throughput_per_sta[s] * pow(10,-6));
                                strcat(tpt_per_device, aux_tpt_per_device);
                                
                                sprintf(aux_rssi_per_device, "%.2f", ConvertPower(PW_TO_DBM,
                                     performance_report[counter_nodes_visited].received_power_array[i]));
                                strcat(rssi_per_device, aux_rssi_per_device);
                                
                                ++counter_nodes_visited;
                                if(counter_nodes_visited < total_nodes_number){
                                    strcat(tpt_per_device, ",");
                                    strcat(rssi_per_device, ",");
                                }
                            }
                        }
                    }
                }
            }
            strcat(tpt_per_device, "}");
            strcat(airtime_per_bss, "}");
            strcat(rssi_per_device, "}");

            
            for(int i = 0; i < total_nodes_number; i ++) {
                if (configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
                    strcat(sinr_per_device, "Inf");
                } else {
                    sprintf(aux_sinr_per_device, "%.2f", ConvertPower(LINEAR_TO_DB, performance_report[i].average_sinr));
                    strcat(sinr_per_device, aux_sinr_per_device);
                }
                if (i < total_nodes_number - 1) {
                    strcat(sinr_per_device, ",");
                } else {
                    strcat(sinr_per_device, "}");
                }
            }

            
            fprintf(logger_script.file, "\n%s\n%s\n%s\n%s\n%s\n",
                    tpt_per_device, airtime_per_bss, rssi_per_device, power_per_ap, sinr_per_device);

            break;
        }

        
		case 16: {
			
			
			char tpt_per_device[1500];
			char aux_tpt_per_device[1500];
			
			char power_per_ap[1500];
			char aux_power_per_ap[1500];
			
			char rssi_per_device[2000];
			char aux_rssi_per_device[2000];
			
			char sinr_per_device[1500];
			char aux_sinr_per_device[1500];
			
			
			int counter_nodes_visited = 0;
			int counter_bss_visited = 0;
			for(int i = 0; i < wlan_container[0].num_stas + 1; i ++) {
				if(configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
					


					

					
					++counter_nodes_visited;
					++counter_bss_visited;
					
					int counter_aps_visited = 0;
					for(int j = 0; j < total_nodes_number; j ++) {
						
						if (configuration_per_node[j].capabilities.node_type == NODE_TYPE_AP) {
							++counter_aps_visited;
							if (i == j) {
								
							} else {
								sprintf(aux_power_per_ap, "%.2f", ConvertPower(PW_TO_DBM,
										performance_report[i].received_power_array[j]));
							}
							strcat(power_per_ap, aux_power_per_ap);
							if (counter_aps_visited < total_wlans_number && counter_aps_visited > 1) {
								strcat(power_per_ap, ",");
							} else {
								if (counter_aps_visited < total_wlans_number) {
									
								} else {
									
								}
							}
						}
					}
					for(int w = 0; w < 1; w ++) {
						
						if(wlan_container[w].ap_id == configuration_per_node[i].capabilities.node_id) {
							for(int s = 0; s < wlan_container[w].num_stas; s ++) {
								
								sprintf(aux_tpt_per_device, "%.2f", performance_report[i].throughput_per_sta[s] * pow(10,-6));
								strcat(tpt_per_device, aux_tpt_per_device);
								
								sprintf(aux_rssi_per_device, "%.2f", ConvertPower(PW_TO_DBM,
									 performance_report[counter_nodes_visited].received_power_array[i]));
								strcat(rssi_per_device, aux_rssi_per_device);
								
								++counter_nodes_visited;
								if(counter_nodes_visited < wlan_container[w].num_stas+1){
									strcat(tpt_per_device, ",");
									strcat(rssi_per_device, ",");
								}
							}
						}
					}
				}
			}
			
			

			
			for(int i = 0; i < wlan_container[0].num_stas + 1; i ++) {
				if (configuration_per_node[i].capabilities.node_type == NODE_TYPE_AP) {
					
				} else {
					sprintf(aux_sinr_per_device, "%.2f", ConvertPower(LINEAR_TO_DB, performance_report[i].average_sinr));
					strcat(sinr_per_device, aux_sinr_per_device);
				}
				if (i > 0 && i < wlan_container[0].num_stas) {
					strcat(sinr_per_device, ",");
				} else if (i == wlan_container[0].num_stas) {
					
				}
			}

			
			fprintf(logger_script.file, "\n%s\n%s\n%s\n%s\n",
					tpt_per_device, power_per_ap, rssi_per_device, sinr_per_device);

			break;
		}

		default:{
		  printf("No simulation type found\n");
		  break;
		}

	}

}

#endif


#line 72 "komondor_main.cc"



#line 1 "node.h"













































 




#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <iostream>
#include <stdlib.h>


#line 1 "../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 57 "node.h"


#line 1 "../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "node.h"


#line 1 "../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../methods/power_channel_methods.h"


#line 1 "../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../methods/power_channel_methods.h"


#line 1 "../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 59 "node.h"


#line 1 "../methods/backoff_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>

#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 55 "../methods/backoff_methods.h"



double	Random2( double v=1.0)	{ return v*drand48();}
int		Random2( int v)		{ return (int)(v*drand48()); }
double	Exponential2(double mean)	{ return -mean*log(Random2());}








double ComputeBackoff(int pdf_backoff, int cw, int backoff_type){

	double backoff_time;
	double expected_backoff ((double) (cw-1)/2);	
	double lambda_backoff (1/(expected_backoff * SLOT_TIME));

	switch(pdf_backoff){

		case PDF_DETERMINISTIC:{
			if(backoff_type == BACKOFF_SLOTTED) {
				int num_slots (rand() % cw); 
				backoff_time = num_slots * SLOT_TIME;
				
			} else if(backoff_type == BACKOFF_CONTINUOUS) {
				backoff_time = 1/lambda_backoff;
			}
			break;
		}

		case PDF_EXPONENTIAL:{
			if(backoff_type == BACKOFF_SLOTTED) {
				backoff_time = round(Exponential2(expected_backoff)) * SLOT_TIME;
			} else if(backoff_type == BACKOFF_CONTINUOUS) {
				backoff_time = Exponential2(1/lambda_backoff);
			}
			break;
		}

		default:{
			printf("Backoff model not found!\n");
			break;
		}
	}

	return backoff_time;

}







double ComputeRemainingBackoff(int backoff_type, double remaining_backoff){

	double updated_remaining_backoff;

	switch(backoff_type){

		case BACKOFF_SLOTTED: {
			int closest_slot (round(remaining_backoff / SLOT_TIME));

			if(fabs(remaining_backoff - closest_slot * SLOT_TIME) < MAX_DIFFERENCE_SAME_TIME){
				updated_remaining_backoff = closest_slot * SLOT_TIME;
			} else {
				updated_remaining_backoff = ceil(remaining_backoff/SLOT_TIME) * SLOT_TIME;
			}
			break;
		}

		case BACKOFF_CONTINUOUS: {
			updated_remaining_backoff = remaining_backoff;
			break;
		}

		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}

	}

	return updated_remaining_backoff;

}










int HandleBackoff(int pause_or_resume, double **channel_power, int primary_channel, double pd,
	int packets_in_buffer){

	int backoff_action (FALSE);

	switch(pause_or_resume){

		case PAUSE_TIMER:{
			if((*channel_power)[primary_channel] > pd) backoff_action = TRUE;
			break;
		}

		case RESUME_TIMER:{
			if(packets_in_buffer > 0) {
				if((*channel_power)[primary_channel] <= pd) backoff_action =  TRUE;
			}
			break;
		}

		default:{
			printf("Unknown handle backoff mode! (not resume nor pause)\n");
			exit(EXIT_FAILURE);
		}
	}

	return backoff_action;

}










void HandleContentionWindow(int cw_adaptation, int increase_or_reset, int* cw_current, int cw_min,
		int *cw_stage_current, int cw_stage_max) {
	if(cw_adaptation == TRUE){
		switch(increase_or_reset) {
			case INCREASE_CW:{
				if(*cw_stage_current < cw_stage_max){
					*cw_stage_current = *cw_stage_current + 1;
					*cw_current = cw_min * pow(2, *cw_stage_current);
				}
				break;
			}
			case RESET_CW:{
				*cw_stage_current = 0;
				*cw_current = cw_min;
				break;
			}
			default:{
				printf("Unknown operation on contention window!");
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {
		
	}
}


#line 60 "node.h"


#line 1 "../methods/modulations_methods.h"













































 






#include <math.h>
#include <algorithm>
#include <stddef.h>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 57 "../methods/modulations_methods.h"







void SelectMCSResponse(int *mcs_response, double power_rx_interest) {

	double pw_rx_intereset_dbm (ConvertPower(PW_TO_DBM, power_rx_interest));

	for ( int ch_num_ix = 0; ch_num_ix < 4; ++ ch_num_ix ){	

		if(pw_rx_intereset_dbm < -82 +(ch_num_ix*3)){ mcs_response[ch_num_ix] = MODULATION_FORBIDDEN; }
		else if (pw_rx_intereset_dbm >= -82 + (ch_num_ix*3) && pw_rx_intereset_dbm < -79 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_BPSK_1_2;}
		else if (pw_rx_intereset_dbm >= -79 + (ch_num_ix*3) && pw_rx_intereset_dbm < -77 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_QPSK_1_2;}
		else if (pw_rx_intereset_dbm >= -77 + (ch_num_ix*3) && pw_rx_intereset_dbm < -74 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_QPSK_3_4;}
		else if (pw_rx_intereset_dbm >= -74 + (ch_num_ix*3) && pw_rx_intereset_dbm < -70 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_16QAM_1_2;}
		else if (pw_rx_intereset_dbm >= -70 + (ch_num_ix*3) && pw_rx_intereset_dbm < -66 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_16QAM_3_4;}
		else if (pw_rx_intereset_dbm >= -66 + (ch_num_ix*3) && pw_rx_intereset_dbm < -65 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_64QAM_2_3;}
		else if (pw_rx_intereset_dbm >= -65 + (ch_num_ix*3) && pw_rx_intereset_dbm < -64 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_64QAM_3_4;}
		else if (pw_rx_intereset_dbm >= -64 + (ch_num_ix*3) && pw_rx_intereset_dbm < -59 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_64QAM_5_6;}
		else if (pw_rx_intereset_dbm >= -59 + (ch_num_ix*3) && pw_rx_intereset_dbm < -57 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_256QAM_3_4;}
		else if (pw_rx_intereset_dbm >= -57 + (ch_num_ix*3) && pw_rx_intereset_dbm < -54 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_256QAM_5_6;}
		else if (pw_rx_intereset_dbm >= -54 + (ch_num_ix*3) && pw_rx_intereset_dbm < -52 +(ch_num_ix*3)){mcs_response[ch_num_ix] = MODULATION_1024QAM_3_4;}
		else { mcs_response[ch_num_ix] = MODULATION_1024QAM_5_6;}
	}
}









double ComputeEbToNoise(double sinr, double bit_rate, int bandwidth, int modulation_type){

	double Es_to_N0 (sinr * (bit_rate/bandwidth));
	
	double Eb_to_N0 (Es_to_N0 * log2(modulation_type));
	

	return Eb_to_N0;

}


#line 61 "node.h"


#line 1 "../methods/notification_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>

#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 55 "../methods/notification_methods.h"














LogicalNack GenerateLogicalNack(int packet_type, int packet_id, int node_id,
		int node_id_a, int node_id_b, int loss_reason, double ber, double sinr){

	LogicalNack logical_nack;

	logical_nack.packet_type = packet_type;
	logical_nack.source_id = node_id;
	logical_nack.packet_id = packet_id;
	logical_nack.loss_reason = loss_reason;
	logical_nack.node_id_a = node_id_a;
	logical_nack.node_id_b = node_id_b;
	logical_nack.ber = ber;
	logical_nack.sinr = sinr;

	return logical_nack;
}















int ProcessNack(LogicalNack logical_nack, int node_id, Logger node_logger, int node_state,
		int save_node_logs,	double sim_time, int *nacks_received,
		int total_nodes_number, int *nodes_transmitting) {

	int reason (PACKET_NOT_LOST);

	
	int node_a (logical_nack.node_id_a);
	int node_b (logical_nack.node_id_b);

	if(node_a == node_id ||  node_b == node_id){		





		
		++ nacks_received[logical_nack.loss_reason] ;

		switch(logical_nack.loss_reason){

			case PACKET_LOST_DESTINATION_TX:{	

				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s Destination N%d was transmitting!s\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2, logical_nack.source_id);




				reason = PACKET_LOST_DESTINATION_TX;

				break;
			}

			case PACKET_LOST_LOW_SIGNAL:{	

				if(save_node_logs) fprintf(node_logger.file,
						"%.12f;N%d;S%d;%s;%s Power received in destination N%d is less than the required capture effect!\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2, logical_nack.source_id);

				reason = PACKET_LOST_LOW_SIGNAL;

				break;
			}

			case PACKET_LOST_INTERFERENCE:{ 	

				if(save_node_logs) fprintf(node_logger.file,
					"%.12f;N%d;S%d;%s;%s High interferences sensed in destination N%d (capture effect not accomplished)!\n",
					sim_time, node_id, node_state, LOG_H02, LOG_LVL2, logical_nack.source_id);





				






				reason = PACKET_LOST_INTERFERENCE;

				break;
			}

			case PACKET_LOST_PURE_COLLISION:{	

				if(save_node_logs) fprintf(node_logger.file,
					"%.12f;N%d;S%d;%s;%s Pure collision detected at destination %d! %d was transmitting and %d appeared\n",
					sim_time, node_id, node_state, LOG_H02, LOG_LVL2, logical_nack.source_id,
					node_a, node_b);








				reason = PACKET_LOST_PURE_COLLISION;

				break;
			}

			case PACKET_LOST_LOW_SIGNAL_AND_RX:{ 

				
				if(node_a == node_id) {

					if(save_node_logs) fprintf(node_logger.file,
						"%.12f;N%d;S%d;%s;%s Destination N%d already receiving from N%d and N%d transmitted with not enough"
						" power to be decoded\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2, logical_nack.source_id, node_a, node_b);



					reason = PACKET_LOST_LOW_SIGNAL_AND_RX;

				}

				break;
			}

			case PACKET_LOST_SINR_PROB:{	

				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s Packet lost due constant PER or due to the BER (%f) "
					"associated to the current SINR (%f dB)\n", sim_time, node_id, node_state, LOG_H02, LOG_LVL2,
					logical_nack.ber, ConvertPower(LINEAR_TO_DB, logical_nack.sinr));

				reason = PACKET_LOST_SINR_PROB;

				break;
			}

			case PACKET_LOST_RX_IN_NAV:{			
				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s Packet lost due to STA was in NAV\n",
					sim_time, node_id, node_state, LOG_H02, LOG_LVL2);

				reason = PACKET_LOST_RX_IN_NAV;

				break;
			}

			case PACKET_LOST_BO_COLLISION:{
				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s Packet lost due to Slotted Backoff\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2);

				reason = PACKET_LOST_BO_COLLISION;

				break;
			}

			case PACKET_LOST_OUTSIDE_CH_RANGE:{	




				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s AP is sending packets outside STAs range!\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2);

				reason = PACKET_LOST_LOW_SIGNAL_AND_RX;
				

				break;
			}

			case PACKET_LOST_CAPTURE_EFFECT: {

				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s Packet lost by Capture Effect!\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2);

				reason = PACKET_LOST_CAPTURE_EFFECT;
				

				break;

			}

			default:{

				if(save_node_logs) fprintf(node_logger.file, "%.12f;N%d;S%d;%s;%s Unknown reason for packet loss\n",
						sim_time, node_id, node_state, LOG_H02, LOG_LVL2);
				exit(EXIT_FAILURE);
				break;
			}

		}

	} else {	


	}

	return reason;
}





void CleanNack(LogicalNack *nack){
	nack->source_id = NODE_ID_NONE;
	nack->packet_id = NO_PACKET_ID;
	nack->loss_reason = PACKET_NOT_LOST;
	nack->node_id_a = NODE_ID_NONE;
	nack->node_id_b = NODE_ID_NONE;
}
















void handlePacketLoss(int type, double *total_time_lost_in_num_channels, double *total_time_lost_per_channel,
		int &packets_lost, int &rts_cts_lost, int **packets_lost_per_sta, int **rts_cts_lost_per_sta,
		int current_right_channel, int current_left_channel, double current_tx_duration, int node_id, int destination_id){





	if(type == PACKET_TYPE_DATA) {
		for(int c = current_left_channel; c <= current_right_channel; c++){
			total_time_lost_per_channel[c] += current_tx_duration;
		}
		total_time_lost_in_num_channels[current_right_channel - current_left_channel] += current_tx_duration;
		++packets_lost;
		++(*packets_lost_per_sta)[destination_id-node_id-1];
	} else if(type == PACKET_TYPE_CTS){
		++rts_cts_lost;
		++(*rts_cts_lost_per_sta)[destination_id-node_id-1];
	}


}













int AttemptToDecodePacket(double sinr, double capture_effect, double pd,
		double power_rx_interest, double constant_per, int node_id, int packet_type,
		int destination_id){

	int packet_lost;
	double per (0);

	
	if(sinr < capture_effect || power_rx_interest < pd) {
		per = 1;
	} else {
		
		if( (destination_id == node_id) && (packet_type == PACKET_TYPE_DATA) ){
			per = constant_per;
		}
	}

	packet_lost = ((double) rand() / (RAND_MAX)) < per;

	return packet_lost;
}















int IsPacketLost(int primary_channel, Notification incoming_notification, Notification new_notification,
		double sinr, double capture_effect, double pd, double power_rx_interest, double constant_per,
		int node_id, int capture_effect_model){

	int loss_reason (PACKET_NOT_LOST);
	int is_packet_lost;	

	switch(capture_effect_model) {

		case CE_DEFAULT: {

			
			
			
			

			
			if(primary_channel >= incoming_notification.left_channel && primary_channel <= incoming_notification.right_channel){

				
				is_packet_lost = AttemptToDecodePacket(sinr, capture_effect, pd, power_rx_interest, constant_per, node_id,
					new_notification.packet_type, new_notification.destination_id);

				if (is_packet_lost) {	
					if (power_rx_interest < pd) {	
						loss_reason = PACKET_LOST_LOW_SIGNAL;

					} else if (sinr < capture_effect){	
						loss_reason = PACKET_LOST_INTERFERENCE;
					} else {	
						loss_reason = PACKET_LOST_SINR_PROB;
					}
				}

			} else{

				loss_reason = PACKET_LOST_OUTSIDE_CH_RANGE;

			}

			break;
		}

		case CE_IEEE_802_11: {

			
			if (power_rx_interest > pd) {
				
				loss_reason = -1;
			} else {
				loss_reason = PACKET_LOST_LOW_SIGNAL;
			}

			break;
		}

	}

	return loss_reason;

}


















TxInfo GenerateTxInfo(int num_packets_aggregated, double data_duration,	double ack_duration,
		double rts_duration, double cts_duration, double current_tx_power, int num_channels_tx,
		int bits_ofdm_sym, double x, double y, double z, double flag_change_in_tx_power) {

	TxInfo tx_info;
	tx_info.SetSizeOfMCS(4);	

	tx_info.num_packets_aggregated = num_packets_aggregated;
	tx_info.data_duration = data_duration;
	tx_info.ack_duration = ack_duration;
	tx_info.rts_duration = rts_duration;
	tx_info.cts_duration = cts_duration;
	tx_info.tx_power = ComputeTxPowerPerChannel(current_tx_power, num_channels_tx);
	tx_info.bits_ofdm_sym = bits_ofdm_sym;
	tx_info.x = x;
	tx_info.y = y;
	tx_info.z = z;
	tx_info.nav_time = 0;
    tx_info.flag_change_in_tx_power = flag_change_in_tx_power;

	return tx_info;

}


#line 62 "node.h"


#line 1 "../methods/time_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>

#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 55 "../methods/time_methods.h"



double	Random( double v=1.0)	{ return v*drand48();}
int	Random( int v)	{ return (int)(v*drand48()); }
double	Exponential(double mean){ return -mean*log(Random());}








int findMaximumPacketsAggregated(int num_packets_aggregated, int data_packet_length, double bits_ofdm_sym){

	double data_duration;
	int limited_num_packets_aggregated (num_packets_aggregated);

	while (limited_num_packets_aggregated > 0) {

		data_duration = IEEE_AX_PHY_HE_SU_DURATION
			+ ceil( ( (double) IEEE_AX_SF_LENGTH + (double) limited_num_packets_aggregated
			* ( (double) IEEE_AX_MD_LENGTH + (double) IEEE_AX_MH_LENGTH + (double) data_packet_length ) )
			/ bits_ofdm_sym ) * IEEE_AX_OFDM_SYMBOL_GI32_DURATION;

		if(data_duration <= IEEE_AX_MAX_PPDU_DURATION) {
			break;
		} else {
			limited_num_packets_aggregated--;
		}
	}

	return limited_num_packets_aggregated;

}








double ComputeTxTime(int total_bits, double data_rate, int pdf_tx_time){

	double tx_time;

	
	

	switch(pdf_tx_time){

		case PDF_DETERMINISTIC:{
			tx_time = total_bits/data_rate;
			break;
		}

		case PDF_EXPONENTIAL:{
			tx_time = Exponential(total_bits/data_rate);
			break;
		}

		default:{
			printf("TX time model not found!\n");
			exit(EXIT_FAILURE);
		}
	}

	
	
	

	return tx_time;
}






double computeRtsTxTime80211ax(double bits_ofdm_sym_legacy){




	return (IEEE_AX_PHY_LEGACY_DURATION + ceil((double) (IEEE_AX_SF_LENGTH +
		(double) IEEE_AX_RTS_LENGTH) / bits_ofdm_sym_legacy) * IEEE_AX_OFDM_SYMBOL_LEGACY);

}






double computeCtsTxTime80211ax(double bits_ofdm_sym_legacy){






	return (IEEE_AX_PHY_LEGACY_DURATION + ceil((double) (IEEE_AX_SF_LENGTH +
		(double) IEEE_AX_CTS_LENGTH) / bits_ofdm_sym_legacy) * IEEE_AX_OFDM_SYMBOL_LEGACY);

}








double computeDataTxTime80211ax(int num_packets_aggregated, int data_packet_length, double bits_ofdm_sym){

	double data_duration;

	if(num_packets_aggregated == 1){

		data_duration = IEEE_AX_PHY_HE_SU_DURATION
			+ ceil( ( (double) IEEE_AX_SF_LENGTH + (double) IEEE_AX_MH_LENGTH +
			(double) data_packet_length) / bits_ofdm_sym ) * IEEE_AX_OFDM_SYMBOL_GI32_DURATION;

	} else {

		data_duration = IEEE_AX_PHY_HE_SU_DURATION
			+ ceil( ( (double) IEEE_AX_SF_LENGTH + (double) num_packets_aggregated
			* ( (double) IEEE_AX_MD_LENGTH + (double) IEEE_AX_MH_LENGTH + (double) data_packet_length ) )
			/ bits_ofdm_sym ) * IEEE_AX_OFDM_SYMBOL_GI32_DURATION;

	}










	return data_duration;

}







double computeAckTxTime80211ax(int num_packets_aggregated, double bits_ofdm_sym_legacy){

	double ack_duration;

	if(num_packets_aggregated == 1){
		ack_duration = IEEE_AX_PHY_LEGACY_DURATION + ceil((double) (IEEE_AX_SF_LENGTH +
			(double) IEEE_AX_ACK_LENGTH) / bits_ofdm_sym_legacy) * IEEE_AX_OFDM_SYMBOL_LEGACY;

		ack_duration = 28 / pow(10,6);

	} else {
		ack_duration = IEEE_AX_PHY_LEGACY_DURATION + ceil((double) (IEEE_AX_SF_LENGTH +
			(double) IEEE_AX_BACK_LENGTH) / bits_ofdm_sym_legacy) * IEEE_AX_OFDM_SYMBOL_LEGACY;

		ack_duration = 32 / pow(10,6);

	}

	
	ack_duration = 32 / pow(10,6);
	return ack_duration;

}











double ComputeNavTime(int node_state, double rts_duration, double cts_duration,
	double data_duration, double ack_duration, double sifs){

	double nav_time;

	switch(node_state){

		case STATE_TX_RTS:{
			
			nav_time = 3 * sifs + rts_duration + cts_duration + data_duration + ack_duration;
			break;
		}

		case STATE_TX_CTS:{
			
			nav_time = 2 * sifs + cts_duration + data_duration + ack_duration;
			break;
		}

		case STATE_TX_DATA:{
			
			nav_time = sifs + data_duration + ack_duration;
			break;
		}

		case STATE_TX_ACK:{
			
			nav_time = ack_duration;
			break;
		}

		default:{

			printf("ERROR: Unreachable state\n");
			exit(EXIT_FAILURE);
		}
	}

	return nav_time;

}














void ComputeFramesDuration(double *rts_duration, double *cts_duration,
	double *data_duration, double *ack_duration, int num_channels_tx, int current_modulation,
	int num_packets_aggregated, int data_packet_length, int bits_ofdm_sym){

	
	*rts_duration = computeRtsTxTime80211ax(IEEE_BITS_OFDM_SYM_LEGACY);
	*cts_duration = computeCtsTxTime80211ax(IEEE_BITS_OFDM_SYM_LEGACY);
	*data_duration = computeDataTxTime80211ax(num_packets_aggregated,
			data_packet_length, bits_ofdm_sym);
	*ack_duration = computeAckTxTime80211ax(num_packets_aggregated, IEEE_BITS_OFDM_SYM_LEGACY);

}


#line 63 "node.h"


#line 1 "../methods/spatial_reuse_methods.h"













































 










#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 61 "../methods/spatial_reuse_methods.h"


#line 1 "../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 62 "../methods/spatial_reuse_methods.h"









int CheckPacketOrigin(Notification notification, int bss_color, int srg) {

	int type_of_packet;
	int bss_color_enabled (false);
	if (notification.tx_info.bss_color >= 0 && bss_color >= 0) bss_color_enabled = true;

	if (!bss_color_enabled) {
		type_of_packet = INTRA_BSS_FRAME;
	} else {
		if ( notification.tx_info.bss_color == bss_color && notification.tx_info.bss_color > 0 ) {
			type_of_packet = INTRA_BSS_FRAME;
		} else {
			if ( notification.tx_info.srg == srg && notification.tx_info.srg > 0) {
				type_of_packet = SRG_FRAME;
			} else {
				type_of_packet = NON_SRG_FRAME;
			}
		}
	}

	return type_of_packet;

}










double GetSensitivitySpatialReuse( int type_last_sensed_packet, double srg_obss_pd,
	double non_srg_obss_pd, double pd_default, double power_received ) {

	double pd_spatial_reuse_pw;
	
	switch(type_last_sensed_packet) {
		case NON_SRG_FRAME:{
			pd_spatial_reuse_pw = non_srg_obss_pd;
			break;
		}
		case SRG_FRAME:{
			pd_spatial_reuse_pw = srg_obss_pd;
			break;
		}
		default:{
			pd_spatial_reuse_pw = pd_default;
			break;
		}
	}
	return pd_spatial_reuse_pw;

}







int IdentifySpatialReuseOpportunity( double power_received, double current_obss_pd) {
	if (power_received < current_obss_pd) {
		return 1;
	} else {
		return 0;
	}
}







double ApplyTxPowerRestriction(double current_pd, double current_tx_power) {

	double tx_power_pw;

	double current_pd_dbm = ConvertPower(PW_TO_DBM, current_pd);

	if (current_pd_dbm <= OBSS_PD_MIN) {
		tx_power_pw = current_tx_power; 
	} else {
		tx_power_pw = ConvertPower(DBM_TO_PW, TX_PWR_REF - (current_pd_dbm - OBSS_PD_MIN));
	}

	
	if (tx_power_pw > ConvertPower(DBM_TO_PW, MAX_TX_PWR_SR)) {
		tx_power_pw = ConvertPower(DBM_TO_PW, MAX_TX_PWR_SR);
	}

	return tx_power_pw;

}









void UpdateTypeOngoingTransmissions(int *type_ongoing_transmissions,
	Notification notification, int bss_color, int srg, int enter_or_leave) {

	
	int packet_type_source = CheckPacketOrigin(notification, bss_color, srg);

	
	if (enter_or_leave) {	
		type_ongoing_transmissions[packet_type_source] = 1;
	} else {				
		type_ongoing_transmissions[packet_type_source] = 0;
	}

}








int CheckObssPdConstraints(double current_obss_pd, double obss_pd_min, double obss_pd_max,
		double tx_power_ref, double tx_power) {
	double obss_pd_ref_dbm = std::max(ConvertPower(PW_TO_DBM, obss_pd_min),
		std::min(ConvertPower(PW_TO_DBM, obss_pd_max), ConvertPower(PW_TO_DBM, obss_pd_min)
		+ (ConvertPower(PW_TO_DBM, tx_power_ref) - ConvertPower(PW_TO_DBM,tx_power))));
	if( ConvertPower(PW_TO_DBM, current_obss_pd) <=  obss_pd_ref_dbm ) {
		
		return 1;
	} else {
		
		return 0;
	}
}




int CheckPowerConstraints(double current_obss_pd, double obss_pd_min, double obss_pd_max) {
	if (current_obss_pd <= obss_pd_min) {
		
		return 1;
	} else {
		
		return 0;
	}
}


#line 64 "node.h"


#line 1 "../structures/notification.h"













































 



#ifndef _AUX_NOTIFICATION_
#define _AUX_NOTIFICATION_


struct TxInfo
{

	int num_packets_aggregated;				
	int *list_id_aggregated;				
	double *timestamp_frames_aggregated;	

	
	double data_duration;		
	double ack_duration;		
	double rts_duration;		
	double cts_duration;		

	double preoccupancy_duration;	
	double total_tx_power;			
	double tx_power;				
	double tx_gain;					
	double pd;						
	double bits_ofdm_sym; 			
	double data_rate; 				
	int modulation_schemes[4];		
	double x;						
	double y;						
	double z;						
	double nav_time;				

	bool flag_change_in_tx_power;	

	
	int bss_color;				
	int srg;					
	bool txop_sr_identified;	

	





	void PrintTxInfo(int packet_id, int destination_id, double tx_duration){
		printf("packet_id = %d - destination_id = %d - tx_duration = %f - tx_power = %f pw"
			" - position = (%.2f, %.2f, %.2f)\n",
			packet_id, destination_id, tx_duration, tx_power, x, y, z);
	}

	



	void SetSizeOfIdsAggregatedArray(int num_packets_aggregated){
		list_id_aggregated = new int[num_packets_aggregated];
		for(int t = 0; t < num_packets_aggregated; ++t){
			list_id_aggregated[t] = 0;
		}
	}

	



	void SetSizeOfTimestampAggregatedArray(int num_packets_aggregated){
		timestamp_frames_aggregated = new double[num_packets_aggregated];
		for(int t = 0; t < num_packets_aggregated; ++t){
			timestamp_frames_aggregated[t] = 0;
		}
	}

	



	void SetSizeOfMCS(int channels_groups){
		
		for(int s = 0; s < channels_groups; ++s){
			modulation_schemes[s] = MODULATION_NONE;
		}
	}

};


struct Notification
{
	
	int packet_id;				
	int packet_type;			
	int source_id;				
	int destination_id;			
	double tx_duration;			
	int left_channel;			
	int right_channel;			
	int frame_length;			
	int modulation_id;			
	double timestamp;			
	double timestamp_generated;	
	TxInfo tx_info; 			

	


	void PrintNotification(void){
		printf("source_id = %d - packet_type = %d - left_channel = %d - right_channel = %d - pkt_length = %d -",
			source_id, packet_type, left_channel, right_channel, frame_length);
		printf("tx_info: ");
		tx_info.PrintTxInfo(packet_id, destination_id, tx_duration);
	}

};

#endif


#line 65 "node.h"


#line 1 "../structures/logical_nack.h"

















































#ifndef _AUX_LOGICAL_NACK_
#define _AUX_LOGICAL_NACK_

struct LogicalNack
{
	int source_id;		
	int packet_type;	
	int packet_id;		
	int loss_reason;	
	int node_id_a;		
	int node_id_b;		
	double ber;			
	double sinr;		

	


	void PrintNackInfo(void){
		printf("source_id = %d - packet_id = %d - loss_reason = %d - node_id_a = %d - node_id_b = %d\n",
			source_id, packet_id, loss_reason, node_id_a, node_id_b);
	}
};

#endif


#line 66 "node.h"


#line 1 "../structures/wlan.h"













































 



#ifndef _AUX_WLAN_
#define _AUX_WLAN_

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string.h>

#line 1 "../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 57 "../structures/wlan.h"


#line 1 "../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 58 "../structures/wlan.h"



struct Wlan
{
	int wlan_id;			
	std::string wlan_code;	
	int num_stas;			
	int ap_id;				
	int *list_sta_id;		

	int spatial_reuse_enabled;	

	



	void SetSizeOfSTAsArray(int num_stas){
		list_sta_id = new int[num_stas];
		for(int s = 0; s < num_stas; ++s){
			list_sta_id[s] = NODE_ID_NONE;
		}
	}

	



	int FindStaInList(int sta_id){
		int found(0);
		for(int s = 0; s < num_stas; ++s){
			if(list_sta_id[s] == sta_id) found = 1;
		}
		return found;
	}

	


	void PrintStaIds(){
		for(int s = 0; s < num_stas; s++){
			printf("%d  ", list_sta_id[s]);
		}
		printf("\n");
	}

	



	void WriteStaIds(Logger logger){
		if (logger.save_logs){
			for(int s = 0; s < num_stas; s++){
				fprintf(logger.file, "%d  ", list_sta_id[s]);
			}
		}
	}

	


	void PrintWlanInfo(){
		printf("%s WLAN %s:\n", LOG_LVL3, wlan_code.c_str());
		printf("%s wlan_id: %d\n", LOG_LVL4, wlan_id);
		printf("%s num_stas: %d\n", LOG_LVL4, num_stas);
		printf("%s ap_id: %d\n", LOG_LVL4, ap_id);
		printf("%s list of STAs IDs: ", LOG_LVL4);
		PrintStaIds();
	}

	




	void WriteWlanInfo(Logger logger, std::string header_str){
		if (logger.save_logs){
			fprintf(logger.file, "%s WLAN %s:\n", header_str.c_str(), wlan_code.c_str());
			fprintf(logger.file, "%s - wlan_id: %d\n", header_str.c_str(), wlan_id);
			fprintf(logger.file, "%s - num_stas: %d\n", header_str.c_str(), num_stas);
			fprintf(logger.file, "%s - ap_id: %d\n", header_str.c_str(), ap_id);
			fprintf(logger.file, "%s - list of STAs IDs: ", header_str.c_str());
			WriteStaIds(logger);
			fprintf(logger.file, "\n");
		}
	}
};

#endif


#line 67 "node.h"


#line 1 "../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 68 "node.h"


#line 1 "../structures/FIFO.h"

#line 1 "../structures/notification.h"













































 



#ifndef _AUX_NOTIFICATION_
#define _AUX_NOTIFICATION_


struct TxInfo
{

	int num_packets_aggregated;				
	int *list_id_aggregated;				
	double *timestamp_frames_aggregated;	

	
	double data_duration;		
	double ack_duration;		
	double rts_duration;		
	double cts_duration;		

	double preoccupancy_duration;	
	double total_tx_power;			
	double tx_power;				
	double tx_gain;					
	double pd;						
	double bits_ofdm_sym; 			
	double data_rate; 				
	int modulation_schemes[4];		
	double x;						
	double y;						
	double z;						
	double nav_time;				

	bool flag_change_in_tx_power;	

	
	int bss_color;				
	int srg;					
	bool txop_sr_identified;	

	





	void PrintTxInfo(int packet_id, int destination_id, double tx_duration){
		printf("packet_id = %d - destination_id = %d - tx_duration = %f - tx_power = %f pw"
			" - position = (%.2f, %.2f, %.2f)\n",
			packet_id, destination_id, tx_duration, tx_power, x, y, z);
	}

	



	void SetSizeOfIdsAggregatedArray(int num_packets_aggregated){
		list_id_aggregated = new int[num_packets_aggregated];
		for(int t = 0; t < num_packets_aggregated; ++t){
			list_id_aggregated[t] = 0;
		}
	}

	



	void SetSizeOfTimestampAggregatedArray(int num_packets_aggregated){
		timestamp_frames_aggregated = new double[num_packets_aggregated];
		for(int t = 0; t < num_packets_aggregated; ++t){
			timestamp_frames_aggregated[t] = 0;
		}
	}

	



	void SetSizeOfMCS(int channels_groups){
		
		for(int s = 0; s < channels_groups; ++s){
			modulation_schemes[s] = MODULATION_NONE;
		}
	}

};


struct Notification
{
	
	int packet_id;				
	int packet_type;			
	int source_id;				
	int destination_id;			
	double tx_duration;			
	int left_channel;			
	int right_channel;			
	int frame_length;			
	int modulation_id;			
	double timestamp;			
	double timestamp_generated;	
	TxInfo tx_info; 			

	


	void PrintNotification(void){
		printf("source_id = %d - packet_type = %d - left_channel = %d - right_channel = %d - pkt_length = %d -",
			source_id, packet_type, left_channel, right_channel, frame_length);
		printf("tx_info: ");
		tx_info.PrintTxInfo(packet_id, destination_id, tx_duration);
	}

};

#endif


#line 1 "../structures/FIFO.h"

#include <deque>





struct FIFO
{	
		std::deque <Notification> m_queue;
		
		int queue_size;

		Notification GetFirstPacket();
		Notification GetPacketAt(int n);
		void DelFirstPacket();		
		void DeletePacketIn(int i);
		void PutPacket(Notification &packet);
		void PutPacketFront(Notification &packet);
		void PutPacketIn(Notification &packet, int);
		int QueueSize();
};

Notification FIFO :: GetFirstPacket()
{
	return(m_queue.front());	
}; 

Notification FIFO :: GetPacketAt(int n)
{
	return(m_queue.at(n));	
}; 


void FIFO :: DelFirstPacket()
{
	m_queue.pop_front();
}; 

void FIFO :: PutPacket(Notification &packet)
{	
	m_queue.push_back(packet);
}; 

void FIFO :: PutPacketFront(Notification &packet)
{	
	m_queue.push_front(packet);
}; 

int FIFO :: QueueSize()
{
	return(m_queue.size());
}; 

void FIFO :: PutPacketIn(Notification & packet,int i)
{
	m_queue.insert(m_queue.begin()+i,packet);
}; 

void FIFO :: DeletePacketIn(int i)
{
	m_queue.erase(m_queue.begin()+i);
};




#line 69 "node.h"


#line 1 "../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../structures/../methods/power_channel_methods.h"


#line 1 "../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../structures/../methods/power_channel_methods.h"


#line 1 "../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 70 "node.h"


#line 1 "../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 71 "node.h"


#define __SAVELOGS__

#ifdef __SAVELOGS__
    #define    LOGS(flag,file,...)    if(flag){fprintf(file, ##__VA_ARGS__);}
#else
    #define    LOGS(flag,file,...)
#endif



#line 505 "node.h"
;





#line 579 "node.h"
;





#line 602 "node.h"
;






#line 2170 "node.h"
;






#line 2817 "node.h"
;






#line 3429 "node.h"
;






#line 3530 "node.h"
;





#line 74 "komondor_main.cc"


#line 1 "traffic_generator.h"













































 



#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <iostream>
#include <stdlib.h>


#line 1 "../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "traffic_generator.h"


#line 1 "../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 57 "traffic_generator.h"




#line 108 "traffic_generator.h"
;





#line 119 "traffic_generator.h"
;





#line 126 "traffic_generator.h"
;





#line 75 "komondor_main.cc"


#line 1 "agent.h"













































 







#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <iostream>
#include <stdlib.h>


#line 1 "../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 60 "agent.h"


#line 1 "../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../structures/../methods/power_channel_methods.h"


#line 1 "../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../structures/../methods/power_channel_methods.h"


#line 1 "../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 61 "agent.h"


#line 1 "../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 62 "agent.h"


#line 1 "../structures/action.h"

















































#line 1 "../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 49 "../structures/action.h"


#line 1 "../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 50 "../structures/action.h"


#ifndef _AUX_ACTION_
#define _AUX_ACTION_


struct Action
{

	int id;				

	
	int channel;		
	double cca;			
	double tx_power;	
	int max_bandwidth;	

	
	double instantaneous_reward;    
	double cumulative_reward;       
	int times_played;               

	
	Performance performance_since_last_cc_request;     
	double cumulative_reward_since_last_cc_request;    
	int times_played_since_last_cc_request;            
	double average_reward_since_last_cc_request;       

	


	void PrintAction() {
		printf("------------\n Action %d:\n", id);
		printf(" * channel = %d\n", channel);
		printf(" * cca = %f dBm\n", ConvertPower(PW_TO_DBM, cca));
		printf(" * tx_power = %f dBm\n", ConvertPower(PW_TO_DBM, tx_power));
		printf(" * max_bandwidth = %d\n", max_bandwidth);
		printf("------------\n");
	}

	






	void WriteAction(Logger logger, int save_logs, double sim_time, char string_device[]) {
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s Action (%d):\n", sim_time, string_device, LOG_C03, LOG_LVL2, id);
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s channel = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, channel);
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s cca = %f dBm\n", sim_time, string_device, LOG_C03, LOG_LVL3, ConvertPower(PW_TO_DBM, cca));
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s tx_power = %f dBm\n", sim_time, string_device, LOG_C03, LOG_LVL3, ConvertPower(PW_TO_DBM, tx_power));
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s max_bandwidth = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, max_bandwidth);
	}

	


	void PrintRewardInformation() {
		printf("------------\n Reward information (a%d):\n", id);
		printf(" * instantaneous_reward = %f\n", instantaneous_reward);
		printf(" * cumulative_reward = %f\n", cumulative_reward);
		printf(" * times_played = %d\n", times_played);
		printf("------------\n");
	}

    






    void WriteRewardInformation(Logger logger, int save_logs, double sim_time, char string_device[]) {
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s Reward information (a%d):\n", sim_time, string_device, LOG_C03, LOG_LVL2, id);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s instantaneous_reward = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, instantaneous_reward);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s cumulative_reward = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, cumulative_reward);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s times_played = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, times_played);
    }

    


        void PrintControllerStatistics() {
            printf("------------\n Information since last CC request (a%d):\n", id);
            printf(" * cumulative_reward_since_last_request = %f\n", cumulative_reward_since_last_cc_request);
            printf(" * times_played_since_last_request = %d\n", times_played_since_last_cc_request);
            printf(" * average_reward_since_last_request = %f\n", average_reward_since_last_cc_request);
            printf("------------\n");
        }

    






    void WriteControllerStatistics(Logger logger, int save_logs, double sim_time, char string_device[]) {
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s Information since last CC request (a%d):\n", sim_time, string_device, LOG_C03, LOG_LVL2, id);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s cumulative_reward_since_last_request = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, cumulative_reward_since_last_cc_request);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s times_played_since_last_request = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, times_played_since_last_cc_request);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s average_reward_since_last_request = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, average_reward_since_last_cc_request);
    }

};

#endif

#line 63 "agent.h"


#line 1 "../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 64 "agent.h"


#line 1 "../methods/agent_methods.h"













































 






#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 52 "../methods/agent_methods.h"


#ifndef _AUX_AGENT_METHODS_
#define _AUX_AGENT_METHODS_






void RestartPerformanceMetrics(Performance *current_performance, double sim_time, int num_channels_allowed) {

	current_performance->timestamp = sim_time;
	current_performance->throughput = 0;
	current_performance->max_bound_throughput = 0;
	current_performance->data_packets_sent = 0;
	current_performance->data_packets_lost = 0;
	current_performance->rts_cts_sent = 0;
	current_performance->rts_cts_lost = 0;
	current_performance->num_packets_generated = 0;
	current_performance->num_packets_dropped = 0;

	for(int n = 0; n < num_channels_allowed; ++n){
		current_performance->total_time_transmitting_in_num_channels[n] = 0;
		current_performance->total_time_lost_in_num_channels[n] = 0;
	}

}





bool CheckValidityOfData(Configuration configuration, Performance performance,
		double sim_time, double max_time_validity_information) {



	bool data_still_valid(false);
	if ( (sim_time - performance.timestamp > max_time_validity_information)
			|| (sim_time - configuration.timestamp > max_time_validity_information) ) {
		data_still_valid = false;
	} else {
		data_still_valid = true;
	}
	return data_still_valid;
}

#endif


#line 65 "agent.h"



#line 1 "../learning_modules/pre_processor.h"













































 







#line 1 "../learning_modules/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 53 "../learning_modules/pre_processor.h"



#line 1 "../learning_modules/../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../learning_modules/../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../learning_modules/../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../learning_modules/../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../learning_modules/../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 55 "../learning_modules/pre_processor.h"


#line 1 "../learning_modules/../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 56 "../learning_modules/pre_processor.h"


#ifndef _AUX_PP_
#define _AUX_PP_

class PreProcessor {

	
	public:

		
		int selected_strategy;				

		
		int *list_of_channels;				
		double *list_of_pd_values;			
		double *list_of_tx_power_values;	
		int *list_of_max_bandwidth;			

		
		int num_arms;					
		int num_arms_channel;			
		int num_arms_sensitivity;		
		int num_arms_tx_power;			
		int num_arms_max_bandwidth;		
		int *indexes_selected_arm;			

	
	private:

	
	public:

		
		
		
		
		

		





		int ProcessWlanConfiguration(int learning_mechanism, Configuration configuration) {
			int processed_configuration(0);
			
			switch(learning_mechanism) {
				
				case MULTI_ARMED_BANDITS:{
					
					processed_configuration = FindActionIndexFromConfigurationBandits(configuration, indexes_selected_arm);
					break;
				}
				
				default:{
					printf("[Pre-Processor] ERROR: '%d' is not a correct learning mechanism\n", learning_mechanism);
					PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}
			return processed_configuration;
		};

		






		double ProcessWlanPerformance(Performance performance, int type_of_reward) {
			return GenerateReward(type_of_reward, performance);
		};

		





		double GenerateReward(int type_of_reward, Performance performance) {

            double reward(0);
			
			switch(type_of_reward){
				




				case REWARD_TYPE_PACKETS_SUCCESSFUL:{
					reward = (performance.data_packets_sent-performance.data_packets_lost)/performance.data_packets_sent;
					break;
				}
				




				case REWARD_TYPE_AVERAGE_THROUGHPUT:{
					if (performance.max_bound_throughput == 0) {
						reward = 0;
					} else {
						reward = (double) performance.throughput/performance.max_bound_throughput;
					}
					break;
				}
				


				case REWARD_TYPE_MIN_RSSI:{
					reward = performance.rssi_list_per_sta[0];
					for (int i = 0; i < performance.num_stas; ++i) {
						if(reward > performance.rssi_list_per_sta[i]) reward = performance.rssi_list_per_sta[i];
					}
					break;
				}
				


				case REWARD_TYPE_MAX_DELAY:{
					reward = performance.average_delay;
					break;
				}
				


				case REWARD_TYPE_AVERAGE_DELAY:{
					reward = performance.average_delay;
					break;
				}
                


				case REWARD_TYPE_CHANNEL_OCCUPANCY:{
					reward = performance.successful_channel_occupancy;
				    break;
				}
				
				default:{
					printf("[Pre-Processor] ERROR: '%d' is not a correct type of performance indicator\n", type_of_reward);
					PrintAvailableRewardTypes();
					exit(EXIT_FAILURE);
					break;
				}
			}

			return reward;
		}

		






		Configuration ProcessMLOutput(int learning_mechanism, Configuration configuration, double ml_output) {
			Configuration suggested_configuration;
			
			switch(learning_mechanism){
				case MULTI_ARMED_BANDITS:{
					suggested_configuration = GenerateNewConfigurationBandits(configuration, ml_output);
					break;
				}
				case RTOT_ALGORITHM:{
					suggested_configuration = GenerateNewConfigurationRtotAlg(configuration, ml_output);
					break;
				}
				
				default:{
					printf("[PP] ERROR: %d is not a correct type of learning mechanism. Returning the default configuration.\n", learning_mechanism);
					suggested_configuration = configuration;
					break;
				}
			}
			return suggested_configuration;
		};

		
		
		
		
		

		



		Action* InitializeActions(){
			Action *action_array = new Action[num_arms];
			int *indexes_arm = new int[NUM_FEATURES_ACTIONS];
			for(int i = 0; i < num_arms; ++i) {
				index2values(indexes_arm, i, num_arms_channel,num_arms_sensitivity,
					num_arms_tx_power, num_arms_max_bandwidth);
				action_array[i].id = i;
				
				action_array[i].channel = list_of_channels[indexes_arm[0]];
				action_array[i].cca = list_of_pd_values[indexes_arm[1]];
				action_array[i].tx_power = list_of_tx_power_values[indexes_arm[2]];
				action_array[i].max_bandwidth = list_of_max_bandwidth[indexes_arm[3]];
				
				action_array[i].instantaneous_reward = 0;
				action_array[i].times_played = 0;
				action_array[i].average_reward_since_last_cc_request = 0;
				action_array[i].times_played_since_last_cc_request = 0;

			}
			return action_array;
		}

		





		Configuration GenerateNewConfigurationBandits(Configuration configuration, double ml_output){
			
			index2values(indexes_selected_arm, (int) ml_output, num_arms_channel,
				num_arms_sensitivity, num_arms_tx_power, num_arms_max_bandwidth);
			
			int new_primary = list_of_channels[indexes_selected_arm[0]];
			double new_pd = list_of_pd_values[indexes_selected_arm[1]];
			double new_tx_power = list_of_tx_power_values[indexes_selected_arm[2]];
			int new_max_bandwidth = list_of_max_bandwidth[indexes_selected_arm[3]];
			
			Configuration new_configuration;
			
			new_configuration = configuration;
			
			new_configuration.selected_primary_channel = new_primary;	
			if (configuration.spatial_reuse_enabled) {
				new_configuration.non_srg_obss_pd = new_pd;
			} else {
				new_configuration.selected_pd = new_pd;
			}
			new_configuration.selected_tx_power = new_tx_power;			
			new_configuration.selected_max_bandwidth = new_max_bandwidth;		
			return new_configuration;
		}

		





		int FindActionIndexFromConfigurationBandits(Configuration configuration, int* &indexes_selected_arm) {

		    
			int index_channel = -1;
			int index_pd = -1;
			int index_tx_power = -1;
			int index_max_bandwidth = -1;

			
			for(int i = 0; i < num_arms_channel; i++) {
				if(configuration.selected_primary_channel == list_of_channels[i]) {
					index_channel = i;
				}
			}
			
			double selected_pd;
			if(configuration.spatial_reuse_enabled) {
				selected_pd = configuration.non_srg_obss_pd;
			} else {
				selected_pd = configuration.selected_pd;
			}
			for(int i = 0; i < num_arms_sensitivity; i++) {
				if(selected_pd == list_of_pd_values[i]) {
					index_pd = i;
				}
			}
			
			for(int i = 0; i < num_arms_tx_power; i++) {
				if(configuration.selected_tx_power == list_of_tx_power_values[i]) {
					index_tx_power = i;
				}
			}
			
			for(int i = 0; i < num_arms_max_bandwidth; i++) {
				if(configuration.selected_max_bandwidth == list_of_max_bandwidth[i]) {
					index_max_bandwidth = i;
				}
			}
			
			indexes_selected_arm[0] = index_channel;
			indexes_selected_arm[1] = index_pd;
			indexes_selected_arm[2] = index_tx_power;
			indexes_selected_arm[3] = index_max_bandwidth;
			
			int action_ix = values2index(indexes_selected_arm, num_arms_channel,
				num_arms_sensitivity, num_arms_tx_power, num_arms_max_bandwidth);


			return action_ix;
		}

		
		
		
		
		

		





		Configuration GenerateNewConfigurationRtotAlg(Configuration configuration, double ml_output){
			
			Configuration new_configuration;
			
			new_configuration = configuration;
			new_configuration.non_srg_obss_pd = ml_output;

			return new_configuration;
		}


		
		
		
		
		

		



		void PrintActionBandits(int action_ix){
			index2values(indexes_selected_arm, action_ix, num_arms_channel,
				num_arms_sensitivity, num_arms_tx_power, num_arms_max_bandwidth);
			printf("%s Action %d ([%d %d %d %d]\n", LOG_LVL2,
				action_ix, indexes_selected_arm[0], indexes_selected_arm[1], indexes_selected_arm[2], indexes_selected_arm[3]);
			printf("%s Channel: %d\n", LOG_LVL3, list_of_channels[indexes_selected_arm[0]]);
			printf("%s pd: %.2f dBm\n", LOG_LVL3,
				ConvertPower(PW_TO_DBM, list_of_pd_values[indexes_selected_arm[1]]));
			printf("%s Tx Power: %.2f dBm\n", LOG_LVL3,
				ConvertPower(PW_TO_DBM, list_of_tx_power_values[indexes_selected_arm[2]]));
			printf("%s Max bandwidth: %d\n", LOG_LVL3, list_of_max_bandwidth[indexes_selected_arm[3]]);
		}

		



		void PrintOrWriteAvailableActions(int print_or_write, char string_device[],
			int save_logs, Logger &logger, double sim_time, int *list_of_available_actions) {

			switch(print_or_write) {
				case PRINT_LOG: {
					printf("%s List of available actions: ", string_device);
					for (int i = 0; i < num_arms; ++i) {
						printf("%d ", list_of_available_actions[i]);
					}
					printf("\n");
					break;
				}
				case WRITE_LOG: {
					LOGS(save_logs,logger.file,
						"%.15f;%s;%s;%s List of available actions: ",
						sim_time, string_device, LOG_C00, LOG_LVL2);
					for (int i = 0; i < num_arms; ++i) {
						LOGS(save_logs, logger.file, "%d ", list_of_available_actions[i]);
					}
					LOGS(save_logs,logger.file, "\n");
				}
			}

		}

		


		void PrintAvailableRewardTypes(){
			printf("%s Available types of rewards:\n%s REWARD_TYPE_PACKETS_SUCCESSFUL (%d)\n"
				"%s REWARD_TYPE_AVERAGE_THROUGHPUT (%d)\n%s REWARD_TYPE_MIN_RSSI (%d)\n"
				"%s REWARD_TYPE_MAX_DELAY (%d)\n%s REWARD_TYPE_AVERAGE_DELAY (%d)\n%s REWARD_TYPE_CHANNEL_OCCUPANCY (%d)",
				LOG_LVL2, LOG_LVL3, REWARD_TYPE_PACKETS_SUCCESSFUL, LOG_LVL3, REWARD_TYPE_AVERAGE_THROUGHPUT,
				LOG_LVL3, REWARD_TYPE_MIN_RSSI, LOG_LVL3, REWARD_TYPE_MAX_DELAY, LOG_LVL3, REWARD_TYPE_AVERAGE_DELAY,
				LOG_LVL3, REWARD_TYPE_CHANNEL_OCCUPANCY);
		}

		


		void PrintAvailableLearningMechanisms(){
			printf("%s Available types of learning mechanisms:\n", LOG_LVL2);
			printf("%s MULTI_ARMED_BANDITS (%d)\n", LOG_LVL3, MULTI_ARMED_BANDITS);
		}

		



		void WritePerformance(Logger &logger, double sim_time, char string_device[],
				Performance performance, int type_of_reward) {

			LOGS(TRUE, logger.file, "%.15f;%s;%s;%s Performance:\n", sim_time, string_device, LOG_C03, LOG_LVL2);
			switch(type_of_reward) {
				
				case REWARD_TYPE_PACKETS_SUCCESSFUL:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Packet successful ratio = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3,
						(double)((performance.data_packets_sent-performance.data_packets_lost)/performance.data_packets_sent));
					break;
				}
				
				case REWARD_TYPE_AVERAGE_THROUGHPUT:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Average throughput = %.2f Mbps\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.throughput * pow(10,-6));
					break;
				}
				
				case REWARD_TYPE_MIN_RSSI:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Min RSSI = %.2f dBm\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.rssi_list_per_sta[0]);
					break;
				}
				
				case REWARD_TYPE_MAX_DELAY:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Max delay = %.2f ms\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.average_delay * pow(10,-3));
					break;
				}
				
				case REWARD_TYPE_AVERAGE_DELAY:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Average delay = %.2f ms\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.average_delay * pow(10,-3));
					break;
				}
				
				case REWARD_TYPE_CHANNEL_OCCUPANCY:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Successful channel successful_channel_occupancy = %.2f\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.successful_channel_occupancy);
					break;
				}
			}

		}

		
		
		
		
		

		







		void index2values(int *indexes, int action_ix, int size_channels, int size_pd, int size_tx_power, int size_max_bandwidth) {
			indexes[0] = (int) action_ix/(size_pd * size_tx_power * size_max_bandwidth);
			indexes[1] = (int) (action_ix - indexes[0] * (size_pd * size_tx_power * size_max_bandwidth))
					/(size_tx_power * size_max_bandwidth);
			indexes[2] = (int) (action_ix -  indexes[0] * (size_pd * size_tx_power * size_max_bandwidth)
					- indexes[1] * (size_tx_power * size_max_bandwidth))
					/(size_max_bandwidth);
			indexes[3] = action_ix % size_max_bandwidth;
		}

		







		int values2index(int *indexes, int size_channels, int size_pd, int size_tx_power, int size_max_bandwidth) {
			int index = indexes[0] * (size_pd * size_tx_power * size_max_bandwidth)
				+ indexes[1] * (size_tx_power * size_max_bandwidth)
				+ indexes[2] * size_max_bandwidth
				+ indexes[3];
			return index;
		}

		


		void InitializeVariables(){
			
			list_of_channels = new int[num_arms_channel];
			list_of_pd_values = new double[num_arms_sensitivity];
			list_of_tx_power_values = new double[num_arms_tx_power];
			list_of_max_bandwidth = new int[num_arms_max_bandwidth];




			
			indexes_selected_arm = new int[NUM_FEATURES_ACTIONS]; 
		}

};

#endif

#line 67 "agent.h"


#line 1 "../learning_modules/ml_model.h"













































 







#line 1 "../learning_modules/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 53 "../learning_modules/ml_model.h"



#line 1 "../learning_modules/../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../learning_modules/../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../learning_modules/../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../learning_modules/../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../learning_modules/../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 55 "../learning_modules/ml_model.h"


#line 1 "../learning_modules/../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 56 "../learning_modules/ml_model.h"


#line 1 "../learning_modules/../structures/controller_report.h"


















































#line 1 "../learning_modules/../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 50 "../learning_modules/../structures/controller_report.h"


#line 1 "../learning_modules/../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 51 "../learning_modules/../structures/controller_report.h"


#ifndef _AUX_CC_REPORT_
#define _AUX_CC_REPORT_


struct ControllerReport
{

	
	int cc_iteration;
	int agents_number;
	int max_number_of_actions;
	
	int **clusters_per_wlan;
	double *cluster_performance;
	
	Configuration *last_configuration_array;	
	Performance *last_performance_array;		
	
	double *performance_per_agent;				
	double *average_performance_per_agent;		
	int *num_arms_per_agent;
	int **list_of_available_actions_per_agent; 	
	double **performance_action_per_agent;		
	int **times_action_played_per_agent;		
	int *most_played_action_per_agent;			

	






	void PrintOrWriteAvailableActions(int write_or_print, Logger &logger, int save_logs, double sim_time) {
		switch(write_or_print){
			
			case PRINT_LOG:{
				printf("+ List of available actions (max = %d):\n", max_number_of_actions);
				for(int i = 0; i < agents_number; ++i) {
					printf("	 * Agent %d: ", i);
					for(int j = 0; j < max_number_of_actions; ++j) {
						printf(" %d ", list_of_available_actions_per_agent[i][j]);
					}
					printf("\n");
				}
				break;
			}
			
			case WRITE_LOG:{
				LOGS(save_logs, logger.file, "%.15f;CC;%s;%s List of available actions:\n", sim_time, LOG_C00, LOG_LVL2);
				for(int i = 0; i < agents_number; ++i) {
					LOGS(save_logs, logger.file, "%.15f;CC;%s;%s Agent %d: ", sim_time, LOG_C00, LOG_LVL3, i);
					for(int j = 0; j < max_number_of_actions; ++j) {
						LOGS(save_logs, logger.file, " %d ", list_of_available_actions_per_agent[i][j]);
						printf(" %d ", list_of_available_actions_per_agent[i][j]);
					}
					LOGS(save_logs, logger.file, "\n");
				}
				break;
			}
		}
	}

	


	void SetSizeOfArrays(){
		
		last_configuration_array = new Configuration[agents_number];
		last_performance_array = new Performance[agents_number];
		
		performance_per_agent = new double[agents_number];
		average_performance_per_agent = new double[agents_number];
		performance_action_per_agent = new double *[agents_number];
		list_of_available_actions_per_agent = new int *[agents_number];
		num_arms_per_agent = new int[agents_number];
		times_action_played_per_agent = new int *[agents_number];
		most_played_action_per_agent = new int[agents_number];
		
		clusters_per_wlan = new int *[agents_number];
		cluster_performance = new double[agents_number];
		
		for (int i = 0; i < agents_number; ++i) {
			list_of_available_actions_per_agent[i] = new int[max_number_of_actions];
			performance_action_per_agent[i] = new double[max_number_of_actions];
			times_action_played_per_agent[i] = new int[max_number_of_actions];
			clusters_per_wlan[i] = new int[agents_number];
		}
	}

};

#endif


#line 57 "../learning_modules/ml_model.h"



#line 1 "../learning_modules//network_optimization_methods/centralized_action_banning.h"













































 






#line 1 "../learning_modules//network_optimization_methods/../../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 52 "../learning_modules//network_optimization_methods/centralized_action_banning.h"


#ifndef _AUX_BANNING_
#define _AUX_BANNING_

class CentralizedActionBanning {

	
	public:

		int save_logs;				
		int print_logs;				

		double *initial_banning_threshold;
		double *current_banning_threshold;
		double MAX_THRESHOLD_BANNING;
		double MIN_THRESHOLD_BANNING;
		double MARGIN_THRESHOLD_BANNING;
        int banning_threshold_type;
        int banning_iteration;

        int banned_in_last_iteration;

        double *max_reward_seen_per_agent;

		int agents_number;
		int max_number_of_actions;

		int **list_of_available_actions_per_agent;
		int *num_arms_per_agent;
		double *average_performance_per_agent;
		double *cluster_performance;
		int **clusters_per_wlan;
		int *most_played_action_per_agent;
		int **times_action_played_per_agent;
		Configuration *configuration_array;

		
		double *previous_performance_per_agent;        
		int *previously_banned_action_per_agent;    
		double DELTA;                               

	
	public:

		
		
		
		
		

		





		void UpdateConfiguration(Configuration *configuration_array, ControllerReport &controller_report,
			Logger central_controller_logger, double sim_time) {

			
			UpdateVariables(controller_report);

			
			RestoreBannedActions(configuration_array, controller_report, central_controller_logger, sim_time);

			
			BanActions(configuration_array, controller_report, central_controller_logger, sim_time);

			
			UpdateBanningThreshold(controller_report, central_controller_logger, sim_time);

		}

		





		void BanActions(Configuration *configuration_array, ControllerReport &controller_report,
			Logger central_controller_logger, double sim_time) {

			
			for(int i = 0; i < agents_number; ++i) {
                
				for(int j = 0; j < agents_number; ++j) {
					if(i != j && clusters_per_wlan[i][j] == 1) {

                        if (average_performance_per_agent[j] < current_banning_threshold[i]) {
							
							if(AssessActionNegativeImpact(i)) {
                                LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s Banned action %d of A%d\n",
                                     sim_time, LOG_C00, LOG_LVL1, most_played_action_per_agent[i], i);
								list_of_available_actions_per_agent[i][most_played_action_per_agent[i]] = 0;
								configuration_array[i].agent_capabilities.available_actions[most_played_action_per_agent[i]] = 0;
                                previously_banned_action_per_agent[i] = most_played_action_per_agent[i];
							}
						}
					}
					
					previous_performance_per_agent[j] = average_performance_per_agent[j];
				}
			}

			++ banning_iteration;

		}

        





		void RestoreBannedActions(Configuration *configuration_array, ControllerReport &controller_report,
            Logger central_controller_logger, double sim_time) {
            
            for(int i = 0; i < agents_number; ++i) {

                if (average_performance_per_agent[i] <= previous_performance_per_agent[i]) {
                    
                    for(int j = 0; j < agents_number; ++j) {
                        if(i != j && clusters_per_wlan[i][j] == 1 && previously_banned_action_per_agent[j] >= 0) {
                            LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s Restored action %d of A%d\n",
                                 sim_time, LOG_C00, LOG_LVL1, previously_banned_action_per_agent[j], j);
                            list_of_available_actions_per_agent[j][previously_banned_action_per_agent[j]] = 1;
                            configuration_array[j].agent_capabilities.available_actions[previously_banned_action_per_agent[j]] = 1;
                            
                            ResetBanningThreshold(i);
                        }
                    }
                }
                
                previously_banned_action_per_agent[i] = -1;
            }
		}

		



		int AssessActionNegativeImpact(int agent_id) {

		    
		    int total_num_arms_played(0);
		    for (int i = 0; i < num_arms_per_agent[agent_id]; ++i) {
                total_num_arms_played += times_action_played_per_agent[agent_id][i];
		    }

			
			double POPULARITY_PERCENTAGE(0.33);
			int min_num_times_action_is_played = (POPULARITY_PERCENTAGE * total_num_arms_played);

			
			int sum_available_actions(0);
			for (int i = 0; i < num_arms_per_agent[agent_id]; ++i) {
				if (list_of_available_actions_per_agent[agent_id] >= 0)
					sum_available_actions += list_of_available_actions_per_agent[agent_id][i];
			}
			
            int  times_played_most_popular_action = times_action_played_per_agent[agent_id][most_played_action_per_agent[agent_id]];
			if (sum_available_actions > 1 && times_played_most_popular_action >= min_num_times_action_is_played) {
				banned_in_last_iteration = TRUE;
				return TRUE;

			} else {
				banned_in_last_iteration = FALSE;
				return FALSE;
			}

		}

		



		void UpdateVariables(ControllerReport controller_report) {

			
			num_arms_per_agent = controller_report.num_arms_per_agent;
			list_of_available_actions_per_agent = controller_report.list_of_available_actions_per_agent;
			most_played_action_per_agent = controller_report.most_played_action_per_agent;
			times_action_played_per_agent = controller_report.times_action_played_per_agent;

			
			configuration_array = controller_report.last_configuration_array;
			average_performance_per_agent = controller_report.average_performance_per_agent;

            
            int change_in_cluster_detected(FALSE);
            for (int i = 0; i < agents_number; ++i) {
            	if (average_performance_per_agent[i] > max_reward_seen_per_agent[i]) {
            		max_reward_seen_per_agent[i] = average_performance_per_agent[i];
            	}

                for (int j = 0; j < agents_number; ++j) {
                    if (clusters_per_wlan[i][j] != controller_report.clusters_per_wlan[i][j]) {
                        change_in_cluster_detected = TRUE;
                        break;
                    }
                }
            }

            
			clusters_per_wlan = controller_report.clusters_per_wlan;
			cluster_performance = controller_report.cluster_performance;

			
			if (change_in_cluster_detected) {
                
                ComputeBanningThreshold();
			}

		}

		
		
		
		
		

        



        void ComputeBanningThreshold() {
            for(int i = 0; i < agents_number; ++i) {
                int agents_in_cluster(0);
                for(int j = 0; j < agents_number; ++j) {
                    if(clusters_per_wlan[i][j] == 1) {
                        agents_in_cluster += 1;
                    }
                }
                initial_banning_threshold[i] = (1.0 / agents_in_cluster);
                current_banning_threshold[i] = initial_banning_threshold[i];
            }
        }

        



        void ResetBanningThreshold(int agent_id) {
        	current_banning_threshold[agent_id] = MIN_THRESHOLD_BANNING;
            banning_iteration = 1;
        }

        






        void UpdateBanningThreshold(ControllerReport controller_report,
			Logger central_controller_logger, double sim_time) {

            
			if(controller_report.cc_iteration > 0) {
				for(int i = 0; i < agents_number; ++i) {
					
					for(int j = 0; j < agents_number; ++j) {
						if(i != j && clusters_per_wlan[i][j] == 1) {
							double threshold_shift (ComputeBanningShift());
							if(average_performance_per_agent[j] > current_banning_threshold[i])
								current_banning_threshold[i] += threshold_shift;
							else if(max_reward_seen_per_agent[j] < current_banning_threshold[i])
								current_banning_threshold[i] -= threshold_shift;
							
							if (current_banning_threshold[i] > MAX_THRESHOLD_BANNING) {
								current_banning_threshold[i] = MAX_THRESHOLD_BANNING;
							}
							if (current_banning_threshold[i] < MIN_THRESHOLD_BANNING)
								current_banning_threshold[i] = MIN_THRESHOLD_BANNING;
						}
						LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s Updating the banning threshold of Agent %d (mode %d)... \n",
							 sim_time, LOG_C00, LOG_LVL1, i, banning_threshold_type);
						LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s New threshold = %f\n",
							 sim_time, LOG_C00, LOG_LVL2, current_banning_threshold[i]);
					}
				}
			}

        }

        


        double ComputeBanningShift() {
        	double threshold_shift(0);
        	switch(banning_threshold_type) {
				case BANNING_THRESHOLD_STATIC : {
					
					break;
				}
				case BANNING_THRESHOLD_LINEAR : {
					threshold_shift = 0.05;
					break;
				}
				case BANNING_THRESHOLD_LOGARITHMIC : {
					threshold_shift = 1/(10*sqrt(banning_iteration));
					break;
				}
			}
        	return threshold_shift;
        }

		
		
		
		
		

        




        void PrintOrWriteStatistics(int write_or_print, Logger &logger) {
            
            switch(write_or_print){
                
                case PRINT_LOG:{
                    printf("%s Centralized action-banning statistics...\n", LOG_LVL1);
                    printf("%s Available actions (%d agents):\n", LOG_LVL2, agents_number);
                    for (int i = 0; i < agents_number; ++i) {
                        for (int j = 0; j < num_arms_per_agent[i]; ++j) {
                            printf("%d ", list_of_available_actions_per_agent[i][j]);
                        }
                        printf("\n");
                    }
                    break;
                }
                
                case WRITE_LOG:{
                    fprintf(logger.file, "%s Centralized action-banning statistics...\n", LOG_LVL1);
                    fprintf(logger.file, "%s Available actions (%d agents):\n", LOG_LVL2, agents_number);
                    for (int i = 0; i < agents_number; ++i) {
                        for (int j = 0; j < num_arms_per_agent[i]; ++j) {
                            fprintf(logger.file, "%d ", list_of_available_actions_per_agent[i][j]);
                        }
                        fprintf(logger.file, "\n");
                    }
                    break;
                }
            }
        }

		
		
		
		
		

		


		void InitializeVariables(){

		    
            initial_banning_threshold = new double[agents_number];
            current_banning_threshold = new double[agents_number];
            MAX_THRESHOLD_BANNING = 0.9;                        
            MIN_THRESHOLD_BANNING = 0.1;						
            MARGIN_THRESHOLD_BANNING = 0.1;                     
            banning_threshold_type = BANNING_THRESHOLD_LOGARITHMIC;  
            banning_iteration = 1;

            banned_in_last_iteration = FALSE;

            
            previous_performance_per_agent = new double[agents_number];
            previously_banned_action_per_agent = new int[agents_number];
            DELTA = 0.1;

            max_reward_seen_per_agent = new double[agents_number];

            
			list_of_available_actions_per_agent = new int *[agents_number];
			num_arms_per_agent = new int[agents_number];
			average_performance_per_agent = new double[agents_number];
			cluster_performance = new double[agents_number];
			clusters_per_wlan = new int *[agents_number];
			most_played_action_per_agent = new int[agents_number];
			times_action_played_per_agent = new int *[agents_number];
			configuration_array = new Configuration[agents_number];

			for(int i = 0; i < agents_number; ++i){
                initial_banning_threshold[i] = 0;
                current_banning_threshold[i] = 0;
				list_of_available_actions_per_agent[i] = new int[max_number_of_actions];	
				num_arms_per_agent[i] = 0;
				average_performance_per_agent[i] = 0;
                previous_performance_per_agent[i] = 0;
                previously_banned_action_per_agent[i] = -1;
				cluster_performance[i] = 0;
				clusters_per_wlan[i] = new int[agents_number];
				most_played_action_per_agent[i] = 0;
				times_action_played_per_agent[i] = new int[max_number_of_actions];
				max_reward_seen_per_agent[i] = 0;
			}

		}

};

#endif

#line 59 "../learning_modules/ml_model.h"


#line 1 "../learning_modules//network_optimization_methods/multi_armed_bandits.h"













































 






#line 1 "../learning_modules//network_optimization_methods/../../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 52 "../learning_modules//network_optimization_methods/multi_armed_bandits.h"


#ifndef _AUX_MABS_
#define _AUX_MABS_

class MultiArmedBandit {

	
	public:

        
        int save_logs;				
        int print_logs;				

        
		int agent_id;						
		int num_arms;					
		int action_selection_strategy;		

		
		int initial_reward;		
		int num_iterations;		

		
		double *reward_per_arm;					
		double *cumulative_reward_per_arm;		
		double *average_reward_per_arm;			
		double *estimated_reward_per_arm;		
		int *times_arm_has_been_selected;		

		
		double initial_epsilon;		
		double epsilon;				

	
	public:

		
		
		
		
		

		




		void UpdateArmStatistics(int action_ix, double reward){

			if(action_ix >= 0) { 
				
				reward_per_arm[action_ix] = reward;
				
				times_arm_has_been_selected[action_ix] += 1;
				
				cumulative_reward_per_arm[action_ix] += reward;
				
				average_reward_per_arm[action_ix] = cumulative_reward_per_arm[action_ix] /
					times_arm_has_been_selected[action_ix];
				
				estimated_reward_per_arm[action_ix] = ((estimated_reward_per_arm[action_ix]
					* times_arm_has_been_selected[action_ix])
					+ reward) / (times_arm_has_been_selected[action_ix] + 2);
			} else {
				printf("[MAB] ERROR: The action ix (%d) is not correct!\n", action_ix);
				exit(EXIT_FAILURE);
			}
		}

		



		int SelectNewAction(int *available_arms, int current_arm) {
			int arm_ix;
			
			
			switch(action_selection_strategy) {
				


				case STRATEGY_EGREEDY:{
					
					epsilon = initial_epsilon / sqrt( (double) num_iterations);
					
                    arm_ix = PickArmEgreedy(num_arms, average_reward_per_arm, epsilon, available_arms);
					break;
				}
				


				case STRATEGY_THOMPSON_SAMPLING:{
					
                    arm_ix = PickArmThompsonSampling(num_arms,
						estimated_reward_per_arm, times_arm_has_been_selected, available_arms);
					break;
				}
                


                case STRATEGY_SEQUENTIAL:{
                    
                    arm_ix = PickArmSequentially(num_arms, available_arms, current_arm);
                    break;
                }
				default:{
					printf("[MAB] ERROR: '%d' is not a correct action-selection strategy!\n", action_selection_strategy);
					PrintAvailableActionSelectionStrategies();
					exit(EXIT_FAILURE);
				}
			}
            
            ++ num_iterations;
            
			return arm_ix;
		}

		
		
		
		
		

		






		int PickArmEgreedy(int num_arms, double *reward_per_arm, double epsilon, int *available_arms) {

			double rand_number = ((double) rand() / (RAND_MAX));
			int action_ix;

			if (rand_number < epsilon) { 
				action_ix = rand() % num_arms;
				int counter(0);
				while (!available_arms[action_ix]) {
					action_ix = rand() % num_arms;
					if(counter > 1000) break; 
				}

			} else { 
				double max = 0;
				for (int i = 0; i < num_arms; i ++) {
					if(available_arms[i] && reward_per_arm[i] >= max) {
						max = reward_per_arm[i];
						action_ix = i;
					}
				}

			}

			return action_ix;

		}

		
		
		
		
		

		double gaussrand(double mean, double std){
			static double V1, V2, S;
			static int phase = 0;
			double X;
			if(phase == 0) {
				do {
					double U1 = (double)rand() /  RAND_MAX;
					double U2 = (double)rand() /  RAND_MAX;
					V1 = 2*U1 - 1;
					V2 = 2*U2 - 1;
					S = V1 * V1 + V2 * V2;
				} while (S >= 1 || S == 0);
				X = (V1 * sqrt(-2 * log(S) / S)) * std + mean;
			} else {
				X = (V1 * sqrt(-2 * log(S) / S)) * std + mean;
			}
			phase = 1 - phase;
			return X;
		}

		






		int PickArmThompsonSampling(int num_arms, double *estimated_reward_per_arm,
			int *times_arm_has_been_selected, int *available_arms) {
			
			int action_ix;
			double *theta = new double[num_arms];
			double std;
			
			for (int i = 0; i < num_arms; ++i) {
				if (available_arms[i]) {
					std = 1.0/(1+times_arm_has_been_selected[i]);
					theta[i] = gaussrand(estimated_reward_per_arm[i], std);
				} else {
					theta[i] = -10000;
				}
			}
			
			double max = theta[0];
			for (int i = 0; i < num_arms; ++i) {
				if(theta[i] > max) {
					max = theta[i];
					action_ix = i;
				}
				
			}

			return action_ix;
		}

        
        
        
        
        


        






        int PickArmSequentially(int num_arms, int *available_arms, int current_arm_ix) {
            int arm_ix(1);
            if (num_iterations == 1) {
                arm_ix = num_iterations;
            } else {
                arm_ix = (current_arm_ix + 1) % num_arms;
            }
            if (available_arms[arm_ix] != 1) {
                arm_ix = PickArmSequentially(num_arms, available_arms, arm_ix);
            }
            return arm_ix;
        }

		
		
		
		
		

		





		void PrintOrWriteStatistics(int write_or_print, Logger &logger, double sim_time) {
			
			switch(write_or_print){
				
				case PRINT_LOG:{
					if(print_logs){
						printf("%s Reward per arm: ", LOG_LVL3);
						for(int n = 0; n < num_arms; n++){
							printf("%f  ", reward_per_arm[n]);
						}
						printf("\n%s Cumulative reward per arm: ", LOG_LVL3);
						for(int n = 0; n < num_arms; n++){
							printf("%f  ", cumulative_reward_per_arm[n]);
						}
						printf("\n%s Times each arm has been selected: ", LOG_LVL3);
						for(int n = 0; n < num_arms; n++){
							printf("%d  ", times_arm_has_been_selected[n]);
						}
						printf("\n");
					}
					break;
				}
				
				case WRITE_LOG:{
					if(save_logs) fprintf(logger.file, "%.15f;A%d;%s;%s Reward per arm: ",
						sim_time, agent_id, LOG_C00, LOG_LVL3);
					for(int n = 0; n < num_arms; n++){
						 if(save_logs){
							 fprintf(logger.file, "%f  ", reward_per_arm[n]);
						 }
					}
					if(save_logs) fprintf(logger.file, "\n%.15f;A%d;%s;%s Cumulative reward per arm: ",
						sim_time, agent_id, LOG_C00, LOG_LVL3);
					for(int n = 0; n < num_arms; n++){
						 if(save_logs){
							 fprintf(logger.file, "%f  ", cumulative_reward_per_arm[n]);
						 }
					}
					fprintf(logger.file, "\n%.15f;A%d;%s;%s Times each arm has been selected: ",
									sim_time, agent_id, LOG_C00, LOG_LVL3);
					for(int n = 0; n < num_arms; n++){
						if(save_logs){
							fprintf(logger.file, "%d ", times_arm_has_been_selected[n]);
						}
					}
					if(save_logs) fprintf(logger.file, "\n");
					break;
				}
			}
		}

		


		void PrintAvailableActionSelectionStrategies(){
			printf("%s Available types of action-selection strategies:\n", LOG_LVL2);
			printf("%s STRATEGY_EGREEDY (%d)\n", LOG_LVL3, STRATEGY_EGREEDY);
			printf("%s STRATEGY_THOMPSON_SAMPLING (%d)\n", LOG_LVL3, STRATEGY_THOMPSON_SAMPLING);
		}

		
		
		
		
		

		


		void InitializeVariables(){
			
			initial_epsilon = 1;
			epsilon = initial_epsilon;
			initial_reward = 0;
			num_iterations = 1;
			
			reward_per_arm = new double[num_arms];
			cumulative_reward_per_arm = new double[num_arms];
			average_reward_per_arm = new double[num_arms];
			estimated_reward_per_arm = new double[num_arms];
			
			times_arm_has_been_selected = new int[num_arms];
			for(int i = 0; i < num_arms; ++i){
				reward_per_arm[i] = initial_reward;	
				cumulative_reward_per_arm[i] = initial_reward;
				average_reward_per_arm[i] = initial_reward;
				estimated_reward_per_arm[i] = initial_reward;
				times_arm_has_been_selected[i] = 0;
			}
		}

};

#endif

#line 60 "../learning_modules/ml_model.h"


#line 1 "../learning_modules//network_optimization_methods/rtot_algorithm.h"













































 









#line 1 "../learning_modules//network_optimization_methods/../../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 55 "../learning_modules//network_optimization_methods/rtot_algorithm.h"


#ifndef _AUX_RTOT_ALG_
#define _AUX_RTOT_ALG_

class RtotAlgorithm {

	
	public:

		int num_stas;				
		double *rssi_per_sta;		
		double *obss_pd_per_sta;	

		double margin_rtot;			

	
	private:

	
	public:

		
		
		
		
		

		



		double UpdateObssPd(double rssi) {
			return ComputeObssPdRtotAlgorithm(rssi, margin_rtot);
		}

		



		double ComputeObssPdRtotAlgorithm(double rssi, double margin_rtot) {

			
			double obss_pd_dbm(0);
			obss_pd_dbm = floor(ConvertPower(PW_TO_DBM, rssi) - ConvertPower(PW_TO_DBM, margin_rtot));
			if (obss_pd_dbm > OBSS_PD_MAX) obss_pd_dbm = OBSS_PD_MAX;
			else if (obss_pd_dbm < OBSS_PD_MIN) obss_pd_dbm = OBSS_PD_MIN;

			printf("[RTOT] New OBSS/PD computed = %f dBm\n", floor(obss_pd_dbm));

			return ConvertPower(DBM_TO_PW, obss_pd_dbm);

		}

		
		
		
		
		

		


		void InitializeVariables(){
			rssi_per_sta = new double[num_stas];
			obss_pd_per_sta = new double[num_stas];
			for (int i = 0 ; i < num_stas ; ++ i) {
				rssi_per_sta[i] = 0;
				obss_pd_per_sta[i] = 0;
			}
		}

		




		void PrintOrWriteInformation(int write_or_print, Logger &logger) {
			
			switch(write_or_print){
				
				case PRINT_LOG:{
					printf("%s RTOT algorithm information...\n", LOG_LVL1);
					printf("%s num_stas = %d\n", LOG_LVL2, num_stas);
					printf("%s margin_rtot = %f\n", LOG_LVL2, ConvertPower(PW_TO_DBM, margin_rtot));
					break;
				}
				
				case WRITE_LOG:{
					fprintf(logger.file, "RTOT algorithm statistics...\n");
					break;
				}
			}
		}

		




		void PrintOrWriteStatistics(int write_or_print, Logger &logger) {
			
			switch(write_or_print){
				
				case PRINT_LOG:{
					printf("%s RTOT algorithm statistics...\n", LOG_LVL1);
					printf("%s rssi_per_sta: ", LOG_LVL2);
					for (int i = 0 ; i < num_stas; ++i) {
						printf("%f dBm ", ConvertPower(PW_TO_DBM, rssi_per_sta[i]));
					}
					printf("\n");
					printf("%s obss_pd_per_sta: ", LOG_LVL2);
					for (int i = 0 ; i < num_stas; ++i) {
						printf("%f dBm ", ConvertPower(PW_TO_DBM, obss_pd_per_sta[i]));
					}
					printf("\n");
					break;
				}
				
				case WRITE_LOG:{
					fprintf(logger.file, "RTOT algorithm statistics...\n");
					break;
				}
			}
		}


};

#endif

#line 61 "../learning_modules/ml_model.h"


#ifndef _AUX_ML_MODEL_
#define _AUX_ML_MODEL_

class MlModel {

	
	public:

		
		int agent_id;					
		int learning_mechanism;			
		int action_selection_strategy;	

		
		int save_logs;		
		int print_logs;		

		
		int agents_number;				
		int wlans_number;				
		int total_nodes_number;			
		int num_channels;				

		
		int num_arms;				
		int max_number_of_actions;		
		int num_stas;					
		double margin_rtot;				

	
	private:

		
		MultiArmedBandit mab_agent;				
		RtotAlgorithm rtot_alg;					
		CentralizedActionBanning action_banner;	

	
	public:

		
		
		
		
		

		





		void ComputeGlobalConfiguration(Configuration *configuration_array, ControllerReport &controller_report,
			Logger &central_controller_logger, double sim_time) {

			switch(learning_mechanism) {
				
				case CENTRALIZED_ACTION_BANNING: {
					
					action_banner.UpdateConfiguration(configuration_array, controller_report, central_controller_logger, sim_time);

					break;
				}
				default: {
					printf("[ML MODEL] ERROR, UNKOWN LEARNING MECHANISM ('%d')\n", learning_mechanism);
					exit(-1);
				}
			}

		}

		
		
		
		
		

		







		int ComputeIndividualConfiguration(int arm_ix, double reward,
			Logger &agent_logger, double sim_time, int *available_arms) {

			int new_action(0);
			switch(learning_mechanism) {
				
				case MULTI_ARMED_BANDITS: {
					
					mab_agent.UpdateArmStatistics(arm_ix, reward);
					
					new_action = mab_agent.SelectNewAction(available_arms, arm_ix);
					break;
				}
				case RTOT_ALGORITHM: {
					new_action = rtot_alg.UpdateObssPd(reward);
					break;
				}
				case CENTRALIZED_ACTION_BANNING: {
					printf("[ML MODEL] ERROR, Action-Banning is not a decentralized ML method. Use 'CentralizedActionBanning()' instead.\n");
					break;
				}
				default: {
					printf("[ML MODEL] ERROR, UNKOWN LEARNING MECHANISM ('%d')\n", learning_mechanism);
					exit(-1);
				}
			}
			return new_action;
		};

		
		
		
		
		

		


		void InitializeVariables() {

			switch(learning_mechanism) {
				
				case MONITORING_ONLY:{
					
					break;
				}
				
				case CENTRALIZED_ACTION_BANNING: {
					action_banner.save_logs = save_logs;
					action_banner.print_logs = print_logs;
					action_banner.agents_number = agents_number;
					action_banner.max_number_of_actions = max_number_of_actions;
					action_banner.InitializeVariables();
					break;
				}
				
				case MULTI_ARMED_BANDITS: {
					mab_agent.agent_id = agent_id;
					mab_agent.save_logs = save_logs;
					mab_agent.print_logs = print_logs;
					mab_agent.action_selection_strategy = action_selection_strategy;
					mab_agent.num_arms = num_arms;
					mab_agent.InitializeVariables();
					break;
				}
				
				case RTOT_ALGORITHM: {
					rtot_alg.num_stas = num_stas;
					rtot_alg.margin_rtot = margin_rtot;
					rtot_alg.InitializeVariables();
					break;
				}
				
				
				

				
				default: {
					printf("[ML MODEL] ERROR: '%d' is not a correct learning mechanism\n", learning_mechanism);
					PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}
		}

		
		
		
		
		

		





		void PrintOrWriteStatistics(int write_or_print, Logger &logger, double sim_time) {

			switch(learning_mechanism) {
				
				case MONITORING_ONLY:{
					
					break;
				}
				
				case MULTI_ARMED_BANDITS: {
					mab_agent.PrintOrWriteStatistics(write_or_print, logger, sim_time);
					break;
				}
				case RTOT_ALGORITHM: {
					rtot_alg.PrintOrWriteStatistics(write_or_print, logger);
					break;
				}
				case CENTRALIZED_ACTION_BANNING: {
                    action_banner.PrintOrWriteStatistics(write_or_print, logger);
					break;
				}
				
				default: {
					printf("[ML MODEL] ERROR: '%d' is not a correct learning mechanism\n", learning_mechanism);
					PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}

		}

		


		void PrintAvailableLearningMechanisms(){
			printf("%s Available types of learning mechanisms:\n", LOG_LVL2);
			printf("%s MULTI_ARMED_BANDITS (#%d)\n", LOG_LVL3, MULTI_ARMED_BANDITS);
			printf("%s ACTION_BANNING (#%d)\n", LOG_LVL3, ACTION_BANNING);
			printf("%s RTOT_ALGORITHM (#%d)\n", LOG_LVL3, RTOT_ALGORITHM);
		}

};

#endif

#line 68 "agent.h"




#line 215 "agent.h"
;





#line 240 "agent.h"
;





#line 252 "agent.h"
;











#line 271 "agent.h"
;







#line 326 "agent.h"
;






#line 353 "agent.h"
;














#line 76 "komondor_main.cc"


#line 1 "central_controller.h"













































 








#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <iostream>
#include <stdlib.h>


#line 1 "../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 61 "central_controller.h"



#line 1 "../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../structures/../methods/power_channel_methods.h"


#line 1 "../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../structures/../methods/power_channel_methods.h"


#line 1 "../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 63 "central_controller.h"


#line 1 "../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 64 "central_controller.h"


#line 1 "../structures/action.h"

















































#line 1 "../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 49 "../structures/action.h"


#line 1 "../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 50 "../structures/action.h"


#ifndef _AUX_ACTION_
#define _AUX_ACTION_


struct Action
{

	int id;				

	
	int channel;		
	double cca;			
	double tx_power;	
	int max_bandwidth;	

	
	double instantaneous_reward;    
	double cumulative_reward;       
	int times_played;               

	
	Performance performance_since_last_cc_request;     
	double cumulative_reward_since_last_cc_request;    
	int times_played_since_last_cc_request;            
	double average_reward_since_last_cc_request;       

	


	void PrintAction() {
		printf("------------\n Action %d:\n", id);
		printf(" * channel = %d\n", channel);
		printf(" * cca = %f dBm\n", ConvertPower(PW_TO_DBM, cca));
		printf(" * tx_power = %f dBm\n", ConvertPower(PW_TO_DBM, tx_power));
		printf(" * max_bandwidth = %d\n", max_bandwidth);
		printf("------------\n");
	}

	






	void WriteAction(Logger logger, int save_logs, double sim_time, char string_device[]) {
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s Action (%d):\n", sim_time, string_device, LOG_C03, LOG_LVL2, id);
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s channel = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, channel);
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s cca = %f dBm\n", sim_time, string_device, LOG_C03, LOG_LVL3, ConvertPower(PW_TO_DBM, cca));
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s tx_power = %f dBm\n", sim_time, string_device, LOG_C03, LOG_LVL3, ConvertPower(PW_TO_DBM, tx_power));
		LOGS(save_logs, logger.file, "%.15f;%s;%s;%s max_bandwidth = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, max_bandwidth);
	}

	


	void PrintRewardInformation() {
		printf("------------\n Reward information (a%d):\n", id);
		printf(" * instantaneous_reward = %f\n", instantaneous_reward);
		printf(" * cumulative_reward = %f\n", cumulative_reward);
		printf(" * times_played = %d\n", times_played);
		printf("------------\n");
	}

    






    void WriteRewardInformation(Logger logger, int save_logs, double sim_time, char string_device[]) {
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s Reward information (a%d):\n", sim_time, string_device, LOG_C03, LOG_LVL2, id);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s instantaneous_reward = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, instantaneous_reward);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s cumulative_reward = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, cumulative_reward);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s times_played = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, times_played);
    }

    


        void PrintControllerStatistics() {
            printf("------------\n Information since last CC request (a%d):\n", id);
            printf(" * cumulative_reward_since_last_request = %f\n", cumulative_reward_since_last_cc_request);
            printf(" * times_played_since_last_request = %d\n", times_played_since_last_cc_request);
            printf(" * average_reward_since_last_request = %f\n", average_reward_since_last_cc_request);
            printf("------------\n");
        }

    






    void WriteControllerStatistics(Logger logger, int save_logs, double sim_time, char string_device[]) {
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s Information since last CC request (a%d):\n", sim_time, string_device, LOG_C03, LOG_LVL2, id);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s cumulative_reward_since_last_request = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, cumulative_reward_since_last_cc_request);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s times_played_since_last_request = %d\n", sim_time, string_device, LOG_C03, LOG_LVL3, times_played_since_last_cc_request);
        LOGS(save_logs, logger.file, "%.15f;%s;%s;%s average_reward_since_last_request = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3, average_reward_since_last_cc_request);
    }

};

#endif

#line 65 "central_controller.h"


#line 1 "../structures/controller_report.h"


















































#line 1 "../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 50 "../structures/controller_report.h"


#line 1 "../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 51 "../structures/controller_report.h"


#ifndef _AUX_CC_REPORT_
#define _AUX_CC_REPORT_


struct ControllerReport
{

	
	int cc_iteration;
	int agents_number;
	int max_number_of_actions;
	
	int **clusters_per_wlan;
	double *cluster_performance;
	
	Configuration *last_configuration_array;	
	Performance *last_performance_array;		
	
	double *performance_per_agent;				
	double *average_performance_per_agent;		
	int *num_arms_per_agent;
	int **list_of_available_actions_per_agent; 	
	double **performance_action_per_agent;		
	int **times_action_played_per_agent;		
	int *most_played_action_per_agent;			

	






	void PrintOrWriteAvailableActions(int write_or_print, Logger &logger, int save_logs, double sim_time) {
		switch(write_or_print){
			
			case PRINT_LOG:{
				printf("+ List of available actions (max = %d):\n", max_number_of_actions);
				for(int i = 0; i < agents_number; ++i) {
					printf("	 * Agent %d: ", i);
					for(int j = 0; j < max_number_of_actions; ++j) {
						printf(" %d ", list_of_available_actions_per_agent[i][j]);
					}
					printf("\n");
				}
				break;
			}
			
			case WRITE_LOG:{
				LOGS(save_logs, logger.file, "%.15f;CC;%s;%s List of available actions:\n", sim_time, LOG_C00, LOG_LVL2);
				for(int i = 0; i < agents_number; ++i) {
					LOGS(save_logs, logger.file, "%.15f;CC;%s;%s Agent %d: ", sim_time, LOG_C00, LOG_LVL3, i);
					for(int j = 0; j < max_number_of_actions; ++j) {
						LOGS(save_logs, logger.file, " %d ", list_of_available_actions_per_agent[i][j]);
						printf(" %d ", list_of_available_actions_per_agent[i][j]);
					}
					LOGS(save_logs, logger.file, "\n");
				}
				break;
			}
		}
	}

	


	void SetSizeOfArrays(){
		
		last_configuration_array = new Configuration[agents_number];
		last_performance_array = new Performance[agents_number];
		
		performance_per_agent = new double[agents_number];
		average_performance_per_agent = new double[agents_number];
		performance_action_per_agent = new double *[agents_number];
		list_of_available_actions_per_agent = new int *[agents_number];
		num_arms_per_agent = new int[agents_number];
		times_action_played_per_agent = new int *[agents_number];
		most_played_action_per_agent = new int[agents_number];
		
		clusters_per_wlan = new int *[agents_number];
		cluster_performance = new double[agents_number];
		
		for (int i = 0; i < agents_number; ++i) {
			list_of_available_actions_per_agent[i] = new int[max_number_of_actions];
			performance_action_per_agent[i] = new double[max_number_of_actions];
			times_action_played_per_agent[i] = new int[max_number_of_actions];
			clusters_per_wlan[i] = new int[agents_number];
		}
	}

};

#endif


#line 66 "central_controller.h"



#line 1 "../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 68 "central_controller.h"


#line 1 "../methods/agent_methods.h"













































 






#line 1 "../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 52 "../methods/agent_methods.h"


#ifndef _AUX_AGENT_METHODS_
#define _AUX_AGENT_METHODS_






void RestartPerformanceMetrics(Performance *current_performance, double sim_time, int num_channels_allowed) {

	current_performance->timestamp = sim_time;
	current_performance->throughput = 0;
	current_performance->max_bound_throughput = 0;
	current_performance->data_packets_sent = 0;
	current_performance->data_packets_lost = 0;
	current_performance->rts_cts_sent = 0;
	current_performance->rts_cts_lost = 0;
	current_performance->num_packets_generated = 0;
	current_performance->num_packets_dropped = 0;

	for(int n = 0; n < num_channels_allowed; ++n){
		current_performance->total_time_transmitting_in_num_channels[n] = 0;
		current_performance->total_time_lost_in_num_channels[n] = 0;
	}

}





bool CheckValidityOfData(Configuration configuration, Performance performance,
		double sim_time, double max_time_validity_information) {



	bool data_still_valid(false);
	if ( (sim_time - performance.timestamp > max_time_validity_information)
			|| (sim_time - configuration.timestamp > max_time_validity_information) ) {
		data_still_valid = false;
	} else {
		data_still_valid = true;
	}
	return data_still_valid;
}

#endif


#line 69 "central_controller.h"



#line 1 "../learning_modules/pre_processor.h"













































 







#line 1 "../learning_modules/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 53 "../learning_modules/pre_processor.h"



#line 1 "../learning_modules/../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../learning_modules/../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../learning_modules/../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../learning_modules/../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../learning_modules/../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 55 "../learning_modules/pre_processor.h"


#line 1 "../learning_modules/../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 56 "../learning_modules/pre_processor.h"


#ifndef _AUX_PP_
#define _AUX_PP_

class PreProcessor {

	
	public:

		
		int selected_strategy;				

		
		int *list_of_channels;				
		double *list_of_pd_values;			
		double *list_of_tx_power_values;	
		int *list_of_max_bandwidth;			

		
		int num_arms;					
		int num_arms_channel;			
		int num_arms_sensitivity;		
		int num_arms_tx_power;			
		int num_arms_max_bandwidth;		
		int *indexes_selected_arm;			

	
	private:

	
	public:

		
		
		
		
		

		





		int ProcessWlanConfiguration(int learning_mechanism, Configuration configuration) {
			int processed_configuration(0);
			
			switch(learning_mechanism) {
				
				case MULTI_ARMED_BANDITS:{
					
					processed_configuration = FindActionIndexFromConfigurationBandits(configuration, indexes_selected_arm);
					break;
				}
				
				default:{
					printf("[Pre-Processor] ERROR: '%d' is not a correct learning mechanism\n", learning_mechanism);
					PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}
			return processed_configuration;
		};

		






		double ProcessWlanPerformance(Performance performance, int type_of_reward) {
			return GenerateReward(type_of_reward, performance);
		};

		





		double GenerateReward(int type_of_reward, Performance performance) {

            double reward(0);
			
			switch(type_of_reward){
				




				case REWARD_TYPE_PACKETS_SUCCESSFUL:{
					reward = (performance.data_packets_sent-performance.data_packets_lost)/performance.data_packets_sent;
					break;
				}
				




				case REWARD_TYPE_AVERAGE_THROUGHPUT:{
					if (performance.max_bound_throughput == 0) {
						reward = 0;
					} else {
						reward = (double) performance.throughput/performance.max_bound_throughput;
					}
					break;
				}
				


				case REWARD_TYPE_MIN_RSSI:{
					reward = performance.rssi_list_per_sta[0];
					for (int i = 0; i < performance.num_stas; ++i) {
						if(reward > performance.rssi_list_per_sta[i]) reward = performance.rssi_list_per_sta[i];
					}
					break;
				}
				


				case REWARD_TYPE_MAX_DELAY:{
					reward = performance.average_delay;
					break;
				}
				


				case REWARD_TYPE_AVERAGE_DELAY:{
					reward = performance.average_delay;
					break;
				}
                


				case REWARD_TYPE_CHANNEL_OCCUPANCY:{
					reward = performance.successful_channel_occupancy;
				    break;
				}
				
				default:{
					printf("[Pre-Processor] ERROR: '%d' is not a correct type of performance indicator\n", type_of_reward);
					PrintAvailableRewardTypes();
					exit(EXIT_FAILURE);
					break;
				}
			}

			return reward;
		}

		






		Configuration ProcessMLOutput(int learning_mechanism, Configuration configuration, double ml_output) {
			Configuration suggested_configuration;
			
			switch(learning_mechanism){
				case MULTI_ARMED_BANDITS:{
					suggested_configuration = GenerateNewConfigurationBandits(configuration, ml_output);
					break;
				}
				case RTOT_ALGORITHM:{
					suggested_configuration = GenerateNewConfigurationRtotAlg(configuration, ml_output);
					break;
				}
				
				default:{
					printf("[PP] ERROR: %d is not a correct type of learning mechanism. Returning the default configuration.\n", learning_mechanism);
					suggested_configuration = configuration;
					break;
				}
			}
			return suggested_configuration;
		};

		
		
		
		
		

		



		Action* InitializeActions(){
			Action *action_array = new Action[num_arms];
			int *indexes_arm = new int[NUM_FEATURES_ACTIONS];
			for(int i = 0; i < num_arms; ++i) {
				index2values(indexes_arm, i, num_arms_channel,num_arms_sensitivity,
					num_arms_tx_power, num_arms_max_bandwidth);
				action_array[i].id = i;
				
				action_array[i].channel = list_of_channels[indexes_arm[0]];
				action_array[i].cca = list_of_pd_values[indexes_arm[1]];
				action_array[i].tx_power = list_of_tx_power_values[indexes_arm[2]];
				action_array[i].max_bandwidth = list_of_max_bandwidth[indexes_arm[3]];
				
				action_array[i].instantaneous_reward = 0;
				action_array[i].times_played = 0;
				action_array[i].average_reward_since_last_cc_request = 0;
				action_array[i].times_played_since_last_cc_request = 0;

			}
			return action_array;
		}

		





		Configuration GenerateNewConfigurationBandits(Configuration configuration, double ml_output){
			
			index2values(indexes_selected_arm, (int) ml_output, num_arms_channel,
				num_arms_sensitivity, num_arms_tx_power, num_arms_max_bandwidth);
			
			int new_primary = list_of_channels[indexes_selected_arm[0]];
			double new_pd = list_of_pd_values[indexes_selected_arm[1]];
			double new_tx_power = list_of_tx_power_values[indexes_selected_arm[2]];
			int new_max_bandwidth = list_of_max_bandwidth[indexes_selected_arm[3]];
			
			Configuration new_configuration;
			
			new_configuration = configuration;
			
			new_configuration.selected_primary_channel = new_primary;	
			if (configuration.spatial_reuse_enabled) {
				new_configuration.non_srg_obss_pd = new_pd;
			} else {
				new_configuration.selected_pd = new_pd;
			}
			new_configuration.selected_tx_power = new_tx_power;			
			new_configuration.selected_max_bandwidth = new_max_bandwidth;		
			return new_configuration;
		}

		





		int FindActionIndexFromConfigurationBandits(Configuration configuration, int* &indexes_selected_arm) {

		    
			int index_channel = -1;
			int index_pd = -1;
			int index_tx_power = -1;
			int index_max_bandwidth = -1;

			
			for(int i = 0; i < num_arms_channel; i++) {
				if(configuration.selected_primary_channel == list_of_channels[i]) {
					index_channel = i;
				}
			}
			
			double selected_pd;
			if(configuration.spatial_reuse_enabled) {
				selected_pd = configuration.non_srg_obss_pd;
			} else {
				selected_pd = configuration.selected_pd;
			}
			for(int i = 0; i < num_arms_sensitivity; i++) {
				if(selected_pd == list_of_pd_values[i]) {
					index_pd = i;
				}
			}
			
			for(int i = 0; i < num_arms_tx_power; i++) {
				if(configuration.selected_tx_power == list_of_tx_power_values[i]) {
					index_tx_power = i;
				}
			}
			
			for(int i = 0; i < num_arms_max_bandwidth; i++) {
				if(configuration.selected_max_bandwidth == list_of_max_bandwidth[i]) {
					index_max_bandwidth = i;
				}
			}
			
			indexes_selected_arm[0] = index_channel;
			indexes_selected_arm[1] = index_pd;
			indexes_selected_arm[2] = index_tx_power;
			indexes_selected_arm[3] = index_max_bandwidth;
			
			int action_ix = values2index(indexes_selected_arm, num_arms_channel,
				num_arms_sensitivity, num_arms_tx_power, num_arms_max_bandwidth);


			return action_ix;
		}

		
		
		
		
		

		





		Configuration GenerateNewConfigurationRtotAlg(Configuration configuration, double ml_output){
			
			Configuration new_configuration;
			
			new_configuration = configuration;
			new_configuration.non_srg_obss_pd = ml_output;

			return new_configuration;
		}


		
		
		
		
		

		



		void PrintActionBandits(int action_ix){
			index2values(indexes_selected_arm, action_ix, num_arms_channel,
				num_arms_sensitivity, num_arms_tx_power, num_arms_max_bandwidth);
			printf("%s Action %d ([%d %d %d %d]\n", LOG_LVL2,
				action_ix, indexes_selected_arm[0], indexes_selected_arm[1], indexes_selected_arm[2], indexes_selected_arm[3]);
			printf("%s Channel: %d\n", LOG_LVL3, list_of_channels[indexes_selected_arm[0]]);
			printf("%s pd: %.2f dBm\n", LOG_LVL3,
				ConvertPower(PW_TO_DBM, list_of_pd_values[indexes_selected_arm[1]]));
			printf("%s Tx Power: %.2f dBm\n", LOG_LVL3,
				ConvertPower(PW_TO_DBM, list_of_tx_power_values[indexes_selected_arm[2]]));
			printf("%s Max bandwidth: %d\n", LOG_LVL3, list_of_max_bandwidth[indexes_selected_arm[3]]);
		}

		



		void PrintOrWriteAvailableActions(int print_or_write, char string_device[],
			int save_logs, Logger &logger, double sim_time, int *list_of_available_actions) {

			switch(print_or_write) {
				case PRINT_LOG: {
					printf("%s List of available actions: ", string_device);
					for (int i = 0; i < num_arms; ++i) {
						printf("%d ", list_of_available_actions[i]);
					}
					printf("\n");
					break;
				}
				case WRITE_LOG: {
					LOGS(save_logs,logger.file,
						"%.15f;%s;%s;%s List of available actions: ",
						sim_time, string_device, LOG_C00, LOG_LVL2);
					for (int i = 0; i < num_arms; ++i) {
						LOGS(save_logs, logger.file, "%d ", list_of_available_actions[i]);
					}
					LOGS(save_logs,logger.file, "\n");
				}
			}

		}

		


		void PrintAvailableRewardTypes(){
			printf("%s Available types of rewards:\n%s REWARD_TYPE_PACKETS_SUCCESSFUL (%d)\n"
				"%s REWARD_TYPE_AVERAGE_THROUGHPUT (%d)\n%s REWARD_TYPE_MIN_RSSI (%d)\n"
				"%s REWARD_TYPE_MAX_DELAY (%d)\n%s REWARD_TYPE_AVERAGE_DELAY (%d)\n%s REWARD_TYPE_CHANNEL_OCCUPANCY (%d)",
				LOG_LVL2, LOG_LVL3, REWARD_TYPE_PACKETS_SUCCESSFUL, LOG_LVL3, REWARD_TYPE_AVERAGE_THROUGHPUT,
				LOG_LVL3, REWARD_TYPE_MIN_RSSI, LOG_LVL3, REWARD_TYPE_MAX_DELAY, LOG_LVL3, REWARD_TYPE_AVERAGE_DELAY,
				LOG_LVL3, REWARD_TYPE_CHANNEL_OCCUPANCY);
		}

		


		void PrintAvailableLearningMechanisms(){
			printf("%s Available types of learning mechanisms:\n", LOG_LVL2);
			printf("%s MULTI_ARMED_BANDITS (%d)\n", LOG_LVL3, MULTI_ARMED_BANDITS);
		}

		



		void WritePerformance(Logger &logger, double sim_time, char string_device[],
				Performance performance, int type_of_reward) {

			LOGS(TRUE, logger.file, "%.15f;%s;%s;%s Performance:\n", sim_time, string_device, LOG_C03, LOG_LVL2);
			switch(type_of_reward) {
				
				case REWARD_TYPE_PACKETS_SUCCESSFUL:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Packet successful ratio = %f\n", sim_time, string_device, LOG_C03, LOG_LVL3,
						(double)((performance.data_packets_sent-performance.data_packets_lost)/performance.data_packets_sent));
					break;
				}
				
				case REWARD_TYPE_AVERAGE_THROUGHPUT:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Average throughput = %.2f Mbps\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.throughput * pow(10,-6));
					break;
				}
				
				case REWARD_TYPE_MIN_RSSI:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Min RSSI = %.2f dBm\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.rssi_list_per_sta[0]);
					break;
				}
				
				case REWARD_TYPE_MAX_DELAY:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Max delay = %.2f ms\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.average_delay * pow(10,-3));
					break;
				}
				
				case REWARD_TYPE_AVERAGE_DELAY:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Average delay = %.2f ms\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.average_delay * pow(10,-3));
					break;
				}
				
				case REWARD_TYPE_CHANNEL_OCCUPANCY:{
					LOGS(TRUE, logger.file,
						"%.15f;%s;%s;%s Successful channel successful_channel_occupancy = %.2f\n", sim_time, string_device,
						LOG_C03, LOG_LVL3, performance.successful_channel_occupancy);
					break;
				}
			}

		}

		
		
		
		
		

		







		void index2values(int *indexes, int action_ix, int size_channels, int size_pd, int size_tx_power, int size_max_bandwidth) {
			indexes[0] = (int) action_ix/(size_pd * size_tx_power * size_max_bandwidth);
			indexes[1] = (int) (action_ix - indexes[0] * (size_pd * size_tx_power * size_max_bandwidth))
					/(size_tx_power * size_max_bandwidth);
			indexes[2] = (int) (action_ix -  indexes[0] * (size_pd * size_tx_power * size_max_bandwidth)
					- indexes[1] * (size_tx_power * size_max_bandwidth))
					/(size_max_bandwidth);
			indexes[3] = action_ix % size_max_bandwidth;
		}

		







		int values2index(int *indexes, int size_channels, int size_pd, int size_tx_power, int size_max_bandwidth) {
			int index = indexes[0] * (size_pd * size_tx_power * size_max_bandwidth)
				+ indexes[1] * (size_tx_power * size_max_bandwidth)
				+ indexes[2] * size_max_bandwidth
				+ indexes[3];
			return index;
		}

		


		void InitializeVariables(){
			
			list_of_channels = new int[num_arms_channel];
			list_of_pd_values = new double[num_arms_sensitivity];
			list_of_tx_power_values = new double[num_arms_tx_power];
			list_of_max_bandwidth = new int[num_arms_max_bandwidth];




			
			indexes_selected_arm = new int[NUM_FEATURES_ACTIONS]; 
		}

};

#endif

#line 71 "central_controller.h"


#line 1 "../learning_modules/ml_model.h"













































 







#line 1 "../learning_modules/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 53 "../learning_modules/ml_model.h"



#line 1 "../learning_modules/../structures/node_configuration.h"













































 



#ifndef _AUX_CONFIGURATION_
#define _AUX_CONFIGURATION_


#line 1 "../learning_modules/../structures/../methods/power_channel_methods.h"













































 





#include <stddef.h>
#include <math.h>
#include <iostream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 56 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/../structures/modulations.h"













































 



#ifndef _MCS_CONFIGURATION_
#define _MCS_CONFIGURATION_

struct Mcs_array {
   static const double mcs_array[4][12];
   static const double coding_rate_array[12];
   static const int bits_per_symbol_modulation_array[12];
   static const int modulation_bits[12];
   static const double coding_rates[12];
};


const double Mcs_array::mcs_array[4][12] = {	
	{4* pow(10,6),16* pow(10,6),24* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),73* pow(10,6),81* pow(10,6),
			98* pow(10,6),108* pow(10,6),122* pow(10,6),135* pow(10,6)},
	{8* pow(10,6),33* pow(10,6),49* pow(10,6),65* pow(10,6),98* pow(10,6),130* pow(10,6),146* pow(10,6),163* pow(10,6),
			195* pow(10,6),217* pow(10,6),244* pow(10,6),271* pow(10,6)},
	{17* pow(10,6),68* pow(10,6),102* pow(10,6),136* pow(10,6),204* pow(10,6),272* pow(10,6),306* pow(10,6),
			340*pow(10,6),408* pow(10,6),453* pow(10,6),510 * pow(10,6),567 * pow(10,6)},
	{34 * pow(10,6),136 * pow(10,6),204 * pow(10,6),272 * pow(10,6),408 * pow(10,6),544 * pow(10,6),613 * pow(10,6),
			681 * pow(10,6),817 * pow(10,6),907 * pow(10,6),1021 * pow(10,6),1134 * pow(10,6)}};

const double Mcs_array::coding_rate_array[12] = {1/double(2), 1/double(2), 3/double(4), 1/double(2),
	3/double(4), 2/double(3), 3/double(4), 5/double(6), 3/double(4), 5/double(6), 3/double(4), 5/double(6)};

const int Mcs_array::bits_per_symbol_modulation_array[12] = {2, 4, 4, 16, 16, 64, 64, 64, 256, 256, 1024, 1024};



const int Mcs_array::modulation_bits[12] = {	
	1,	
	2,	
	2,	
	4,	
	4,	
	6,	
	6,	
	6,	
	8,	
	8,	
	10,	
	10	
};

const double Mcs_array::coding_rates[12] = {	
	1/double(2),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	3/double(4),	
	1/double(2),	
	2/double(3),	
	3/double(4),	
	3/double(4),	
	5/double(6),	
	3/double(4),	
	5/double(6)		
};






int getNumberSubcarriers(int num_channels){

	int num_subcarriers;

	switch(num_channels){

		
		case 1:{
			num_subcarriers = 234;
			break;
		}

		
		case 2:{
			num_subcarriers = 468;
			break;
		}

		
		case 4:{
			num_subcarriers = 980;
			break;
		}

		
		case 8:{
			num_subcarriers = 1960;
			break;
		}

	}

	return num_subcarriers;

}

#endif


#line 57 "../learning_modules/../structures/../methods/power_channel_methods.h"


#line 1 "../learning_modules/../structures/../methods/auxiliary_methods.h"













































 





#include <math.h>
#include <algorithm>
#include <stddef.h>
#include <string>
#include <sstream>


#line 1 "../learning_modules/../structures/../methods/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 58 "../learning_modules/../structures/../methods/auxiliary_methods.h"


#ifndef _AUX_METHODS_
#define _AUX_METHODS_

template <typename T>
std::string ToString(T val)
{
    std::stringstream stream;
    stream << val;
    return stream.str();
}







int PickRandomElementFromArray(int *array, int array_size){
	int element (0);
	
	if(array_size > 0){
		int rand_ix (rand()%(array_size));
		element = array[rand_ix];
	} else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}







int PickElementFromArrayRR(int *array, int array_size){
	static int i,j;
	int element (0);
	if(array_size > 0){
		element = array[j];
		j = (++i)%array_size;
	}
	else {
		element = NODE_ID_NONE;
		printf("The list does not contain elements!\n");
	}
	return element;
}










void PrintOrWriteArrayInt(int *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%d  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteArrayDouble(double *list, int list_size, int write_or_print, int save_node_logs,
	int print_node_logs, Logger node_logger) {

	switch(write_or_print){

		case PRINT_LOG:{
			if(print_node_logs){
				for(int c = 0; c < list_size; ++c){
					printf("%.2f  ", list[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < list_size; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%f  ", list[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}

}








int GetFirstOrLastTrueElemOfArray(int first_or_last, int *list, int list_size){

	int left_ix (0);
	int left_ix_is_set (0);
	int right_ix (0);

	for(int ix = 0; ix < list_size; ++ix){
		if(list[ix]){
			if(!left_ix_is_set){
				left_ix = ix;
				left_ix_is_set = TRUE;
			}
			if(right_ix < ix) right_ix = ix;
		}
	}

	switch(first_or_last){
		case LAST_TRUE_IN_ARRAY:{
			return right_ix; 
			break;
		}
		case FIRST_TRUE_IN_ARRAY:{
			return left_ix; 
			break;
		}
		default:{
			printf("Backoff type not found!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

}








int GetNumberOfSpecificElementInArray(int value, int* array, int list_size){
	int num (0);
	for(int i=0; i<list_size; ++i){
		if(array[i]==value) ++num;
	}
	return num;
}







double RandomDouble(double min, double max)
{
    double f ((double)rand() / RAND_MAX);
    return min + f * (max - min);
}







double TruncateDouble(double number, int floating_position){
    double x (pow(10,floating_position) * number);
    double y (x / pow(10,floating_position));
    return y;
}







double RoundToDigits(double value, int digits)
{
    if (value == 0.0) 
        return 0.0;
    
    double factor (pow(10.0, digits));
    double rounded_numerator (round(value * factor));
    double rounded_value (rounded_numerator / factor);
    
    return rounded_value;
}








double FixTimeOffset(double time_value, int trunc_pos, int round_pos){

	double truncated_value (0);
	double rounded_value (0);
	double fixed_time_value (0);
	
	if (trunc_pos != 0) {
		truncated_value = TruncateDouble(time_value, trunc_pos);
		rounded_value = RoundToDigits(truncated_value,round_pos);
		fixed_time_value = rounded_value;




	} else {
		rounded_value = RoundToDigits(time_value,round_pos);
		fixed_time_value = rounded_value;
	}



	return fixed_time_value;
}

#endif


#line 58 "../learning_modules/../structures/../methods/power_channel_methods.h"


#ifndef _POWER_METHODS_
#define _POWER_METHODS_







double ConvertPower(int conversion_type, double power_magnitude_in){

  double converted_power (0);

  switch(conversion_type){
    
    case PW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-9));
      break;
    }
    
    case DBM_TO_PW:{
      converted_power = pow(10,(power_magnitude_in + 90)/10);
      break;
    }
    
    case MW_TO_DBM:{
      converted_power = 10 * log10(power_magnitude_in * pow(10,-6));
      break;
    }
    
    case DBM_TO_MW:
    case DB_TO_LINEAR:
    case DBW_TO_W: {
      converted_power = pow(10,power_magnitude_in/10);
      break;
    }
    
    case W_TO_DBW:
    case LINEAR_TO_DB: {
      converted_power = 10 * log10(power_magnitude_in);
      break;
    }
    default:{
      printf("Power conversion type not found!\n");
      break;
    }
  }
  return converted_power;
}











double ComputeDistance(double x1, double y1, double z1, double x2, double y2, double z2){
  double distance (sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)));
  return distance;
}









double ComputePowerReceived(double distance, double tx_power, double central_frequency, int path_loss_model) {






	double tx_power_dbm (ConvertPower(PW_TO_DBM, tx_power));
	double tx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_TX_GAIN_DB));
	double rx_gain (ConvertPower(DB_TO_LINEAR, ANTENNA_RX_GAIN_DB));
	double pw_received_dbm;
	double wavelength ((double) SPEED_LIGHT/central_frequency);
	double loss;

	double pw_received;	

	switch(path_loss_model){
		
		case PATH_LOSS_LFS:{
			pw_received = tx_power * tx_gain * rx_gain * pow(((double) SPEED_LIGHT/(4*M_PI*distance*central_frequency)),2);
			break;
		}
		
		case PATH_LOSS_OKUMURA_HATA:{
			double tx_heigth (10);    
			double rx_heigth (10);    
			double path_loss_A (69.55 + 26.16 * log10(3*pow(10,8)/wavelength) - 13.82 * log10(tx_heigth));
			double path_loss_B (44.9 - 6.55 * log10(tx_heigth));
			double path_loss_E (3.2 * pow(log10(11.7554 * rx_heigth),2) - 4.97);
			double path_loss (path_loss_A + path_loss_B * log10(distance/1000) - path_loss_E);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - path_loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double obstacles_at_wlan ((((double) rand())/RAND_MAX)*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}
		
		case PATH_LOSS_INDOOR_2: {
			double path_loss_factor (5);
			double shadowing (9.5);
			double obstacles (30);
			double walls_frequency (5); 
			double shadowing_at_wlan (1/2*shadowing);
			double obstacles_at_wlan (1/2*obstacles);
			double alpha (4.4); 
			double path_loss (path_loss_factor + 10*alpha*log10(distance) + shadowing_at_wlan +
			  (distance/walls_frequency)*obstacles_at_wlan);
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - path_loss; 
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_1_TGax: {
			int n_walls(10);   
			int n_floors(3);   
			int L_iw(5);     
			double min_d(distance);
			if (distance > 5) { min_d = 5; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d) +
				  18.3*pow((distance/n_floors),(((distance/n_floors)+2)/((distance/n_floors)+1))
						  - 0.46) + L_iw*(distance/n_walls));
			double d_BP (5);    
			if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/double(5));
			} else {
			loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_2_TGax: {
			int f_walls(12/20);   
			double min_d(distance);
			if (distance > 10) { min_d = 1; }
			double central_frequency_ghz(central_frequency / pow(10,9));
			double shadowing (5);
			double shadowing_at_wlan ((((double) rand())/RAND_MAX)*shadowing);
			double LFS (40.05 + 20*log10(central_frequency_ghz/2.4) + 20*log10(min_d)
				+ 7*(distance*f_walls) + shadowing_at_wlan);
			int d_BP (1);    
			if (distance >= d_BP) {
				loss = LFS + 35*log10(distance/10);
			} else {
				loss = LFS;
			}
			pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			
			break;
	
	
	
	
		}

		
		
		
		
		case PATH_LOSS_SCENARIO_3_TGax: {
		  double LFS (32.4 + 20*log10(2.4*pow(10,3))+ 20*log10(distance/1000));
		  int d_BP (10);    
		  if (distance >= d_BP) {
			loss = LFS + 35*log10(distance/d_BP);
		  } else {
			loss = LFS;
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB + ANTENNA_RX_GAIN_DB - loss;
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4_TGax: {
		  double h_AP (10);    
		  double h_STA (1.5);   
		  double d_BP ((4 * (h_AP - 1) * (h_STA - 1) * central_frequency) / SPEED_LIGHT);
		  if (distance < d_BP && distance >= 10) {
			loss = 22 * log10(distance) + 28 + 20  *log10(central_frequency * pow(10,-9));
		  } else if (distance >= d_BP && distance < 5000) {
			loss = 40 * log10(distance) + 7.8 + 18 * log10(h_AP - 1) -
				18 * log10(h_STA - 1)  + 20 * log10(central_frequency * pow(10,-9));
		  }
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		
		
		case PATH_LOSS_SCENARIO_4a_TGax: {
		
		
		  if (distance < 2000 && distance >= 10) {
			loss = 36.7 * log10(distance) + 22.7 + 26  * log10(central_frequency * pow(10,-9));
		  }
		  
		  
		  double d_outdoor (0);
		  double d_indoor (0);
		  loss = loss * (d_outdoor + d_indoor) + 20 + 0.5 * d_indoor;
		  pw_received_dbm = tx_power_dbm + ANTENNA_TX_GAIN_DB - loss; 
		  pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
		  break;
		}

		



		case PATHLOSS_5GHZ_OFFICE_BUILDING:{
			
			double pl_overall_db;		
			double pl_free_space_db;	
			double alpha (0.44);		
			pl_free_space_db = 20 * log10(distance) + 20 * log10(central_frequency) +
					20 * log10((4*M_PI)/((double) SPEED_LIGHT)) -
					ANTENNA_RX_GAIN_DB - ANTENNA_TX_GAIN_DB;
			pl_overall_db = pl_free_space_db + alpha * distance;
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_INROOM_LOSS_5250KHZ:{
			double pl_overall_db (47.8 + 14.8 * log10(distance));		
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_ROOM_CORRIDOR_5250KHZ:{
			double pl_overall_db;
			if(distance <=  9){
				pl_overall_db = 53.2 + 25.8 * log10(distance);		
			} else {
				pl_overall_db = 56.4 + 29.1 * log10(distance);		
			}
			double pw_received_dbm (ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db);
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		



		case PATHLOSS_TMB:{
			double pl_overall_db;
			pl_overall_db = 54.12 + 10 * 2.06067 * log10(distance) + 5.25 * 0.1467 * distance;
			double pw_received_dbm = ConvertPower(PW_TO_DBM, tx_power) - pl_overall_db;
			pw_received = ConvertPower(DBM_TO_PW, pw_received_dbm);
			break;
		}

		default:{
		  printf("Path loss model not found!\n");
		  break;
		}

	}

	return pw_received;

}







double ComputeTxPowerPerChannel(double current_tx_power, int num_channels_tx){
	double tx_power_per_channel (current_tx_power);
	int num_channels_tx_ix (log2(num_channels_tx));
	for (int num_ch_ix = 0; num_ch_ix < num_channels_tx_ix; ++num_ch_ix){
		
		tx_power_per_channel =  tx_power_per_channel/2;	
	}
	return tx_power_per_channel;
}














void GetChannelOccupancyByCCA(int primary_channel, int pifs_activated, int *channels_free, int min_channel_allowed,
		int max_channel_allowed, double **channel_power, double pd, double *timestampt_channel_becomes_free,
		double sim_time, double pifs){

	switch(pifs_activated){

		case TRUE:{
			double time_channel_has_been_free;	
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if(c == primary_channel){
					if((*channel_power)[c] < pd) channels_free[c] = CHANNEL_FREE;
				} else {
					time_channel_has_been_free = sim_time - timestampt_channel_becomes_free[c];
					
					
					
					if((*channel_power)[c] < pd && time_channel_has_been_free > pifs){
					  channels_free[c] = CHANNEL_FREE;
					} else {
					  channels_free[c] = CHANNEL_OCCUPIED;

					}
				}
			}
			break;
		}

		case FALSE:{
			for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
				if((*channel_power)[c] < pd){
				  channels_free[c] = CHANNEL_FREE;
				} else {
				  channels_free[c] = CHANNEL_OCCUPIED;
				}
			}
			break;
		}
	}

}











void UpdatePowerSensedPerNode(int primary_channel, std::map<int,double> &power_received_per_node,
	Notification notification, double central_frequency, int path_loss_model,
	double pw_received, int start_or_finish) {

	if(primary_channel >= notification.left_channel && primary_channel <= notification.right_channel){

		switch(start_or_finish){

			case TX_INITIATED:{
				power_received_per_node[notification.source_id] = pw_received;
				break;
			}

			case TX_FINISHED:{
				power_received_per_node.erase(notification.source_id);
				break;
			}

			default:{
				printf("ERROR: Unkown start_or_finish instruction");
				exit(EXIT_FAILURE);
				break;
			}
		}

	} else {

		power_received_per_node.erase(notification.source_id);

	}

}

void UpdateRssiPerSta(Wlan wlan, double *rssi_per_sta,
		double *received_power_array, int total_nodes_number){

	int id(0);
	for (int i = 0; i < total_nodes_number; ++i) {
		if (wlan.FindStaInList(i)){
			rssi_per_sta[id] = received_power_array[i];
			++id;
		}
	}

}










void ApplyAdjacentChannelInterferenceModel(int adjacent_channel_model, double total_power[],
	Notification notification, double central_frequency, double pw_received, int path_loss_model){

	
	for(int i = notification.left_channel; i <= notification.right_channel; ++i){
		(total_power)[i] = pw_received;
	}

	double pw_loss_db;
	double total_power_dbm;

	
	switch(adjacent_channel_model){

		case ADJACENT_CHANNEL_NONE:{
			
			break;
		}

		
		case ADJACENT_CHANNEL_BOUNDARY:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				if(c < notification.left_channel || c > notification.right_channel){

					if(c < notification.left_channel) {

						pw_loss_db = 20 * abs(c-notification.left_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					} else if(c > notification.right_channel) {

						pw_loss_db = 20 * abs(c-notification.right_channel);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);

					}

					if((total_power)[c] < MIN_VALUE_C_LANGUAGE){

						(total_power)[c] = 0;

					}

				} else {
					
				}
			}
			break;
		}

		case ADJACENT_CHANNEL_EXTREME:{

			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c) {

				for(int j = notification.left_channel; j <= notification.right_channel; ++j){

					if(c != j) {

						pw_loss_db = 20 * abs(c-j);
						total_power_dbm = ConvertPower(PW_TO_DBM, pw_received) - pw_loss_db;
						(total_power)[c] = (total_power)[c] + ConvertPower(DBM_TO_PW, total_power_dbm);
						if((total_power)[c] < MIN_DOUBLE_VALUE_KOMONDOR) (total_power)[c] = 0;

					}
				}
			}
			break;
		}

		default:{
			printf("ERROR: Unkown cochannel model!");
			exit(EXIT_FAILURE);
			break;
		}
	}

}












void UpdateChannelsPower(double **channel_power, Notification notification,
    int update_type, double central_frequency, int path_loss_model,
	int adjacent_channel_model, double pw_received, int node_id){

	double total_power[NUM_CHANNELS_KOMONDOR];
	memset(total_power, 0, NUM_CHANNELS_KOMONDOR * sizeof(double));

	
	ApplyAdjacentChannelInterferenceModel(adjacent_channel_model, total_power,
		notification, central_frequency, pw_received, path_loss_model);

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){

		switch(update_type){

			case TX_FINISHED:{

				(*channel_power)[c] = (*channel_power)[c] - total_power[c];

				
				if ((*channel_power)[c] < 0.000001) (*channel_power)[c] = 0;
				break;
			}

			case TX_INITIATED:{
				(*channel_power)[c] = (*channel_power)[c] + total_power[c];
				break;
			}

			default:{}
		}

	}
}








double UpdateSINR(double pw_received_interest, double max_pw_interference){
	double sinr (pw_received_interest / (max_pw_interference + ConvertPower(DBM_TO_PW, NOISE_LEVEL_DBM)));
	return sinr;
}










void ComputeMaxInterference(double *max_pw_interference, int *channel_max_intereference,
	Notification notification_interest, int node_state, std::map<int,double> &power_received_per_node,
	double **channel_power) {

	*max_pw_interference = 0;

	for(int c = notification_interest.left_channel; c <= notification_interest.right_channel; ++c){

		if(node_state == STATE_RX_DATA || node_state == STATE_RX_ACK || node_state == STATE_NAV
			|| node_state == STATE_RX_RTS || node_state == STATE_RX_CTS || node_state == STATE_SENSING){

			if(*max_pw_interference <
					((*channel_power)[c] - power_received_per_node[notification_interest.source_id])){

				*max_pw_interference = (*channel_power)[c] - power_received_per_node[notification_interest.source_id];

				*channel_max_intereference = c;

			}
		}
	}
}


void GetTxChannelsByChannelBondingCCA11ax(int *channels_for_tx, int channel_bonding_model, int min_channel_allowed,
		int max_channel_allowed, int primary_channel, double **channel_power){


	int num_channels_allowed = max_channel_allowed - min_channel_allowed + 1;

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	switch(channel_bonding_model){

		
		case CB_ONLY_PRIMARY:{
			if((*channel_power)[primary_channel] < ConvertPower(DBM_TO_PW,-82)) channels_for_tx[primary_channel] = TRUE;
			break;
		}

		case CB_ALWAYS_MAX_LOG2:{

			switch(num_channels_allowed){

				
				case 8: {

					int num_ch_tx_possible = 8;

					
					if(primary_channel <=3){

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

					} else {

						for(int c = 0; c <= 3; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_80MHZ)) num_ch_tx_possible = 4;
						}

						for(int c = 4; c <= 7; ++c){
							if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_80MHZ)) num_ch_tx_possible = 4;
						}

					}

					if (num_ch_tx_possible == 4){
						
						
						if(primary_channel <= 3){

							if(primary_channel <= 1){

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 0; c <= 1; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 2; c <= 3; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}

						} else {

							if(primary_channel <= 5){

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

							} else {

								for(int c = 4; c <= 5; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
								}

								for(int c = 6; c <= 7; ++c){
									if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
								}

							}
						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}
				}

				
				case 4: {

					int num_ch_tx_possible = 4;

					
					
					if(primary_channel <= 3){

						if(primary_channel <= 1){

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 0; c <= 1; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 2; c <= 3; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}

					} else {

						if(primary_channel <= 5){

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

						} else {

							for(int c = 4; c <= 5; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_40MHZ)) num_ch_tx_possible = 2;
							}

							for(int c = 6; c <= 7; ++c){
								if((*channel_power)[c] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_40MHZ)) num_ch_tx_possible = 2;
							}

						}
					}

					if (num_ch_tx_possible == 2){

						
						
						if(primary_channel == 0){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 1){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 2){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 3){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 4){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 5){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 6){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						} else if(primary_channel == 7){
							if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
							if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
						}

					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}

					break;
				}

				
				case 2: {

					int num_ch_tx_possible = 2;

					
					
					if(primary_channel == 0){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 1){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 2){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 3){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 4){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 5){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 6){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel+1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					} else if(primary_channel == 7){
						if((*channel_power)[primary_channel] > ConvertPower(DBM_TO_PW,CCA_PRIMARY_20MHZ)) num_ch_tx_possible = 1;
						if((*channel_power)[primary_channel-1] > ConvertPower(DBM_TO_PW,CCA_SECONDARY_20MHZ)) num_ch_tx_possible = 1;
					}

					if (num_ch_tx_possible == 1){

						channels_for_tx[primary_channel] = TRUE;

					} else if (num_ch_tx_possible == 2){

						if(primary_channel <= 1){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
						} else if(primary_channel <= 3){
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 5){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}

					} else if (num_ch_tx_possible == 4){

						if(primary_channel <= 3){
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						} else if(primary_channel <= 7){
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						}


					} else if (num_ch_tx_possible == 8){
						for(int c = 0; c <= 7; ++c){
							channels_for_tx[c] = TRUE;
						}
					}


					break;
				}

				
				case 1: {

					
					channels_for_tx[primary_channel] = TRUE;

					break;
				}

				break;
			}

		}
	}
}













void GetTxChannelsByChannelBondingCCASame(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_system){

	
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		channels_for_tx[c] = FALSE;
	}

	
	int left_free_ch (0);
	int left_free_ch_is_set (0);	
	int right_free_ch (0);

	for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
		if(channels_free[c]){
			if(!left_free_ch_is_set){
				left_free_ch = c;
				left_free_ch_is_set = TRUE;
			}
			if(right_free_ch < c){
				right_free_ch = c;
			}
		}
	}

	int num_available_ch (max_channel_allowed - min_channel_allowed + 1);
	int log2_modulus;	
	int left_tx_ch;		
	int right_tx_ch; 	

	
	
	int all_channels_free_in_range ( TRUE );	

	
	int possible_channel_ranges_ixs[4] = {FALSE, FALSE, FALSE, FALSE};

	
	if(channels_free[primary_channel]) possible_channel_ranges_ixs[0] = TRUE;

	
	if(NUM_CHANNELS_KOMONDOR > 1){
		if(primary_channel % 2 == 1){	
			if(channels_free[primary_channel - 1]) possible_channel_ranges_ixs[1] = TRUE;
		} else{
			if(channels_free[primary_channel + 1]) possible_channel_ranges_ixs[1] = TRUE;
		}
	}

	
	if(NUM_CHANNELS_KOMONDOR > 3){
		if(primary_channel > 3){	
			for(int c = 0; c < 4; ++c){
				if(!channels_free[4 + c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;

		} else { 
			for(int c = 0; c < 4; ++c){
				if(!channels_free[c]) all_channels_free_in_range = FALSE;
			}
			if(all_channels_free_in_range) possible_channel_ranges_ixs[2] = TRUE;
		}
	}


	
	if(NUM_CHANNELS_KOMONDOR > 7){
		for(int c = 0; c < 8; ++c){
			if(!channels_free[c]) all_channels_free_in_range = FALSE;
		}
		if(all_channels_free_in_range) possible_channel_ranges_ixs[3] = TRUE;
	}

	if(left_free_ch_is_set){

		
		switch(channel_bonding_model){

			
			case CB_ONLY_PRIMARY:{

				if(primary_channel >= left_free_ch && primary_channel <= right_free_ch){
					channels_for_tx[primary_channel] = TRUE;
				}
				break;
			}

			
			case CB_SCB:{

				int tx_possible = TRUE;
				
				for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}

				if(tx_possible){
					left_tx_ch = left_free_ch;
					right_tx_ch = right_free_ch;
					for(int c = min_channel_allowed; c <= max_channel_allowed; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			case CB_SCB_LOG2:{

				while(1){
					
					if(fmod(log10(num_available_ch)/log10(2), 1) == 0){
						log2_modulus = primary_channel % num_available_ch;
						left_tx_ch = primary_channel - log2_modulus;
						right_tx_ch = primary_channel + num_available_ch - log2_modulus - 1;
						
						if((left_tx_ch >= min_channel_allowed) && (right_tx_ch <= max_channel_allowed)){
							
							break;

						} else {
							--num_available_ch;
						}

					} else{
						--num_available_ch;
					}
				}

				
				int tx_possible = TRUE;
				for(int c = left_tx_ch; c <= right_tx_ch; ++c){
					if(!channels_free[c]){
						tx_possible = FALSE;
					}
				}
				if(tx_possible){
					for(int c = left_tx_ch; c <= right_tx_ch; ++c){
						channels_for_tx[c] = TRUE;
					}
				} else {
					
					channels_for_tx[0] = TX_NOT_POSSIBLE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX:{
				for(int c = left_free_ch; c <= right_free_ch; ++c){
					channels_for_tx[c] = TRUE;
				}
				break;
			}

			
			
			case CB_ALWAYS_MAX_LOG2:{

				int ch_range_ix (GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4));

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{
						channels_for_tx[primary_channel] = TRUE;
						if(primary_channel % 2 == 1){	
							channels_for_tx[primary_channel - 1] = TRUE;
						} else{
							channels_for_tx[primary_channel + 1] = TRUE;
						}
						break;
					}

					case 3:{
						
						if(primary_channel > 3){	
							channels_for_tx[4] = TRUE;
							channels_for_tx[5] = TRUE;
							channels_for_tx[6] = TRUE;
							channels_for_tx[7] = TRUE;
						} else { 
							channels_for_tx[0] = TRUE;
							channels_for_tx[1] = TRUE;
							channels_for_tx[2] = TRUE;
							channels_for_tx[3] = TRUE;
						}
						break;
					}

					case 4:{
						for(int c = 0; c < 8; ++c){
							channels_for_tx[c] = TRUE;
						}
						break;
					}

					default:{
						break;
					}

				}


				break;

			}

			
			case CB_ALWAYS_MAX_LOG2_MCS:{

				
				printf("Deprecated CB model. Please, use another one.\n");
				exit(-1);

				break;
				}

			
			case CB_PROB_UNIFORM_LOG2:{

				int ch_range_ix = GetNumberOfSpecificElementInArray(1, possible_channel_ranges_ixs, 4);

				int random_value = 1 + rand() % (ch_range_ix);	

				switch(ch_range_ix){

					case 1:{
						channels_for_tx[primary_channel] = TRUE;
						break;
					}

					case 2:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value > 1){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						}
						break;
					}

					case 3:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						}

						break;
					}

					case 4:{

						channels_for_tx[primary_channel] = TRUE;

						if(random_value == 2){
							if(primary_channel % 2 == 1){	
								channels_for_tx[primary_channel - 1] = TRUE;
							} else{
								channels_for_tx[primary_channel + 1] = TRUE;
							}
						} else if( random_value == 3){
							
							if(primary_channel > 3){	

								channels_for_tx[4] = TRUE;
								channels_for_tx[5] = TRUE;
								channels_for_tx[6] = TRUE;
								channels_for_tx[7] = TRUE;

							} else { 

								channels_for_tx[0] = TRUE;
								channels_for_tx[1] = TRUE;
								channels_for_tx[2] = TRUE;
								channels_for_tx[3] = TRUE;
							}
						} else if(random_value == 4){
							for(int c = 0; c < 8; ++c ){
								channels_for_tx[c] = TRUE;
							}
						}
						break;
					}

					default:{
						break;
					}

				}


				break;


				break;
			}

			default:{
				printf("channel_bonding_model %d is NOT VALID!\n", channel_bonding_model);
				exit(EXIT_FAILURE);
				break;
			}
		}
	} else {  

	channels_for_tx[0] = TX_NOT_POSSIBLE;

	}

}




void UpdateTimestamptChannelFreeAgain(double *timestampt_channel_becomes_free, double **channel_power,
		double current_pd, double sim_time) {

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){

		if((*channel_power)[i] > current_pd) {

			timestampt_channel_becomes_free[i] = -1;

		} else if(timestampt_channel_becomes_free[i] == -1){

			timestampt_channel_becomes_free[i] = sim_time;

		}
	}
}









void PrintOrWriteChannelPower(int write_or_print, int save_node_logs, Logger node_logger,
	int print_node_logs, double **channel_power){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channel_power [dBm]: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				if(save_node_logs) fprintf(node_logger.file, "%f  ", ConvertPower(PW_TO_DBM, (*channel_power)[c]));
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}









void PrintOrWriteChannelsFree(int write_or_print,
		int save_node_logs, int print_node_logs, Logger node_logger, int *channels_free){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_free: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_free[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs) fprintf(node_logger.file, "%d ", channels_free[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void PrintOrWriteNodesTransmitting(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int total_nodes_number,	int *nodes_transmitting){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("Nodes transmitting: ");
				for(int n = 0; n < total_nodes_number; ++n){
					if(nodes_transmitting[n] == TRUE) printf("%d  ", nodes_transmitting[n]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int n = 0; n < total_nodes_number; ++n){
				 if(save_node_logs){
					 if(nodes_transmitting[n])  fprintf(node_logger.file, "N%d ", n);
				 }
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}










void GetMinAndMaxAllowedChannels(int& min_ch, int& max_ch, int primary_channel, int max_bandwidth){

	switch(max_bandwidth){

		
		case 1:{
			min_ch = primary_channel;
			max_ch = primary_channel;
			break;
		}

		
		case 2:{

			if(primary_channel == 0 || primary_channel == 1){
				min_ch = 0;
				max_ch = 1;
			} else if(primary_channel == 2 || primary_channel == 3){
				min_ch = 2;
				max_ch = 3;
			} else if(primary_channel == 4 || primary_channel == 5){
				min_ch = 4;
				max_ch = 5;
			} else if(primary_channel == 6 || primary_channel == 7){
				min_ch = 6;
				max_ch = 7;
			}

			break;
		}

		
		case 4:{
			if(primary_channel <= 3){
				min_ch = 0;
				max_ch = 3;
			} else {
				min_ch = 4;
				max_ch = 7;
			}
			break;
		}

		
		case 8:{
			min_ch = 0;
			max_ch = 7;
			break;
		}

	} 

}














void GetTxChannels(int *channels_for_tx, int channel_bonding_model, int *channels_free,
    int min_channel_allowed, int max_channel_allowed, int primary_channel, int num_channels_komondor,
	double **channel_power, int channel_aggregation_cca_model){

	switch(channel_aggregation_cca_model){

		case CHANNEL_AGGREGATION_CCA_SAME:{
			GetTxChannelsByChannelBondingCCASame(channels_for_tx, channel_bonding_model, channels_free,
					min_channel_allowed, max_channel_allowed, primary_channel, num_channels_komondor);
			break;
		}

		case CHANNEL_AGGREGATION_CCA_11AX:{
			GetTxChannelsByChannelBondingCCA11ax(channels_for_tx, channel_bonding_model, min_channel_allowed,
						max_channel_allowed, primary_channel, channel_power);
			break;
		}

	}

}









void PrintOrWriteChannelForTx(int write_or_print, int save_node_logs, int print_node_logs,
	Logger node_logger, int *channels_for_tx){

	switch(write_or_print){
		case PRINT_LOG:{
			if(print_node_logs){
				printf("channels_for_tx: ");
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("%d  ", channels_for_tx[c]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
				 if(save_node_logs)  fprintf(node_logger.file, "%d  ", channels_for_tx[c]);
			}
			if(save_node_logs)  fprintf(node_logger.file, "\n");
			break;
		}
	}
}

#endif


#line 53 "../learning_modules/../structures/node_configuration.h"


struct Capabilities
{
	std::string node_code;		
	int node_id;				
	double x;					
	double y;					
	double z;					
	int node_type;				


	int primary_channel;		
	int min_channel_allowed;	
	int max_channel_allowed;	
	int num_channels_allowed;	
	double tx_power_default;	
	double sensitivity_default;	
	int current_max_bandwidth;	

	


	void PrintCapabilities(){
		printf("%s Capabilities of node %d:\n", LOG_LVL3, node_id);
		printf("%s node_type = %d\n", LOG_LVL4, node_type);
		printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
		printf("%s primary_channel = %d\n", LOG_LVL4, primary_channel);
		printf("%s min_channel_allowed = %d\n", LOG_LVL4, min_channel_allowed);
		printf("%s max_channel_allowed = %d\n", LOG_LVL4, max_channel_allowed);
		printf("%s current_max_bandwidth = %d\n", LOG_LVL4, current_max_bandwidth);


		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
		printf("\n");
	}

	




	void WriteCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;N%d;%s;%s WLAN capabilities:\n", sim_time, node_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;N%d;%s;%s node_type = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, node_type);
		fprintf(logger.file, "%.15f;N%d;%s;%s position = (%.2f, %.2f, %.2f)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, x, y, z);
		fprintf(logger.file, "%.15f;N%d;%s;%s primary_channel = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, primary_channel);
		fprintf(logger.file, "%.15f;N%d;%s;%s min_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, min_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s max_channel_allowed = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, max_channel_allowed);
		fprintf(logger.file, "%.15f;N%d;%s;%s current_max_bandwidth = %d\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, current_max_bandwidth);




		fprintf(logger.file, "%.15f;N%d;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
		fprintf(logger.file, "%.15f;N%d;%s;%s sensitivity_default = %f pW (%f dBm)\n",
			sim_time, node_id, LOG_F00, LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	}

};

struct AgentCapabilities
{
	int agent_id;					
	double time_between_requests;	
	int num_arms;
	int *available_actions;

	



	void SetSizeOfStaList(int num_arms){
		available_actions = new int[num_arms];
	}

	


	void PrintAgentCapabilities(){
		printf("%s Information of agent %d:\n", LOG_LVL3, agent_id);
		printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
		printf("\n");
	}
	




	void WriteAgentCapabilities(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;A%d;%s;%s Agent information:\n", sim_time, agent_id, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;A%d;%s;%s time_betwee_requests = %f\n",
			sim_time, agent_id,  LOG_F00, LOG_LVL4, time_between_requests);
	}
};


struct Configuration
{
	double timestamp;					

	int selected_primary_channel;		
	double selected_pd;					
	double selected_tx_power;			
	int selected_max_bandwidth;			

	
	int frame_length;
	int max_num_packets_aggregated;

	
	int spatial_reuse_enabled;	
	int bss_color;				
	int srg;					
	double non_srg_obss_pd; 	
	double srg_obss_pd; 		

	Capabilities capabilities;
	AgentCapabilities agent_capabilities;

	



	void PrintConfiguration(int origin){
		if (origin == ORIGIN_AGENT) {
			printf("%s Recommended configuration by the agent:\n", LOG_LVL3);
		} else if (origin == ORIGIN_AP) {
			printf("%s Current configuration of the WLAN:\n", LOG_LVL3);
		} else {
			printf("ERROR: bad origin\n");
		}
		printf("%s selected_primary = %d\n", LOG_LVL4, selected_primary_channel);
		printf("%s pd_default = %f pW (%f dBm)\n", LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		printf("%s selected_max_bandwidth = %d\n", LOG_LVL4, selected_max_bandwidth);
		printf("\n");
	}

	




	void WriteConfiguration(Logger logger, double sim_time){
		fprintf(logger.file, "%.15f;CC;%s;%s WLAN configuration:\n", sim_time, LOG_F00, LOG_LVL3);
		fprintf(logger.file, "%.15f;CC;%s;%s selected_primary = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_primary_channel);
		fprintf(logger.file, "%.15f;CC;%s;%s pd_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_pd, ConvertPower(PW_TO_DBM, selected_pd));
		fprintf(logger.file, "%.15f;CC;%s;%s tx_power_default = %f pW (%f dBm)\n",
			sim_time, LOG_F00, LOG_LVL4, selected_tx_power, ConvertPower(PW_TO_DBM, selected_tx_power));
		fprintf(logger.file, "%.15f;CC;%s;%s selected_max_bandwidth = %d\n",
			sim_time, LOG_F00, LOG_LVL4, selected_max_bandwidth);
	}

};

#endif


#line 55 "../learning_modules/ml_model.h"


#line 1 "../learning_modules/../structures/performance.h"













































 



#ifndef _AUX_PERFORMANCE_
#define _AUX_PERFORMANCE_

struct Performance
{

	
	double timestamp;		        
	double sum_time_channel_idle;	

	
	double throughput;				
	double throughput_loss;			
	double max_bound_throughput;	

	
	int data_packets_acked;			
	int data_frames_acked;			
	int data_packets_sent;			
	int data_packets_lost;			
	int rts_cts_sent;				
	int rts_cts_lost;				
	int rts_lost_slotted_bo;		
	double average_sinr;

	
	int num_packets_generated;		
	int num_packets_dropped;		
	int num_delay_measurements;		
	double sum_delays;				
	double average_delay;			
	double average_rho;				
	double average_utilization;		
	double generation_drop_ratio;	

	
	double *max_received_power_in_ap_per_wlan;
    double *rssi_list;					
    double *received_power_array;		
    double total_channel_occupancy;
    double successful_channel_occupancy;

	
	double expected_backoff;							
	int num_new_backoff_computations;					
	int *num_trials_tx_per_num_channels;				
	double average_waiting_time;						
	double bandwidth_used_txing;						
	int min_channel_allowed;                            
    int max_channel_allowed;                            
	double *total_time_transmitting_per_channel;		
	double *total_time_transmitting_in_num_channels;	
	double *total_time_lost_per_channel;				
	double *total_time_lost_in_num_channels;			
	double *total_time_spectrum_per_channel;			
	double time_in_nav;									

	
    int num_stas;                   
	double *throughput_per_sta;			
	int *data_packets_sent_per_sta;		
	int *rts_cts_sent_per_sta;			
	int *data_packets_lost_per_sta;		
	int *rts_cts_lost_per_sta;			
	int *data_packets_acked_per_sta;	
	int *data_frames_acked_per_sta;		
    double *rssi_list_per_sta;			

	
	int num_tx_init_tried;				
	int num_tx_init_not_possible;		
	double prob_slotted_bo_collision;	

	



	void SetSizeOfChannelLists(int total_channels_number){
		num_trials_tx_per_num_channels = new int[total_channels_number];
		total_time_transmitting_per_channel = new double[total_channels_number];
		total_time_transmitting_in_num_channels = new double[total_channels_number];
		total_time_lost_per_channel = new double[total_channels_number];
		total_time_lost_in_num_channels = new double[total_channels_number];
		total_time_spectrum_per_channel = new double[total_channels_number];
		for(int i = 0; i < total_channels_number; ++i){
			num_trials_tx_per_num_channels[i] = 0;
			total_time_transmitting_per_channel[i] = 0;
			total_time_transmitting_in_num_channels[i] = 0;
			total_time_lost_per_channel[i] = 0;
			total_time_lost_in_num_channels[i] = 0;
			total_time_spectrum_per_channel[i] = 0;
		}
	}

	



	void SetSizeOfStaList(int num_stas){
		throughput_per_sta = new double[num_stas];
		data_packets_sent_per_sta = new int[num_stas];
		rts_cts_sent_per_sta = new int[num_stas];
		data_packets_lost_per_sta = new int[num_stas];
		rts_cts_lost_per_sta = new int[num_stas];
		data_packets_acked_per_sta = new int[num_stas];
		data_frames_acked_per_sta = new int[num_stas];
		for(int i = 0; i < num_stas; ++i){
			throughput_per_sta[i] = 0;
			data_packets_sent_per_sta[i] = 0;
			rts_cts_sent_per_sta[i] = 0;
			data_packets_lost_per_sta[i] = 0;
			rts_cts_lost_per_sta[i] = 0;
			data_packets_acked_per_sta[i] = 0;
			data_frames_acked_per_sta[i] = 0;
		}
	}

	



	void SetSizeOfRssiList(int total_wlans_number){
		rssi_list = new double[total_wlans_number];
		max_received_power_in_ap_per_wlan = new double[total_wlans_number];
		for(int i = 0; i < total_wlans_number; ++i){
			rssi_list[i] = 0;
			max_received_power_in_ap_per_wlan[i] = 0;
		}
	}

	



	void SetSizeOfRxPowerList(int total_nodes_number){
		received_power_array = new double[total_nodes_number];
		for(int i = 0; i < total_nodes_number; ++i){
			received_power_array[i] = 0;
		}
	}

	



	void SetSizeOfRssiPerStaList(int num_stas){
		rssi_list_per_sta = new double[num_stas];
		for(int i = 0; i < num_stas; ++i){
			rssi_list_per_sta[i] = 0;
		}
	}

};

#endif


#line 56 "../learning_modules/ml_model.h"


#line 1 "../learning_modules/../structures/controller_report.h"


















































#line 1 "../learning_modules/../structures/../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 50 "../learning_modules/../structures/controller_report.h"


#line 1 "../learning_modules/../structures/logger.h"

















































#ifndef _AUX_LOGGER_
#define _AUX_LOGGER_

struct Logger
{
	int save_logs;					
	FILE *file;						
	char head_string[INTEGER_SIZE];	

	


	void SetVoidHeadString(){
		sprintf(head_string, "%s", " ");
	}
	
};

#endif


#line 51 "../learning_modules/../structures/controller_report.h"


#ifndef _AUX_CC_REPORT_
#define _AUX_CC_REPORT_


struct ControllerReport
{

	
	int cc_iteration;
	int agents_number;
	int max_number_of_actions;
	
	int **clusters_per_wlan;
	double *cluster_performance;
	
	Configuration *last_configuration_array;	
	Performance *last_performance_array;		
	
	double *performance_per_agent;				
	double *average_performance_per_agent;		
	int *num_arms_per_agent;
	int **list_of_available_actions_per_agent; 	
	double **performance_action_per_agent;		
	int **times_action_played_per_agent;		
	int *most_played_action_per_agent;			

	






	void PrintOrWriteAvailableActions(int write_or_print, Logger &logger, int save_logs, double sim_time) {
		switch(write_or_print){
			
			case PRINT_LOG:{
				printf("+ List of available actions (max = %d):\n", max_number_of_actions);
				for(int i = 0; i < agents_number; ++i) {
					printf("	 * Agent %d: ", i);
					for(int j = 0; j < max_number_of_actions; ++j) {
						printf(" %d ", list_of_available_actions_per_agent[i][j]);
					}
					printf("\n");
				}
				break;
			}
			
			case WRITE_LOG:{
				LOGS(save_logs, logger.file, "%.15f;CC;%s;%s List of available actions:\n", sim_time, LOG_C00, LOG_LVL2);
				for(int i = 0; i < agents_number; ++i) {
					LOGS(save_logs, logger.file, "%.15f;CC;%s;%s Agent %d: ", sim_time, LOG_C00, LOG_LVL3, i);
					for(int j = 0; j < max_number_of_actions; ++j) {
						LOGS(save_logs, logger.file, " %d ", list_of_available_actions_per_agent[i][j]);
						printf(" %d ", list_of_available_actions_per_agent[i][j]);
					}
					LOGS(save_logs, logger.file, "\n");
				}
				break;
			}
		}
	}

	


	void SetSizeOfArrays(){
		
		last_configuration_array = new Configuration[agents_number];
		last_performance_array = new Performance[agents_number];
		
		performance_per_agent = new double[agents_number];
		average_performance_per_agent = new double[agents_number];
		performance_action_per_agent = new double *[agents_number];
		list_of_available_actions_per_agent = new int *[agents_number];
		num_arms_per_agent = new int[agents_number];
		times_action_played_per_agent = new int *[agents_number];
		most_played_action_per_agent = new int[agents_number];
		
		clusters_per_wlan = new int *[agents_number];
		cluster_performance = new double[agents_number];
		
		for (int i = 0; i < agents_number; ++i) {
			list_of_available_actions_per_agent[i] = new int[max_number_of_actions];
			performance_action_per_agent[i] = new double[max_number_of_actions];
			times_action_played_per_agent[i] = new int[max_number_of_actions];
			clusters_per_wlan[i] = new int[agents_number];
		}
	}

};

#endif


#line 57 "../learning_modules/ml_model.h"



#line 1 "../learning_modules//network_optimization_methods/centralized_action_banning.h"













































 






#line 1 "../learning_modules//network_optimization_methods/../../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 52 "../learning_modules//network_optimization_methods/centralized_action_banning.h"


#ifndef _AUX_BANNING_
#define _AUX_BANNING_

class CentralizedActionBanning {

	
	public:

		int save_logs;				
		int print_logs;				

		double *initial_banning_threshold;
		double *current_banning_threshold;
		double MAX_THRESHOLD_BANNING;
		double MIN_THRESHOLD_BANNING;
		double MARGIN_THRESHOLD_BANNING;
        int banning_threshold_type;
        int banning_iteration;

        int banned_in_last_iteration;

        double *max_reward_seen_per_agent;

		int agents_number;
		int max_number_of_actions;

		int **list_of_available_actions_per_agent;
		int *num_arms_per_agent;
		double *average_performance_per_agent;
		double *cluster_performance;
		int **clusters_per_wlan;
		int *most_played_action_per_agent;
		int **times_action_played_per_agent;
		Configuration *configuration_array;

		
		double *previous_performance_per_agent;        
		int *previously_banned_action_per_agent;    
		double DELTA;                               

	
	public:

		
		
		
		
		

		





		void UpdateConfiguration(Configuration *configuration_array, ControllerReport &controller_report,
			Logger central_controller_logger, double sim_time) {

			
			UpdateVariables(controller_report);

			
			RestoreBannedActions(configuration_array, controller_report, central_controller_logger, sim_time);

			
			BanActions(configuration_array, controller_report, central_controller_logger, sim_time);

			
			UpdateBanningThreshold(controller_report, central_controller_logger, sim_time);

		}

		





		void BanActions(Configuration *configuration_array, ControllerReport &controller_report,
			Logger central_controller_logger, double sim_time) {

			
			for(int i = 0; i < agents_number; ++i) {
                
				for(int j = 0; j < agents_number; ++j) {
					if(i != j && clusters_per_wlan[i][j] == 1) {

                        if (average_performance_per_agent[j] < current_banning_threshold[i]) {
							
							if(AssessActionNegativeImpact(i)) {
                                LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s Banned action %d of A%d\n",
                                     sim_time, LOG_C00, LOG_LVL1, most_played_action_per_agent[i], i);
								list_of_available_actions_per_agent[i][most_played_action_per_agent[i]] = 0;
								configuration_array[i].agent_capabilities.available_actions[most_played_action_per_agent[i]] = 0;
                                previously_banned_action_per_agent[i] = most_played_action_per_agent[i];
							}
						}
					}
					
					previous_performance_per_agent[j] = average_performance_per_agent[j];
				}
			}

			++ banning_iteration;

		}

        





		void RestoreBannedActions(Configuration *configuration_array, ControllerReport &controller_report,
            Logger central_controller_logger, double sim_time) {
            
            for(int i = 0; i < agents_number; ++i) {

                if (average_performance_per_agent[i] <= previous_performance_per_agent[i]) {
                    
                    for(int j = 0; j < agents_number; ++j) {
                        if(i != j && clusters_per_wlan[i][j] == 1 && previously_banned_action_per_agent[j] >= 0) {
                            LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s Restored action %d of A%d\n",
                                 sim_time, LOG_C00, LOG_LVL1, previously_banned_action_per_agent[j], j);
                            list_of_available_actions_per_agent[j][previously_banned_action_per_agent[j]] = 1;
                            configuration_array[j].agent_capabilities.available_actions[previously_banned_action_per_agent[j]] = 1;
                            
                            ResetBanningThreshold(i);
                        }
                    }
                }
                
                previously_banned_action_per_agent[i] = -1;
            }
		}

		



		int AssessActionNegativeImpact(int agent_id) {

		    
		    int total_num_arms_played(0);
		    for (int i = 0; i < num_arms_per_agent[agent_id]; ++i) {
                total_num_arms_played += times_action_played_per_agent[agent_id][i];
		    }

			
			double POPULARITY_PERCENTAGE(0.33);
			int min_num_times_action_is_played = (POPULARITY_PERCENTAGE * total_num_arms_played);

			
			int sum_available_actions(0);
			for (int i = 0; i < num_arms_per_agent[agent_id]; ++i) {
				if (list_of_available_actions_per_agent[agent_id] >= 0)
					sum_available_actions += list_of_available_actions_per_agent[agent_id][i];
			}
			
            int  times_played_most_popular_action = times_action_played_per_agent[agent_id][most_played_action_per_agent[agent_id]];
			if (sum_available_actions > 1 && times_played_most_popular_action >= min_num_times_action_is_played) {
				banned_in_last_iteration = TRUE;
				return TRUE;

			} else {
				banned_in_last_iteration = FALSE;
				return FALSE;
			}

		}

		



		void UpdateVariables(ControllerReport controller_report) {

			
			num_arms_per_agent = controller_report.num_arms_per_agent;
			list_of_available_actions_per_agent = controller_report.list_of_available_actions_per_agent;
			most_played_action_per_agent = controller_report.most_played_action_per_agent;
			times_action_played_per_agent = controller_report.times_action_played_per_agent;

			
			configuration_array = controller_report.last_configuration_array;
			average_performance_per_agent = controller_report.average_performance_per_agent;

            
            int change_in_cluster_detected(FALSE);
            for (int i = 0; i < agents_number; ++i) {
            	if (average_performance_per_agent[i] > max_reward_seen_per_agent[i]) {
            		max_reward_seen_per_agent[i] = average_performance_per_agent[i];
            	}

                for (int j = 0; j < agents_number; ++j) {
                    if (clusters_per_wlan[i][j] != controller_report.clusters_per_wlan[i][j]) {
                        change_in_cluster_detected = TRUE;
                        break;
                    }
                }
            }

            
			clusters_per_wlan = controller_report.clusters_per_wlan;
			cluster_performance = controller_report.cluster_performance;

			
			if (change_in_cluster_detected) {
                
                ComputeBanningThreshold();
			}

		}

		
		
		
		
		

        



        void ComputeBanningThreshold() {
            for(int i = 0; i < agents_number; ++i) {
                int agents_in_cluster(0);
                for(int j = 0; j < agents_number; ++j) {
                    if(clusters_per_wlan[i][j] == 1) {
                        agents_in_cluster += 1;
                    }
                }
                initial_banning_threshold[i] = (1.0 / agents_in_cluster);
                current_banning_threshold[i] = initial_banning_threshold[i];
            }
        }

        



        void ResetBanningThreshold(int agent_id) {
        	current_banning_threshold[agent_id] = MIN_THRESHOLD_BANNING;
            banning_iteration = 1;
        }

        






        void UpdateBanningThreshold(ControllerReport controller_report,
			Logger central_controller_logger, double sim_time) {

            
			if(controller_report.cc_iteration > 0) {
				for(int i = 0; i < agents_number; ++i) {
					
					for(int j = 0; j < agents_number; ++j) {
						if(i != j && clusters_per_wlan[i][j] == 1) {
							double threshold_shift (ComputeBanningShift());
							if(average_performance_per_agent[j] > current_banning_threshold[i])
								current_banning_threshold[i] += threshold_shift;
							else if(max_reward_seen_per_agent[j] < current_banning_threshold[i])
								current_banning_threshold[i] -= threshold_shift;
							
							if (current_banning_threshold[i] > MAX_THRESHOLD_BANNING) {
								current_banning_threshold[i] = MAX_THRESHOLD_BANNING;
							}
							if (current_banning_threshold[i] < MIN_THRESHOLD_BANNING)
								current_banning_threshold[i] = MIN_THRESHOLD_BANNING;
						}
						LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s Updating the banning threshold of Agent %d (mode %d)... \n",
							 sim_time, LOG_C00, LOG_LVL1, i, banning_threshold_type);
						LOGS(save_logs, central_controller_logger.file, "%.15f;CC;%s;%s New threshold = %f\n",
							 sim_time, LOG_C00, LOG_LVL2, current_banning_threshold[i]);
					}
				}
			}

        }

        


        double ComputeBanningShift() {
        	double threshold_shift(0);
        	switch(banning_threshold_type) {
				case BANNING_THRESHOLD_STATIC : {
					
					break;
				}
				case BANNING_THRESHOLD_LINEAR : {
					threshold_shift = 0.05;
					break;
				}
				case BANNING_THRESHOLD_LOGARITHMIC : {
					threshold_shift = 1/(10*sqrt(banning_iteration));
					break;
				}
			}
        	return threshold_shift;
        }

		
		
		
		
		

        




        void PrintOrWriteStatistics(int write_or_print, Logger &logger) {
            
            switch(write_or_print){
                
                case PRINT_LOG:{
                    printf("%s Centralized action-banning statistics...\n", LOG_LVL1);
                    printf("%s Available actions (%d agents):\n", LOG_LVL2, agents_number);
                    for (int i = 0; i < agents_number; ++i) {
                        for (int j = 0; j < num_arms_per_agent[i]; ++j) {
                            printf("%d ", list_of_available_actions_per_agent[i][j]);
                        }
                        printf("\n");
                    }
                    break;
                }
                
                case WRITE_LOG:{
                    fprintf(logger.file, "%s Centralized action-banning statistics...\n", LOG_LVL1);
                    fprintf(logger.file, "%s Available actions (%d agents):\n", LOG_LVL2, agents_number);
                    for (int i = 0; i < agents_number; ++i) {
                        for (int j = 0; j < num_arms_per_agent[i]; ++j) {
                            fprintf(logger.file, "%d ", list_of_available_actions_per_agent[i][j]);
                        }
                        fprintf(logger.file, "\n");
                    }
                    break;
                }
            }
        }

		
		
		
		
		

		


		void InitializeVariables(){

		    
            initial_banning_threshold = new double[agents_number];
            current_banning_threshold = new double[agents_number];
            MAX_THRESHOLD_BANNING = 0.9;                        
            MIN_THRESHOLD_BANNING = 0.1;						
            MARGIN_THRESHOLD_BANNING = 0.1;                     
            banning_threshold_type = BANNING_THRESHOLD_LOGARITHMIC;  
            banning_iteration = 1;

            banned_in_last_iteration = FALSE;

            
            previous_performance_per_agent = new double[agents_number];
            previously_banned_action_per_agent = new int[agents_number];
            DELTA = 0.1;

            max_reward_seen_per_agent = new double[agents_number];

            
			list_of_available_actions_per_agent = new int *[agents_number];
			num_arms_per_agent = new int[agents_number];
			average_performance_per_agent = new double[agents_number];
			cluster_performance = new double[agents_number];
			clusters_per_wlan = new int *[agents_number];
			most_played_action_per_agent = new int[agents_number];
			times_action_played_per_agent = new int *[agents_number];
			configuration_array = new Configuration[agents_number];

			for(int i = 0; i < agents_number; ++i){
                initial_banning_threshold[i] = 0;
                current_banning_threshold[i] = 0;
				list_of_available_actions_per_agent[i] = new int[max_number_of_actions];	
				num_arms_per_agent[i] = 0;
				average_performance_per_agent[i] = 0;
                previous_performance_per_agent[i] = 0;
                previously_banned_action_per_agent[i] = -1;
				cluster_performance[i] = 0;
				clusters_per_wlan[i] = new int[agents_number];
				most_played_action_per_agent[i] = 0;
				times_action_played_per_agent[i] = new int[max_number_of_actions];
				max_reward_seen_per_agent[i] = 0;
			}

		}

};

#endif

#line 59 "../learning_modules/ml_model.h"


#line 1 "../learning_modules//network_optimization_methods/multi_armed_bandits.h"













































 






#line 1 "../learning_modules//network_optimization_methods/../../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 52 "../learning_modules//network_optimization_methods/multi_armed_bandits.h"


#ifndef _AUX_MABS_
#define _AUX_MABS_

class MultiArmedBandit {

	
	public:

        
        int save_logs;				
        int print_logs;				

        
		int agent_id;						
		int num_arms;					
		int action_selection_strategy;		

		
		int initial_reward;		
		int num_iterations;		

		
		double *reward_per_arm;					
		double *cumulative_reward_per_arm;		
		double *average_reward_per_arm;			
		double *estimated_reward_per_arm;		
		int *times_arm_has_been_selected;		

		
		double initial_epsilon;		
		double epsilon;				

	
	public:

		
		
		
		
		

		




		void UpdateArmStatistics(int action_ix, double reward){

			if(action_ix >= 0) { 
				
				reward_per_arm[action_ix] = reward;
				
				times_arm_has_been_selected[action_ix] += 1;
				
				cumulative_reward_per_arm[action_ix] += reward;
				
				average_reward_per_arm[action_ix] = cumulative_reward_per_arm[action_ix] /
					times_arm_has_been_selected[action_ix];
				
				estimated_reward_per_arm[action_ix] = ((estimated_reward_per_arm[action_ix]
					* times_arm_has_been_selected[action_ix])
					+ reward) / (times_arm_has_been_selected[action_ix] + 2);
			} else {
				printf("[MAB] ERROR: The action ix (%d) is not correct!\n", action_ix);
				exit(EXIT_FAILURE);
			}
		}

		



		int SelectNewAction(int *available_arms, int current_arm) {
			int arm_ix;
			
			
			switch(action_selection_strategy) {
				


				case STRATEGY_EGREEDY:{
					
					epsilon = initial_epsilon / sqrt( (double) num_iterations);
					
                    arm_ix = PickArmEgreedy(num_arms, average_reward_per_arm, epsilon, available_arms);
					break;
				}
				


				case STRATEGY_THOMPSON_SAMPLING:{
					
                    arm_ix = PickArmThompsonSampling(num_arms,
						estimated_reward_per_arm, times_arm_has_been_selected, available_arms);
					break;
				}
                


                case STRATEGY_SEQUENTIAL:{
                    
                    arm_ix = PickArmSequentially(num_arms, available_arms, current_arm);
                    break;
                }
				default:{
					printf("[MAB] ERROR: '%d' is not a correct action-selection strategy!\n", action_selection_strategy);
					PrintAvailableActionSelectionStrategies();
					exit(EXIT_FAILURE);
				}
			}
            
            ++ num_iterations;
            
			return arm_ix;
		}

		
		
		
		
		

		






		int PickArmEgreedy(int num_arms, double *reward_per_arm, double epsilon, int *available_arms) {

			double rand_number = ((double) rand() / (RAND_MAX));
			int action_ix;

			if (rand_number < epsilon) { 
				action_ix = rand() % num_arms;
				int counter(0);
				while (!available_arms[action_ix]) {
					action_ix = rand() % num_arms;
					if(counter > 1000) break; 
				}

			} else { 
				double max = 0;
				for (int i = 0; i < num_arms; i ++) {
					if(available_arms[i] && reward_per_arm[i] >= max) {
						max = reward_per_arm[i];
						action_ix = i;
					}
				}

			}

			return action_ix;

		}

		
		
		
		
		

		double gaussrand(double mean, double std){
			static double V1, V2, S;
			static int phase = 0;
			double X;
			if(phase == 0) {
				do {
					double U1 = (double)rand() /  RAND_MAX;
					double U2 = (double)rand() /  RAND_MAX;
					V1 = 2*U1 - 1;
					V2 = 2*U2 - 1;
					S = V1 * V1 + V2 * V2;
				} while (S >= 1 || S == 0);
				X = (V1 * sqrt(-2 * log(S) / S)) * std + mean;
			} else {
				X = (V1 * sqrt(-2 * log(S) / S)) * std + mean;
			}
			phase = 1 - phase;
			return X;
		}

		






		int PickArmThompsonSampling(int num_arms, double *estimated_reward_per_arm,
			int *times_arm_has_been_selected, int *available_arms) {
			
			int action_ix;
			double *theta = new double[num_arms];
			double std;
			
			for (int i = 0; i < num_arms; ++i) {
				if (available_arms[i]) {
					std = 1.0/(1+times_arm_has_been_selected[i]);
					theta[i] = gaussrand(estimated_reward_per_arm[i], std);
				} else {
					theta[i] = -10000;
				}
			}
			
			double max = theta[0];
			for (int i = 0; i < num_arms; ++i) {
				if(theta[i] > max) {
					max = theta[i];
					action_ix = i;
				}
				
			}

			return action_ix;
		}

        
        
        
        
        


        






        int PickArmSequentially(int num_arms, int *available_arms, int current_arm_ix) {
            int arm_ix(1);
            if (num_iterations == 1) {
                arm_ix = num_iterations;
            } else {
                arm_ix = (current_arm_ix + 1) % num_arms;
            }
            if (available_arms[arm_ix] != 1) {
                arm_ix = PickArmSequentially(num_arms, available_arms, arm_ix);
            }
            return arm_ix;
        }

		
		
		
		
		

		





		void PrintOrWriteStatistics(int write_or_print, Logger &logger, double sim_time) {
			
			switch(write_or_print){
				
				case PRINT_LOG:{
					if(print_logs){
						printf("%s Reward per arm: ", LOG_LVL3);
						for(int n = 0; n < num_arms; n++){
							printf("%f  ", reward_per_arm[n]);
						}
						printf("\n%s Cumulative reward per arm: ", LOG_LVL3);
						for(int n = 0; n < num_arms; n++){
							printf("%f  ", cumulative_reward_per_arm[n]);
						}
						printf("\n%s Times each arm has been selected: ", LOG_LVL3);
						for(int n = 0; n < num_arms; n++){
							printf("%d  ", times_arm_has_been_selected[n]);
						}
						printf("\n");
					}
					break;
				}
				
				case WRITE_LOG:{
					if(save_logs) fprintf(logger.file, "%.15f;A%d;%s;%s Reward per arm: ",
						sim_time, agent_id, LOG_C00, LOG_LVL3);
					for(int n = 0; n < num_arms; n++){
						 if(save_logs){
							 fprintf(logger.file, "%f  ", reward_per_arm[n]);
						 }
					}
					if(save_logs) fprintf(logger.file, "\n%.15f;A%d;%s;%s Cumulative reward per arm: ",
						sim_time, agent_id, LOG_C00, LOG_LVL3);
					for(int n = 0; n < num_arms; n++){
						 if(save_logs){
							 fprintf(logger.file, "%f  ", cumulative_reward_per_arm[n]);
						 }
					}
					fprintf(logger.file, "\n%.15f;A%d;%s;%s Times each arm has been selected: ",
									sim_time, agent_id, LOG_C00, LOG_LVL3);
					for(int n = 0; n < num_arms; n++){
						if(save_logs){
							fprintf(logger.file, "%d ", times_arm_has_been_selected[n]);
						}
					}
					if(save_logs) fprintf(logger.file, "\n");
					break;
				}
			}
		}

		


		void PrintAvailableActionSelectionStrategies(){
			printf("%s Available types of action-selection strategies:\n", LOG_LVL2);
			printf("%s STRATEGY_EGREEDY (%d)\n", LOG_LVL3, STRATEGY_EGREEDY);
			printf("%s STRATEGY_THOMPSON_SAMPLING (%d)\n", LOG_LVL3, STRATEGY_THOMPSON_SAMPLING);
		}

		
		
		
		
		

		


		void InitializeVariables(){
			
			initial_epsilon = 1;
			epsilon = initial_epsilon;
			initial_reward = 0;
			num_iterations = 1;
			
			reward_per_arm = new double[num_arms];
			cumulative_reward_per_arm = new double[num_arms];
			average_reward_per_arm = new double[num_arms];
			estimated_reward_per_arm = new double[num_arms];
			
			times_arm_has_been_selected = new int[num_arms];
			for(int i = 0; i < num_arms; ++i){
				reward_per_arm[i] = initial_reward;	
				cumulative_reward_per_arm[i] = initial_reward;
				average_reward_per_arm[i] = initial_reward;
				estimated_reward_per_arm[i] = initial_reward;
				times_arm_has_been_selected[i] = 0;
			}
		}

};

#endif

#line 60 "../learning_modules/ml_model.h"


#line 1 "../learning_modules//network_optimization_methods/rtot_algorithm.h"













































 









#line 1 "../learning_modules//network_optimization_methods/../../list_of_macros.h"

















































#define MIN_VALUE_C_LANGUAGE		0.000001				///> Minimum float value printable for default by C++ language
#define MIN_DOUBLE_VALUE_KOMONDOR	0.000000000000001		///> Minimum value accepted by Komondor
#define MILLI_VALUE					0.001					///> Milli value (10^-3)
#define MICRO_VALUE					0.000001				///> Micro value (10^-6)
#define NANO_VALUE					0.000000001				///> Nano value (10^-9)
#define PICO_VALUE					0.000000000001			///> Pico value (10^-12)
#define FEMTO_VALUE					0.000000000000001		///> Femto value (10^-15)
#define ATTO_VALUE					0.000000000000000001	///> Atto value (10^-18)


#define FALSE 				0			///> Boolean: false
#define TRUE 				1			///> Boolean: true
#define INTEGER_SIZE		8			///> Size of an integer
#define CHAR_BUFFER_SIZE	1024		///> Size of system buffer


#define LOG_LVL1	""
#define LOG_LVL2	"  -"
#define LOG_LVL3	"    ·"
#define LOG_LVL4	"       +"
#define LOG_LVL5	"          *"


#define STATE_UNKNOWN	-1	///> Unknown state (e.g. at the beginning of the simulation)
#define STATE_SENSING	0	///> Sensing the channel and decreasing backoff counter when possible according PD requirements
#define STATE_TX_DATA	1	///> Transmitting. Transmission are finished after the transmission duration established.
#define STATE_RX_DATA	2	///> Receiving a packet from other node.
#define STATE_WAIT_ACK	3	///> Waiting ACK
#define STATE_TX_ACK	4	///> Transmitting ACK
#define STATE_RX_ACK	5	///> Receiving ACK
#define STATE_TX_RTS	6	///> Transmitting RTS
#define STATE_TX_CTS	7	///> Transmitting CTS
#define STATE_RX_RTS	8	///> Receiving RTS
#define STATE_RX_CTS	9	///> Receiving CTS
#define STATE_WAIT_CTS	10	///> Waiting CTS packet
#define STATE_WAIT_DATA	11	///> Waiting Data after CTS
#define STATE_NAV		12	///> Virtual Carrier Sense (process only RTS and CTS)
#define STATE_SLEEP		13	///> Virtual Carrier Sense (process only RTS and CTS)


#define NODE_TYPE_UNKWNOW	-1	///> Unknown (none) node type
#define NODE_TYPE_AP		0	///> Access Point
#define NODE_TYPE_STA		1	///> Station
#define NODE_TYPE_OTHER		2	///> Other kind of devices


#define PRINT_LOG				0	///> Print logs per console
#define WRITE_LOG				1	///> Write log in file
#define SAVE_LOG_NONE			0	///> Don't save logs
#define SAVE_LOG				1	///> Save logs
#define LOG_HEADER_NODE_SIZE	30	///> Node log header size


#define INFO_DETAIL_LEVEL_0		0
#define INFO_DETAIL_LEVEL_1		1
#define INFO_DETAIL_LEVEL_2		2
#define INFO_DETAIL_LEVEL_3		3


#define TX_INITIATED		0	///> Transmission is initiated ('inportSomeNodeStartTX()')
#define TX_FINISHED			1	///> Transmission is finished ('inportSomeNodeFinishTX()')
#define TX_NOT_POSSIBLE 	-1	///> Transmission is not possible
#define TX_DURATION_NONE	0 	///> No transmission duration for logical notifications


#define PACKET_NOT_LOST					-1	///> Packet is not lost
#define PACKET_LOST_DESTINATION_TX		0	///> Destination was already transmitting when the transmission was attempted
#define PACKET_LOST_LOW_SIGNAL			1	///> Signal strength is not enough (< PD) to be decoded
#define PACKET_LOST_INTERFERENCE		2	///> There are interference signals greater than PD (collision)
#define PACKET_LOST_PURE_COLLISION		3	///> Two nodes transmitting to same destination with signal strengths enough to be decoded
#define PACKET_LOST_LOW_SIGNAL_AND_RX	4	///> Destination already receiving and new signal strength was not enough to be decoded
#define PACKET_LOST_SINR_PROB			5	///> Packet lost due to SINR probability
#define PACKET_ACK_LOST					6	///> ACK lost
#define PACKET_LOST_RX_IN_NAV			7	///> Received a packet when being in NAV state
#define PACKET_LOST_BO_COLLISION		8	///> Collision by simultaneous backoff
#define PACKET_LOST_OUTSIDE_CH_RANGE	9	///> Packet was transmitted outside the primary channel of the receiver
#define PACKET_LOST_CAPTURE_EFFECT		10	///> A new transmission made that the CE was not longer accomplished
#define PACKET_IGNORED_SPATIAL_REUSE	11	///> The transmission was ignored due to the spatial reuse operation

#define NUM_PACKET_LOST_REASONS			12	///> Number of reasons whereby a packet can be lost


#define NODE_ID_NONE	-1
#define WLAN_ID_NONE	-1


#define NO_PACKET_ID				-1		///> Packet without ID
#define MAX_PACKET_ID				645210	///> Maybe some day it is needed :D
#define PACKET_TYPE_DATA			0		///> Data packet type
#define PACKET_TYPE_ACK				1		///> ACK packet type
#define PACKET_TYPE_MCS_REQUEST		2		///> MCS request type
#define PACKET_TYPE_MCS_RESPONSE 	3 		///> MCS response type
#define PACKET_TYPE_RTS				4		///> RTS type
#define PACKET_TYPE_CTS				5		///> CTS type


#define PD_NOT_EXCEEDED	0	///> PD is not exceeded (primary channel is free)
#define PD_EXCEEDED		1	///> PD is exceeded


#define PW_TO_DBM		0	///> Convert pW to dBm
#define DBM_TO_PW		1	///> Convert dBm to pW
#define MW_TO_DBM		2	///> Convert mW to dBm
#define DBM_TO_MW		3	///> Convert dBm to mW
#define W_TO_DBW		4	///> Convert W to dBW
#define DBW_TO_W		5	///> Convert dBW to W
#define LINEAR_TO_DB	6	///> Convert Linear to dB
#define DB_TO_LINEAR	7	///> Convert dB to Linear


#define FIRST_TRUE_IN_ARRAY 		0	///> Search first element '1' in an array
#define LAST_TRUE_IN_ARRAY			1	///> Search last element '1' in an array
#define NUM_OPTIONS_CHANNEL_LENGTH	4	///> Number of options of channel lengths (1, 2, 4, 8)


#define CHANNEL_OCCUPIED	0
#define CHANNEL_FREE		1


#define PROGRESS_BAR_DELTA		5	///> Amount of percentage between two progress bar indicators
#define PROGRESS_BAR_DISPLAY 	1	///> Activate progress bar


#define PAUSE_TIMER					0					///> Try to pause a timer (e.g. backoff)
#define RESUME_TIMER				1					///> Try to resume timer
#define MAX_NUM_RAND_TIME			1000				///> Max. number of time rand values
#define MAX_DIFFERENCE_SAME_TIME	MAX_NUM_RAND_TIME * PICO_VALUE	///> Max. difference for considering that two events occur at the same time
#define TIME_OUT_EXTRA_TIME			PICO_VALUE	///> TO is triggered when exceeded TIME_OUT_EXTRA_TIME







#define PATH_LOSS_LFS 				0		///> Free space - Calculator: https://www.pasternack.com/t-calculator-fspl.aspx
#define PATH_LOSS_OKUMURA_HATA 		1		///> Okumura-Hata model - Urban areas
#define PATH_LOSS_INDOOR 			2   	///> Indoor model (could suite an apartments building scenario)
#define PATH_LOSS_INDOOR_2 			3		///> Indoor model without variability
#define PATH_LOSS_SCENARIO_1_TGax	4		///> IEEE 802.11ax Scenario 1 (residential)
#define PATH_LOSS_SCENARIO_2_TGax	5		///> IEEE 802.11ax Scenario 2 (enterprise)
#define PATH_LOSS_SCENARIO_3_TGax	6		///> IEEE 802.11ax Scenario 3 (indoor BSS)
#define PATH_LOSS_SCENARIO_4_TGax	7		///> IEEE 802.11ax Scenario 4 (outdoor BSS)
#define PATH_LOSS_SCENARIO_4a_TGax	8		///> IEEE 802.11ax Scenario 4a (outdoor BSS + residential)
#define PATHLOSS_5GHZ_OFFICE_BUILDING	9	///> Office building indoor pathloss for 5 GHz
#define PATHLOSS_INROOM_LOSS_5250KHZ	10	///> In-room LoS for 5.25 GHz
#define PATHLOSS_ROOM_CORRIDOR_5250KHZ	11	///> Room-corridor for 5.25 GHz
#define PATHLOSS_TMB	12					///> 11ax for 5 GHz

#define PATH_LOSS_DISTANCE_BREAKPOINT_CHANNEL_B	5	///> Breakpoint distance for channel model B [m]


#define CB_ONLY_PRIMARY				0	///> Only Primary Channel used if FREE
#define CB_SCB						1	///> SCB: if all channels are FREE, transmit. If not, generate a new backoff.
#define CB_SCB_LOG2					2	///> Log2 SCB:  if all channels accepted by the log2 mapping are FREE, transmit. If not, generate a new backoff.
#define CB_ALWAYS_MAX				3	///> Always-max (DCB): TX in all the free channels contiguous to the primary channel
#define CB_ALWAYS_MAX_LOG2			4	///> Log2 Always-max (DCB): TX in the larger channel range allowed by the log2 mapping
#define CB_ALWAYS_MAX_LOG2_MCS		5	///> Log2 Always-max (DCB) with optimal MCS: picks the channel range + MCS providing max throughput
#define CB_PROB_UNIFORM_LOG2		6	///> Log2 probabilistic uniform: pick with same probabilty any available channel range

#define CHANNEL_AGGREGATION_CCA_SAME 0	///> Same CCA (e.g., -82 dBm) is applied to every 20-MHz channel
#define CHANNEL_AGGREGATION_CCA_11AX 1	///> Different CCA (i.e., -82, 79, -72...) is applied depending on primary and secondary

#define CCA_PRIMARY_20MHZ	-82			///> CCA for primary channel of width 20 MHz (in 40 MHz)
#define CCA_SECONDARY_20MHZ	-72			///> CCA for secondary channel of width 20 MHz (in 40 MHz)
#define CCA_PRIMARY_40MHZ	-79			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_SECONDARY_40MHZ	-72			///> CCA for primary channel of width 40 MHz (in 80 MHz)
#define CCA_PRIMARY_80MHZ	-76			///> CCA for primary channel of width 80 MHz (in 160 MHz)
#define CCA_SECONDARY_80MHZ	-69			///> CCA for primary channel of width 80 MHz (in 160 MHz)


#define ADJACENT_CHANNEL_NONE		0	///> No adjacent channel interference
#define ADJACENT_CHANNEL_BOUNDARY	1	///> (RECOMMENDED) Boundary adjacent channel interference: only boundary channels (left and right) used in the TX affect the rest of channels
#define ADJACENT_CHANNEL_EXTREME	2	///> Extreme adjacent channel interference: ALL channels used in the TX affect the rest of channels


#define TRAFFIC_FULL_BUFFER						0	///> Transmitters always have packets to transmit
#define TRAFFIC_POISSON							1	///> Traffic is generated randomly according to a Poisson distribution
#define TRAFFIC_DETERMINISTIC					2	///> Traffic is generated at fixed intervals
#define TRAFFIC_POISSON_BURST					3	///> Traffic is generated in bursts following a Poisson distribution
#define TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION	99	///> Transmitters always have the same packet pending to be transmitted


#define INCREASE_CW 1		///> Command to increase contention window
#define RESET_CW 2			///> Command to reset the contention window


#define CE_DEFAULT			0	///>
#define CE_IEEE_802_11		1	///>


#define PDF_DETERMINISTIC	0	///> Deterministic (same value as mean)
#define PDF_EXPONENTIAL		1	///> Exponential pdf


#define IEEE_NOT_SPECIFIED		0
#define IEEE_802_11_AX			1


#define BACKOFF_SLOTTED		0
#define BACKOFF_CONTINUOUS	1







#define SPEED_LIGHT			3*pow(10,8)	///> Speed of light [m/s]
#define NUM_CHANNELS_KOMONDOR	8   ///> Total number of frequency channels
#define CHANNEL_BW_MHZ			20	///> Bandwidth of a basic channel [MHz]
#define NOISE_LEVEL_DBM			-95	///> Noise level [dBm]
#define ANTENNA_RX_GAIN_DB 		0	///> Antenna receiption gain [dB]
#define ANTENNA_TX_GAIN_DB 		0	///> Antenna transmission gain [dB]


#define MODULATION_FORBIDDEN	-1
#define MODULATION_NONE			0
#define MODULATION_BPSK_1_2		1
#define MODULATION_QPSK_1_2		2
#define MODULATION_QPSK_3_4		3
#define MODULATION_16QAM_1_2	4
#define MODULATION_16QAM_3_4	5
#define MODULATION_64QAM_2_3	6
#define MODULATION_64QAM_3_4	7
#define MODULATION_64QAM_5_6	8
#define MODULATION_256QAM_3_4	9
#define MODULATION_256QAM_5_6	10
#define MODULATION_1024QAM_3_4	11
#define MODULATION_1024QAM_5_6	12


#define PACKET_BUFFER_SIZE		100		///> Size of the packets buffer








#define CST_DBM		-68

#define IEEE_AX_OFDM_SYMBOL_LEGACY			(4 * MICRO_VALUE)	///> Duration of an OFDM symbol in legacy mode
#define IEEE_AX_OFDM_SYMBOL_GI32_DURATION	(16 * MICRO_VALUE)	///> Duration of OFDM symbol (for guard interval 3.2) [s]
#define IEEE_AX_PHY_LEGACY_DURATION 		(20 * MICRO_VALUE)	///> Duration of legacy PHY header [s]
#define IEEE_AX_PHY_HE_SU_DURATION	 		(100 * MICRO_VALUE)	///> HE single-user preamble [s]





#define SLOT_TIME	0.000009					///> Slot time unit [s]
#define SIFS 		(16 * MICRO_VALUE)			///> SIFS value
#define DIFS		(SIFS + (2 * SLOT_TIME))	///> DIFS value
#define PIFS		(SIFS + SLOT_TIME)			///> PIFS value

#define IEEE_AX_SF_LENGTH				16					///> Service field length [bits]
#define IEEE_AX_MD_LENGTH				32					///> MPDU delimiter if packet aggregation is used [bits]

#define IEEE_AX_MH_LENGTH				320					///> MAC header including FCS [bits]
#define IEEE_AX_TB_LENGTH				18					///> Tail length [bits]
#define IEEE_AX_RTS_LENGTH				160					///> RTS length [bits]
#define IEEE_AX_CTS_LENGTH				112					///> CTS length [bits]
#define IEEE_AX_ACK_LENGTH				112					///> ACK length [bits]


#define IEEE_AX_BACK_LENGTH				432					///> Block-ACK length [bits]
#define IEEE_AX_SU_SPATIAL_STREAMS		1					///> Number of spatial streams
#define IEEE_AX_MAX_PPDU_DURATION		(5484 * MICRO_VALUE)///> Maximum PPDU duration (limits the A-MPDU operation)

#define MAC_HEADER						320 				///> Size of the MAC header (for data packets)

#define IEEE_BITS_OFDM_SYM_LEGACY 		24					///> Number of bits per symbol in the legacy OFDM operation





#define MIN_TX_POWER_DBM 		1
#define MAX_TX_POWER_DBM 		20
#define MIN_SENSITIVITY_DBM 	-82
#define MAX_SENSITIVITY_DBM 	-62





#define INTRA_BSS_FRAME		0		///> Frame type = Intra-BSS or legacy
#define NON_SRG_FRAME		1		///> Frame type = Inter-BSS with different SRG
#define SRG_FRAME			2		///> Frame type = Inter-BSS with same SRG
#define OBSS_PD_MIN			-82 	///> Minimum OBSS_PD (dBm)
#define OBSS_PD_MAX			-62 	///> Maximum OBSS_PD (dBm)
#define MAX_TX_PWR_SR		20		///> Maximum transmit power to be used during the SR operation (dBm)
#define TX_PWR_REF			21		///> TX PWR REF (dBm)






#define ORIGIN_AGENT	0		///> To determine the source of a received command/configuration (agent)
#define ORIGIN_AP		1		///> To determine the source of a received command/configuration (AP)
#define ORIGIN_CC		2		///> To determine the source of a received command/configuration (AP)

#define NUM_FEATURES_ACTIONS			4	///> Number of features considered (e.g., primary, PD, P_tx, Max bandwidth)


#define REWARD_TYPE_PACKETS_SUCCESSFUL	0	///> Packets sent
#define REWARD_TYPE_AVERAGE_THROUGHPUT 	1	///> Throughput
#define REWARD_TYPE_MIN_RSSI			2	///> Minimum RSSI received
#define REWARD_TYPE_MAX_DELAY			3	///> Maximum experienced delay
#define REWARD_TYPE_AVERAGE_DELAY		4	///> Average experienced delay
#define REWARD_TYPE_CHANNEL_OCCUPANCY 	5	///> Average channel occupancy ratio


#define AGENT_MODE_DECENTRALIZED 	0	///> Agents are independent entities that follow their own learning procedure
#define AGENT_MODE_COOPERATIVE		1	///> Agents combine local and distributed/centralized learning approaches
#define AGENT_MODE_CENTRALIZED		2	///> The learning operation is fully managed by a central controller


#define MONITORING_ONLY		 			0
#define MULTI_ARMED_BANDITS 			1
#define GRAPH_COLORING					2
#define ACTION_BANNING					3
#define RTOT_ALGORITHM					4
#define CENTRALIZED_ACTION_BANNING		5


#define BANNING_THRESHOLD_STATIC        0
#define BANNING_THRESHOLD_LINEAR        1
#define BANNING_THRESHOLD_LOGARITHMIC   2

#define INCREASE_THRESHOLD   0
#define DECREASE_THRESHOLD   1


#define STRATEGY_EGREEDY				1
#define STRATEGY_THOMPSON_SAMPLING		2
#define STRATEGY_SEQUENTIAL             3

#define MAX_TIME_INFORMATION_VALID		10 ///> Maximum amount of time (in seconds) the information of the network is considered to be valid


#define CONFIGURATION_SUGGESTED 		0
#define CONFIGURATION_RECOMMENDED 		1
#define CONFIGURATION_REQUIRED			2


#define CC_MODE_PASSIVE		0
#define CC_MODE_ACTIVE		1


#define SEND_CONFIGURATION_PERFORMANCE 	0
#define UPDATE_CONFIGURATION			1
#define STOP_ACTING						2
#define RESUME_ACTIVITY					3
#define MODIFY_ITERATION_TIME			4
#define BAN_CONFIGURATION				5
#define UNBAN_CONFIGURATION				6
#define COMMUNICATION_UPON_TRIGGER		7
#define COMMUNICATION_AUTOMATIC			8


#define CLUSTER_BY_CCA			0
#define CLUSTER_BY_DISTANCE		1


#define MAX_MIN_PERFORMANCE			0
#define PROP_FAIRNESS_PERFORMANCE	1
#define AVERAGE_PERFORMANCE			2







#define NUM_FULL_ARGUMENTS_CONSOLE				12		///> Number of arguments entered per console corresponding to full config
#define NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS	9		///> Number of arguments entered per console corresponding to full config (NO AGENTS)
#define NUM_PARTIAL_ARGUMENTS_CONSOLE			4		///> Number of arguments entered per console corresponding to partial config
#define NUM_PARTIAL_ARGUMENTS_SCRIPT			5		///> Number of arguments entered per script corresponding to partial config

#define IX_SYSTEM_INPUT_FILE		1
#define IX_NODES_INPUT_FILE			2
#define IX_SCRIPT_OUTPUT_FILENAME	3
#define IX_SIMULATION_CODE			4
#define IX_WRITE_SYSTEM_LOGS		5
#define IX_WRITE_NODE_LOGS			6
#define IX_PRINT_SYSTEM_LOGS		7
#define IX_PRINT_NODE_LOGS			8
#define IX_SIMULATION_TIME			9
#define IX_RANDOM_SEED				10

#define DEFAULT_SCRIPT_FILENAME		"./output/script_output.txt"
#define DEFAULT_SIMULATION_CODE		"DEFAULT_SIM"
#define DEFAULT_WRITE_SYSTEM_LOGS	0
#define DEFAULT_WRITE_NODE_LOGS		0
#define DEFAULT_PRINT_SYSTEM_LOGS	1
#define DEFAULT_PRINT_NODE_LOGS		1


#define FILE_TYPE_UNKNOWN		-1
#define FILE_TYPE_APS			0
#define FILE_TYPE_NODES			1
#define FILE_NAME_CODE_NODES	"nodes"


#define IX_NODE_CODE				1
#define IX_NODE_TYPE				2
#define IX_WLAN_CODE				3
#define IX_POSITION_X				4
#define IX_POSITION_Y				5
#define IX_POSITION_Z				6
#define IX_CENTRAL_FREQ				7
#define IX_CHANNEL_BONDING_MODEL	8
#define IX_PRIMARY_CHANNEL			9
#define IX_MIN_CH_ALLOWED			10
#define IX_MAX_CH_ALLOWED			11
#define IX_TX_POWER_DEFAULT			12
#define IX_PD_DEFAULT				13
#define IX_TRAFFIC_MODEL			14
#define IX_TRAFFIC_LOAD				15
#define IX_PACKET_LENGTH			16
#define IX_NUM_PACKETS_AGG			17
#define IX_CAPTURE_EFFECT_MODEL		18
#define IX_CAPTURE_EFFECT_THR		19
#define IX_CONSTANT_PER				20
#define IX_PIFS_ACTIVATED			21
#define IX_CW_ADAPTATION_FLAG		22
#define IX_CW_MIN					23
#define IX_CW_STAGE_MAX				24
#define IX_BSS_COLOR				25
#define IX_SRG						26
#define IX_NON_SRG_OBSS_PD			27
#define IX_SRG_OBSS_PD				28


#define IX_AGENT_WLAN_CODE				1
#define IX_COMMUNICATION_LEVEL			2
#define IX_AGENT_TIME_BW_REQUESTS		3
#define IX_AGENT_CHANNEL_VALUES			4
#define IX_AGENT_PD_VALUES				5
#define IX_AGENT_TX_POWER_VALUES		6
#define IX_AGENT_MAX_BANDWIDTH			7
#define IX_AGENT_TYPE_OF_REWARD			8
#define IX_AGENT_LEARNING_MECHANISM		9
#define IX_AGENT_SELECTED_STRATEGY 		10











#define LOG_B00 "B00" 	///> other option: #define LOG_B00 "B00: Start() starts"
#define LOG_B01 "B01"	///> Start() ends
#define LOG_B02 "B02"
#define LOG_B03 "B03"
#define LOG_B04 "B04"
#define LOG_B05 "B05"
#define LOG_B06 "B06"
#define LOG_B07 "B07"
#define LOG_B08 "B08"
#define LOG_B09 "B09"
#define LOG_B10 "B10"
#define LOG_B11 "B11"
#define LOG_B12 "B12"
#define LOG_B13 "B13"
#define LOG_B14 "B14"
#define LOG_B15 "B15"
#define LOG_B16 "B16"


#define LOG_C00 "C00"	///> Stop() starts
#define LOG_C01 "C01"	///> Stop() ends
#define LOG_C02 "C02"	///> Statistics: Time...
#define LOG_C03 "C03"
#define LOG_C04 "C04"
#define LOG_C05 "C05"
#define LOG_C06 "C06"
#define LOG_C07 "C07"
#define LOG_C08 "C08"
#define LOG_C09 "C09"
#define LOG_C10 "C10"
#define LOG_C11 "C11"
#define LOG_C12 "C12"
#define LOG_C13 "C13"
#define LOG_C14 "C14"
#define LOG_C15 "C15"
#define LOG_C16 "C16"


#define LOG_D00 "D00"
#define LOG_D01 "D01"
#define LOG_D02 "D02"
#define LOG_D03 "D03"
#define LOG_D04 "D04"
#define LOG_D05 "D05"
#define LOG_D06 "D06"
#define LOG_D07 "D07"
#define LOG_D08 "D08"
#define LOG_D09 "D09"
#define LOG_D10 "D10"
#define LOG_D11 "D11"
#define LOG_D12 "D12"
#define LOG_D13 "D13"
#define LOG_D14 "D14"
#define LOG_D15 "D15"
#define LOG_D16 "D16"
#define LOG_D17 "D17"
#define LOG_D18 "D18"
#define LOG_D19 "D19"
#define LOG_D20 "D20"
#define LOG_D21 "D21"
#define LOG_D22 "D22"


#define LOG_E00 "E00"
#define LOG_E01 "E01"
#define LOG_E02 "E02"
#define LOG_E03 "E03"
#define LOG_E04 "E04"
#define LOG_E05 "E05"
#define LOG_E06 "E06"
#define LOG_E07 "E07"
#define LOG_E08 "E08"
#define LOG_E09 "E09"
#define LOG_E10 "E10"
#define LOG_E11 "E11"
#define LOG_E12 "E12"
#define LOG_E13 "E13"
#define LOG_E14 "E14"
#define LOG_E15 "E15"
#define LOG_E16 "E16"
#define LOG_E17 "E17"
#define LOG_E18 "E18"
#define LOG_E19 "E19"
#define LOG_E20 "E20"
#define LOG_E21 "E21"
#define LOG_E22 "E22"
#define LOG_E23 "E23"


#define LOG_F00 "F00"
#define LOG_F01 "F01"
#define LOG_F02 "F02"
#define LOG_F03 "F03"
#define LOG_F04 "F04"
#define LOG_F05 "F05"
#define LOG_F06 "F06"
#define LOG_F07 "F07"
#define LOG_F08 "F08"
#define LOG_F09 "F09"
#define LOG_F10 "F10"
#define LOG_F11 "F11"
#define LOG_F12 "F12"
#define LOG_F13 "F13"
#define LOG_F14 "F14"
#define LOG_F15 "F15"
#define LOG_F16 "F16"


#define LOG_G00 "G00"
#define LOG_G01 "G01"
#define LOG_G02 "G02"
#define LOG_G03 "G03"
#define LOG_G04 "G04"
#define LOG_G05 "G05"
#define LOG_G06 "G06"
#define LOG_G07 "G07"
#define LOG_G08 "G08"
#define LOG_G09 "G09"
#define LOG_G10 "G10"
#define LOG_G11 "G11"
#define LOG_G12 "G12"
#define LOG_G13 "G13"
#define LOG_G14 "G14"
#define LOG_G15 "G15"
#define LOG_G16 "G16"


#define LOG_H00 "H00"
#define LOG_H01 "H01"
#define LOG_H02 "H02"
#define LOG_H03 "H03"
#define LOG_H04 "H04"
#define LOG_H05 "H05"
#define LOG_H06 "H06"
#define LOG_H07 "H07"
#define LOG_H08 "H08"
#define LOG_H09 "H09"
#define LOG_H10 "H10"
#define LOG_H11 "H11"
#define LOG_H12 "H12"
#define LOG_H13 "H13"
#define LOG_H14 "H14"
#define LOG_H15 "H15"
#define LOG_H16 "H16"

#define LOG_I00 "I00"
#define LOG_I01 "I01"
#define LOG_I02 "I02"
#define LOG_I03 "I03"
#define LOG_I04 "I04"
#define LOG_I05 "I05"
#define LOG_I06 "I06"
#define LOG_I07 "I07"
#define LOG_I08 "I08"
#define LOG_I09 "I09"
#define LOG_I10 "I10"
#define LOG_I11 "I11"
#define LOG_I12 "I12"
#define LOG_I13 "I13"
#define LOG_I14 "I14"
#define LOG_I15 "I15"
#define LOG_I16 "I16"


#define LOG_Z00 "Z00"	// Node info
#define LOG_Z01 "Z01"
#define LOG_Z02 "Z02"
#define LOG_Z03 "Z03"
#define LOG_Z04 "Z04"
#define LOG_Z05 "Z05"
#define LOG_Z06 "Z06"
#define LOG_Z07 "Z07"
#define LOG_Z08 "Z08"
#define LOG_Z09 "Z09"
#define LOG_Z10 "Z10"
#define LOG_Z11 "Z11"
#define LOG_Z12 "Z12"
#define LOG_Z13 "Z13"
#define LOG_Z14 "Z14"
#define LOG_Z15 "Z15"
#define LOG_Z16 "Z16"

#line 55 "../learning_modules//network_optimization_methods/rtot_algorithm.h"


#ifndef _AUX_RTOT_ALG_
#define _AUX_RTOT_ALG_

class RtotAlgorithm {

	
	public:

		int num_stas;				
		double *rssi_per_sta;		
		double *obss_pd_per_sta;	

		double margin_rtot;			

	
	private:

	
	public:

		
		
		
		
		

		



		double UpdateObssPd(double rssi) {
			return ComputeObssPdRtotAlgorithm(rssi, margin_rtot);
		}

		



		double ComputeObssPdRtotAlgorithm(double rssi, double margin_rtot) {

			
			double obss_pd_dbm(0);
			obss_pd_dbm = floor(ConvertPower(PW_TO_DBM, rssi) - ConvertPower(PW_TO_DBM, margin_rtot));
			if (obss_pd_dbm > OBSS_PD_MAX) obss_pd_dbm = OBSS_PD_MAX;
			else if (obss_pd_dbm < OBSS_PD_MIN) obss_pd_dbm = OBSS_PD_MIN;

			printf("[RTOT] New OBSS/PD computed = %f dBm\n", floor(obss_pd_dbm));

			return ConvertPower(DBM_TO_PW, obss_pd_dbm);

		}

		
		
		
		
		

		


		void InitializeVariables(){
			rssi_per_sta = new double[num_stas];
			obss_pd_per_sta = new double[num_stas];
			for (int i = 0 ; i < num_stas ; ++ i) {
				rssi_per_sta[i] = 0;
				obss_pd_per_sta[i] = 0;
			}
		}

		




		void PrintOrWriteInformation(int write_or_print, Logger &logger) {
			
			switch(write_or_print){
				
				case PRINT_LOG:{
					printf("%s RTOT algorithm information...\n", LOG_LVL1);
					printf("%s num_stas = %d\n", LOG_LVL2, num_stas);
					printf("%s margin_rtot = %f\n", LOG_LVL2, ConvertPower(PW_TO_DBM, margin_rtot));
					break;
				}
				
				case WRITE_LOG:{
					fprintf(logger.file, "RTOT algorithm statistics...\n");
					break;
				}
			}
		}

		




		void PrintOrWriteStatistics(int write_or_print, Logger &logger) {
			
			switch(write_or_print){
				
				case PRINT_LOG:{
					printf("%s RTOT algorithm statistics...\n", LOG_LVL1);
					printf("%s rssi_per_sta: ", LOG_LVL2);
					for (int i = 0 ; i < num_stas; ++i) {
						printf("%f dBm ", ConvertPower(PW_TO_DBM, rssi_per_sta[i]));
					}
					printf("\n");
					printf("%s obss_pd_per_sta: ", LOG_LVL2);
					for (int i = 0 ; i < num_stas; ++i) {
						printf("%f dBm ", ConvertPower(PW_TO_DBM, obss_pd_per_sta[i]));
					}
					printf("\n");
					break;
				}
				
				case WRITE_LOG:{
					fprintf(logger.file, "RTOT algorithm statistics...\n");
					break;
				}
			}
		}


};

#endif

#line 61 "../learning_modules/ml_model.h"


#ifndef _AUX_ML_MODEL_
#define _AUX_ML_MODEL_

class MlModel {

	
	public:

		
		int agent_id;					
		int learning_mechanism;			
		int action_selection_strategy;	

		
		int save_logs;		
		int print_logs;		

		
		int agents_number;				
		int wlans_number;				
		int total_nodes_number;			
		int num_channels;				

		
		int num_arms;				
		int max_number_of_actions;		
		int num_stas;					
		double margin_rtot;				

	
	private:

		
		MultiArmedBandit mab_agent;				
		RtotAlgorithm rtot_alg;					
		CentralizedActionBanning action_banner;	

	
	public:

		
		
		
		
		

		





		void ComputeGlobalConfiguration(Configuration *configuration_array, ControllerReport &controller_report,
			Logger &central_controller_logger, double sim_time) {

			switch(learning_mechanism) {
				
				case CENTRALIZED_ACTION_BANNING: {
					
					action_banner.UpdateConfiguration(configuration_array, controller_report, central_controller_logger, sim_time);

					break;
				}
				default: {
					printf("[ML MODEL] ERROR, UNKOWN LEARNING MECHANISM ('%d')\n", learning_mechanism);
					exit(-1);
				}
			}

		}

		
		
		
		
		

		







		int ComputeIndividualConfiguration(int arm_ix, double reward,
			Logger &agent_logger, double sim_time, int *available_arms) {

			int new_action(0);
			switch(learning_mechanism) {
				
				case MULTI_ARMED_BANDITS: {
					
					mab_agent.UpdateArmStatistics(arm_ix, reward);
					
					new_action = mab_agent.SelectNewAction(available_arms, arm_ix);
					break;
				}
				case RTOT_ALGORITHM: {
					new_action = rtot_alg.UpdateObssPd(reward);
					break;
				}
				case CENTRALIZED_ACTION_BANNING: {
					printf("[ML MODEL] ERROR, Action-Banning is not a decentralized ML method. Use 'CentralizedActionBanning()' instead.\n");
					break;
				}
				default: {
					printf("[ML MODEL] ERROR, UNKOWN LEARNING MECHANISM ('%d')\n", learning_mechanism);
					exit(-1);
				}
			}
			return new_action;
		};

		
		
		
		
		

		


		void InitializeVariables() {

			switch(learning_mechanism) {
				
				case MONITORING_ONLY:{
					
					break;
				}
				
				case CENTRALIZED_ACTION_BANNING: {
					action_banner.save_logs = save_logs;
					action_banner.print_logs = print_logs;
					action_banner.agents_number = agents_number;
					action_banner.max_number_of_actions = max_number_of_actions;
					action_banner.InitializeVariables();
					break;
				}
				
				case MULTI_ARMED_BANDITS: {
					mab_agent.agent_id = agent_id;
					mab_agent.save_logs = save_logs;
					mab_agent.print_logs = print_logs;
					mab_agent.action_selection_strategy = action_selection_strategy;
					mab_agent.num_arms = num_arms;
					mab_agent.InitializeVariables();
					break;
				}
				
				case RTOT_ALGORITHM: {
					rtot_alg.num_stas = num_stas;
					rtot_alg.margin_rtot = margin_rtot;
					rtot_alg.InitializeVariables();
					break;
				}
				
				
				

				
				default: {
					printf("[ML MODEL] ERROR: '%d' is not a correct learning mechanism\n", learning_mechanism);
					PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}
		}

		
		
		
		
		

		





		void PrintOrWriteStatistics(int write_or_print, Logger &logger, double sim_time) {

			switch(learning_mechanism) {
				
				case MONITORING_ONLY:{
					
					break;
				}
				
				case MULTI_ARMED_BANDITS: {
					mab_agent.PrintOrWriteStatistics(write_or_print, logger, sim_time);
					break;
				}
				case RTOT_ALGORITHM: {
					rtot_alg.PrintOrWriteStatistics(write_or_print, logger);
					break;
				}
				case CENTRALIZED_ACTION_BANNING: {
                    action_banner.PrintOrWriteStatistics(write_or_print, logger);
					break;
				}
				
				default: {
					printf("[ML MODEL] ERROR: '%d' is not a correct learning mechanism\n", learning_mechanism);
					PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}

		}

		


		void PrintAvailableLearningMechanisms(){
			printf("%s Available types of learning mechanisms:\n", LOG_LVL2);
			printf("%s MULTI_ARMED_BANDITS (#%d)\n", LOG_LVL3, MULTI_ARMED_BANDITS);
			printf("%s ACTION_BANNING (#%d)\n", LOG_LVL3, ACTION_BANNING);
			printf("%s RTOT_ALGORITHM (#%d)\n", LOG_LVL3, RTOT_ALGORITHM);
		}

};

#endif

#line 72 "central_controller.h"




#line 199 "central_controller.h"
;





#line 233 "central_controller.h"
;





#line 250 "central_controller.h"
;











#line 326 "central_controller.h"
;







#line 418 "central_controller.h"
;








#line 474 "central_controller.h"
;











#line 515 "central_controller.h"
;














#line 77 "komondor_main.cc"


int total_nodes_number;			
char* tmp_nodes;



#line 363 "komondor_main.cc"
;





#line 370 "komondor_main.cc"
;





#line 397 "komondor_main.cc"
;





#line 1211 "komondor_main.cc"
const char* GetField(char* line, int num){
    const char* tok;
    for (tok = strtok(line, ";");
            tok && *tok;
            tok = strtok(NULL, ";\n"))
    {
        if (!--num)
            return tok;
    }
    return NULL;
}






#include "compcxx_komondor_main.h"
class compcxx_Agent_25;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_20 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_20() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Agent_25* p_compcxx_parent;};


#line 71 "agent.h"
class compcxx_Agent_25 : public compcxx_component, public TypeII{

	
	public:

		
		void Setup();
		void Start();
		void Stop();

		
		void InitializeAgent();
        void InitializeMlPipeline();
		void InitializePreProcessor();
		void InitializeMlModel();

		
		void RequestInformationToAp();
		void ComputeNewConfiguration();
		void SendNewConfigurationToAp(Configuration &configuration_to_send);

		
		void ForwardInformationToController();
		void UpdateConfigurationStatisticsController(int selected_conf_ix);
		void ResetControllerStatistics();

		
		

		
		void UpdateAction(int action_ix);

		
		void PrintAgentInfo();
		void WriteAgentInfo(Logger logger, std::string header_str);
		void PrintOrWriteAgentStatistics();

	
	public:

		
		int agent_id; 				
		int agent_centralized;		
		std::string wlan_code;		
		int wlan_id;                
		int num_stas;				

		
		int learning_mechanism;			
		int action_selection_strategy;	

		
		int controller_on;				

		
		int *list_of_channels; 				
		double *list_of_pd_values;			
		double *list_of_tx_power_values;	
		int *list_of_max_bandwidth;			

		Action *actions;					
		int *list_of_available_actions;		
		int num_arms;					
		int num_arms_channel;			
		int num_arms_sensitivity;		
		int num_arms_tx_power;			
		int num_arms_max_bandwidth;			

		
		int type_of_reward;					
		int type_of_reward_cc;              
		double time_between_requests; 		

		
		int save_agent_logs;			
		int print_agent_logs;			
		std::string simulation_code;	

		
		double margin_rtot;      

	
	private:

        
        FILE *output_log_file;				
        char own_file_path[32];				
        Logger agent_logger;				
        char *header_string;				

        
        Performance performance;						
        int *indexes_configuration;                     
        Configuration configuration;					
        Configuration new_configuration;				
        Configuration configuration_from_controller;	
        int ml_output;	                            

        
        PreProcessor pre_processor;             
        MlModel ml_model;                       
        int learning_allowed;                   
        int flag_compute_new_configuration; 	

		
		int processed_configuration;	
		double processed_reward;		
		double processed_reward_cc;     

		
        int automatic_forward_enabled;          
		int flag_request_from_controller;		
		int flag_information_available;			

		
        int num_requests;			
        double initial_reward;		

	
	public:

		
		/*inport */void inline InportReceivingInformationFromAp(Configuration &configuration, Performance &performance);
		
		class my_Agent_outportRequestInformationToAp_f_t:public compcxx_functor<Agent_outportRequestInformationToAp_f_t>{ public:void  operator() () { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(); return (c[0]->*f[0])();};};my_Agent_outportRequestInformationToAp_f_t outportRequestInformationToAp_f;/*outport void outportRequestInformationToAp()*/;
		class my_Agent_outportSendConfigurationToAp_f_t:public compcxx_functor<Agent_outportSendConfigurationToAp_f_t>{ public:void  operator() (Configuration &new_configuration) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(new_configuration); return (c[0]->*f[0])(new_configuration);};};my_Agent_outportSendConfigurationToAp_f_t outportSendConfigurationToAp_f;/*outport void outportSendConfigurationToAp(Configuration &new_configuration)*/;
		
        /*inport */void inline InportReceiveCommandFromController(int destination_agent_id,
            int command_id, Configuration &new_configuration, int type_of_reward);
		class my_Agent_outportAnswerToController_f_t:public compcxx_functor<Agent_outportAnswerToController_f_t>{ public:void  operator() (int agent_id, Configuration &configuration, Performance &performance, Action *actions) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(agent_id,configuration,performance,actions); return (c[0]->*f[0])(agent_id,configuration,performance,actions);};};my_Agent_outportAnswerToController_f_t outportAnswerToController_f;/*outport void outportAnswerToController(int agent_id, Configuration &configuration, Performance &performance, Action *actions)*/;
		
		compcxx_Timer_20 /*<trigger_t> */trigger_request_information_to_ap;        
		/*inport */inline void RequestInformationToAp(trigger_t& t1);   
		compcxx_Agent_25 () { 
			trigger_request_information_to_ap.p_compcxx_parent=this /*connect trigger_request_information_to_ap.to_component,*/;
		}

};




class compcxx_CentralController_26;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_21 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_21() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_CentralController_26* p_compcxx_parent;};

class compcxx_CentralController_26;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_22 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_22() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_CentralController_26* p_compcxx_parent;};


#line 75 "central_controller.h"
class compcxx_CentralController_26 : public compcxx_component, public TypeII{

	
	public:

		
		void Setup();
		void Start();
		void Stop();

		
		void InitializeCentralController();
        void StartCcActivity();

		
		void RequestInformationToAgents();
		void SendCommandToAllAgents(int command_id, Configuration *conf_array);
		void SendConfigurationToSingleAgent(int destination_agent_id, Configuration conf);
		void SendCommandToSingleAgent(int destination_agent_id, int command_id, Configuration conf);

		
		void ApplyMlMethod();

		
		void GenerateClusters(int wlan_id, Performance performance, Configuration configuration);
		void PrintOrWriteClusters(int print_or_write);
		void UpdatePerformancePerCluster(int shared_performance_metric);

		
		void UpdateControllerReport(int agent_id, Action *actions);

		
		void PrintControllerInfo();
		void WriteControllerInfo(Logger logger);
		void PrintOrWriteControllerStatistics(int print_or_write);
        void WriteAgentPerformance(Action *actions, int agent_id);

		
		void InitializeMlPipeline();
        void InitializePreProcessor();
		void InitializeMlModel();

	
	public:

		
		int controller_on;				
		int controller_mode; 			
		double time_between_requests;	
        double *agent_iteration_time;   

        
		int agents_number;				
		int *list_of_agents;			
		int wlans_number;				
		int total_nodes_number;			
		int *num_arms_per_agent;		
		int max_number_of_actions;		

		
		int type_of_reward;				
		int learning_mechanism;			
		int action_selection_strategy;	

		
		int save_controller_logs;		
		int print_controller_logs;		

	
	private:

		
		FILE *output_log_file;				
		char own_file_path[32];				
		Logger central_controller_logger;	
		char *header_string;				

		
		ControllerReport controller_report;

		
		Configuration *configuration_array;	
		Performance *performance_array;		

		
		MlModel ml_model;					
		PreProcessor pre_processor;			

		
		int cc_iteration; 					
		int counter_responses_received; 	

	
	public:

		
		/*inport */void inline InportReceivingInformationFromAgent(int agent_id, Configuration &configuration,
			Performance &performance, Action *actions);

		
		class my_CentralController_outportSendCommandToAgent_f_t:public compcxx_functor<CentralController_outportSendCommandToAgent_f_t>{ public:void  operator() (int destination_agent_id, int command_id,
			Configuration &new_configuration, int type_of_reward) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(destination_agent_id,command_id,new_configuration,type_of_reward); return (c[0]->*f[0])(destination_agent_id,command_id,new_configuration,type_of_reward);};};my_CentralController_outportSendCommandToAgent_f_t outportSendCommandToAgent_f;/*outport void outportSendCommandToAgent(int destination_agent_id, int command_id,
			Configuration &new_configuration, int type_of_reward)*/;

		
		compcxx_Timer_21 /*<trigger_t> */trigger_apply_ml_method;					
		compcxx_Timer_22 /*<trigger_t> */trigger_request_information_to_agents;	

		
		/*inport */inline void ApplyMlMethod(trigger_t& t1);
		/*inport */inline void RequestInformationToAgents(trigger_t& t1);

		
		compcxx_CentralController_26 () {
			trigger_apply_ml_method.p_compcxx_parent=this /*connect trigger_apply_ml_method.to_component,*/;
			trigger_request_information_to_agents.p_compcxx_parent=this /*connect trigger_request_information_to_agents.to_component,*/;
		}

};




class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_7 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_7() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_8 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_8() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_9 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_9() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_10 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_10() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_6 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_6() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_3 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_3() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_11 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_11() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_12 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_12() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_16 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_16() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_13 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_13() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_17 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_17() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_2 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_2() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_4 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_4() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_15 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_15() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_5 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_5() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_14 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_14() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};

class compcxx_Node_23;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_18 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_18() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_Node_23* p_compcxx_parent;};


#line 82 "node.h"
class compcxx_Node_23 : public compcxx_component, public TypeII{

	
	public:

		
		void Setup();
		void Start();
		void Stop();

		
		void InitializeVariables();
		void RestartNode(int called_by_time_out);
		void CallRestartSta();
		void CallSensing();
		void PrintNodeInfo(int info_detail_level);
		void PrintNodeConfiguration();
		void WriteNodeInfo(Logger node_logger, int info_detail_level, std::string header_str);
		void WriteNodeConfiguration(Logger node_logger, std::string header_str);
		void WriteReceivedConfiguration(Logger node_logger, std::string header_str, Configuration new_configuration);
		void PrintOrWriteNodeStatistics(int write_or_print);
		void HandleSlottedBackoffCollision();
		void StartSavingLogs();
		void RecoverFromCtsTimeout();
		void MeasureRho();
		void SaveSimulationPerformance();

		
		Notification GenerateNotification(int packet_type, int destination_id,
			int packet_id, int num_packets_aggregated, double timestamp_generated, double tx_duration);
		void SelectDestination();
		void SendResponsePacket();
		void AckTimeout();
		void CtsTimeout();
		void DataTimeout();
		void NavTimeout();
		void RequestMCS();
		void StartTransmission();
		void AbortRtsTransmission();


		void SendLogicalNack(LogicalNack logical_nack);

		
		void PauseBackoff();
		void ResumeBackoff();

		
		void GenerateConfiguration();
		void ApplyNewConfiguration(Configuration &received_configuration);
		void BroadcastNewConfigurationToStas(Configuration &received_configuration);
		void UpdatePerformanceMeasurements();

		
		void SpatialReuseOpportunityEnds();

	
	public:

		
		int node_id; 					
		double x;						
		double y;						
		double z;						
		std::string node_code;			
		int node_type;					
		int current_primary_channel;	
		int min_channel_allowed;		
		int max_channel_allowed;		
		int num_channels_allowed;		
		double tx_power_default;		
		double sensitivity_default;		
		int current_dcb_policy;			
										
		int current_max_bandwidth;		
		FIFO buffer;					
		int last_packet_generated_id;	

		
		int bss_color;			
		int srg;				
		double non_srg_obss_pd; 
		double srg_obss_pd; 	

		
		std::string wlan_code;		
		Wlan wlan;					

		
		
		double simulation_time_komondor;	
		int total_wlans_number;				
		int total_nodes_number;				
		int collisions_model;				
		double capture_effect;				
		double constant_per;				
		int save_node_logs;					
		int print_node_logs;				
		std::string simulation_code;		
		int capture_effect_model;			
		int nack_activated;					

		
		int adjacent_channel_model;			
		int pifs_activated;					

		
		int current_modulation;				
		int channel_max_intereference;		
		double central_frequency;			
		int cw_min;							
		int cw_stage_max;					
		int pdf_backoff;					
		int path_loss_model;				

		
		int modulation_rates[4][12];		
		int err_prob_modulation[4][12];		
		int first_time_requesting_mcs;		

		
		int pdf_tx_time;					
		int frame_length;					
		int max_num_packets_aggregated;		
		int traffic_model;					
		int backoff_type;					
		int cw_adaptation;					

		double *distances_array;					
		double *received_power_array;				
		double *max_received_power_in_ap_per_wlan;	

		double *rssi_per_sta;	

	
	public:

		int data_packets_sent;								
		int rts_cts_sent;									
		double num_packets_generated;						
		double num_packets_dropped;							
		double *total_time_transmitting_per_channel;		
		double *total_time_transmitting_in_num_channels;	
		double *total_time_lost_per_channel;				
		double *total_time_lost_in_num_channels;			
		double *total_time_spectrum_per_channel;			
															
		double throughput;									
		double throughput_loss;								
		int data_packets_acked;								
		int data_frames_acked;								
		int data_packets_lost;								
		int *num_trials_tx_per_num_channels;				
		int rts_cts_lost;
		int *nacks_received;								
		int num_tx_init_tried;								
		int num_tx_init_not_possible;						
		int rts_lost_slotted_bo;							
		double prob_slotted_bo_collision;					
		double average_waiting_time;						
		double bandwidth_used_txing;						
															
															
		int num_delay_measurements;			
		double sum_delays;					
		double average_delay;				
		double average_rho;					
		double average_utilization;			
		double generation_drop_ratio;		

		double expected_backoff;		 	
		int num_new_backoff_computations;   

		double sum_time_channel_idle;		
		double last_time_channel_is_idle;	
		bool channel_idle;					

		double last_time_not_in_nav;	
		double time_in_nav;				
		int times_went_to_nav;			

		
		double *throughput_per_sta;			
		int *data_packets_sent_per_sta;		
		int *rts_cts_sent_per_sta;			
		int *data_packets_lost_per_sta;		
		int *rts_cts_lost_per_sta;			
		int *data_packets_acked_per_sta;	
		int *data_frames_acked_per_sta;		

		
		Performance simulation_performance;	

		
		Configuration configuration;		
		Configuration new_configuration;	

		
		Configuration spatial_reuse_configuration;	

		
		Performance performance_report;	

	
	private:

		
		double *channel_power;				
		int *channels_free;					
		int *channels_for_tx;				

		
		FILE *output_log_file;				
		char own_file_path[32];				
		Logger node_logger;					
		std::string header_str;				

		
		int node_state;						
		double remaining_backoff;			
		int progress_bar_counter;			

		
		int node_is_transmitter;			
		int current_left_channel;			
		int current_right_channel;			
		double current_tx_power;			
		double current_pd;					
		int current_destination_id;			
		double current_tx_duration;			
		double current_nav_time;			
		int packet_id;						
		double current_sinr;				
		double aggregate_sinr;              
		int num_sinr_measurements;
		int loss_reason;					
		int current_num_packets_aggregated;	
		int limited_num_packets_aggregated; 

		
		Notification rts_notification;			
		Notification cts_notification;			
		Notification data_notification;			
		Notification ack_notification;			
		Notification incoming_notification; 	
		Notification new_packet;				
		Notification null_notification;			
		Notification nav_notification;			
		Notification outrange_nav_notification; 
		TxInfo current_tx_info;					

		int default_modulation;		
		double bits_ofdm_sym;		

		
		int cw_current;				
		int cw_stage_current;		

		
		double data_duration;		
		double ack_duration;		
		double rts_duration;		
		double cts_duration;		

		int **mcs_per_node;				
		int *change_modulation_flag;	
		int *mcs_response;				

		
		LogicalNack logical_nack;					
		double max_pw_interference;					
		int channel_max_interference;				
		int *nodes_transmitting;					
		std::map<int, double>
			power_received_per_node;				
		double power_rx_interest;					
		int receiving_from_node_id;					
		int receiving_packet_id;					



		double BER;									
		double PER;									
		double *timestampt_channel_becomes_free;	
		double time_to_trigger;						
		int num_channels_tx;						
		int flag_apply_new_configuration;			
		int channel_aggregation_cca_model;			

		
		int flag_measure_rho;					
		double delta_measure_rho;				
		int num_measures_rho;					
		int num_measures_rho_accomplished;		
		int num_measures_utilization;			
		int num_measures_buffer_with_packets;	

		
		double burst_rate;				
		int num_bursts;					

		
		double sum_waiting_time;					
		double timestamp_new_trial_started;			
		int num_average_waiting_time_measurements;	
		double time_rand_value;						

		
		int spatial_reuse_enabled;		
		int type_last_sensed_packet;	
		double pd_spatial_reuse;		
		double tx_power_sr; 			
		int txop_sr_identified;			

		int type_ongoing_transmissions_sr[3]; 	
		double next_pd_spatial_reuse; 			
		bool flag_change_in_tx_power;			
		double potential_obss_pd_threshold;		
		double current_obss_pd_threshold;		
		double next_tx_power_limit;				
		double current_tx_power_sr;				

	
	public:

		
		/*inport */void inline InportSomeNodeStartTX(Notification &notification);
		/*inport */void inline InportSomeNodeFinishTX(Notification &notification);
		/*inport */void inline InportNackReceived(LogicalNack &logical_nack_info);

		/*inport */void inline InportMCSRequestReceived(Notification &notification);
		/*inport */void inline InportMCSResponseReceived(Notification &notification);

		/*inport */void inline InportReceivingRequestFromAgent();
		/*inport */void inline InportReceiveConfigurationFromAgent(Configuration &new_configuration);
		/*inport */void inline InportNewWlanConfigurationReceived(Configuration &new_configuration);

		
		/*inport */void inline InportNewPacketGenerated();

		
		/*inport */void inline InportRequestSpatialReuseConfiguration();
		/*inport */void inline InportNewSpatialReuseConfiguration(Configuration &new_configuration);

		
		class my_Node_outportSelfStartTX_f_t:public compcxx_functor<Node_outportSelfStartTX_f_t>{ public:void  operator() (Notification &notification) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(notification); return (c[0]->*f[0])(notification);};};my_Node_outportSelfStartTX_f_t outportSelfStartTX_f;/*outport void outportSelfStartTX(Notification &notification)*/;
		class my_Node_outportSelfFinishTX_f_t:public compcxx_functor<Node_outportSelfFinishTX_f_t>{ public:void  operator() (Notification &notification) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(notification); return (c[0]->*f[0])(notification);};};my_Node_outportSelfFinishTX_f_t outportSelfFinishTX_f;/*outport void outportSelfFinishTX(Notification &notification)*/;
		class my_Node_outportSendLogicalNack_f_t:public compcxx_functor<Node_outportSendLogicalNack_f_t>{ public:void  operator() (LogicalNack &logical_nack_info) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(logical_nack_info); return (c[0]->*f[0])(logical_nack_info);};};my_Node_outportSendLogicalNack_f_t outportSendLogicalNack_f;/*outport void outportSendLogicalNack(LogicalNack &logical_nack_info)*/;

		class my_Node_outportAskForTxModulation_f_t:public compcxx_functor<Node_outportAskForTxModulation_f_t>{ public:void  operator() (Notification &notification) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(notification); return (c[0]->*f[0])(notification);};};my_Node_outportAskForTxModulation_f_t outportAskForTxModulation_f;/*outport void outportAskForTxModulation(Notification &notification)*/;
		class my_Node_outportAnswerTxModulation_f_t:public compcxx_functor<Node_outportAnswerTxModulation_f_t>{ public:void  operator() (Notification &notification) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(notification); return (c[0]->*f[0])(notification);};};my_Node_outportAnswerTxModulation_f_t outportAnswerTxModulation_f;/*outport void outportAnswerTxModulation(Notification &notification)*/;

		class my_Node_outportAnswerToAgent_f_t:public compcxx_functor<Node_outportAnswerToAgent_f_t>{ public:void  operator() (Configuration &configuration, Performance &performance) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(configuration,performance); return (c[0]->*f[0])(configuration,performance);};};my_Node_outportAnswerToAgent_f_t outportAnswerToAgent_f;/*outport void outportAnswerToAgent(Configuration &configuration, Performance &performance)*/;
		class my_Node_outportSetNewWlanConfiguration_f_t:public compcxx_functor<Node_outportSetNewWlanConfiguration_f_t>{ public:void  operator() (Configuration &new_configuration) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(new_configuration); return (c[0]->*f[0])(new_configuration);};};my_Node_outportSetNewWlanConfiguration_f_t outportSetNewWlanConfiguration_f;/*outport void outportSetNewWlanConfiguration(Configuration &new_configuration)*/;

		
		class my_Node_outportRequestSpatialReuseConfiguration_f_t:public compcxx_functor<Node_outportRequestSpatialReuseConfiguration_f_t>{ public:void  operator() () { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(); return (c[0]->*f[0])();};};my_Node_outportRequestSpatialReuseConfiguration_f_t outportRequestSpatialReuseConfiguration_f;/*outport void outportRequestSpatialReuseConfiguration()*/;
		class my_Node_outportNewSpatialReuseConfiguration_f_t:public compcxx_functor<Node_outportNewSpatialReuseConfiguration_f_t>{ public:void  operator() (Configuration &new_configuration) { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(new_configuration); return (c[0]->*f[0])(new_configuration);};};my_Node_outportNewSpatialReuseConfiguration_f_t outportNewSpatialReuseConfiguration_f;/*outport void outportNewSpatialReuseConfiguration(Configuration &new_configuration)*/;

		
		compcxx_Timer_2 /*<trigger_t> */trigger_sim_time;				
		compcxx_Timer_3 /*<trigger_t> */trigger_end_backoff; 			
		compcxx_Timer_4 /*<trigger_t> */trigger_start_backoff;		
		compcxx_Timer_5 /*<trigger_t> */trigger_toFinishTX; 			
		compcxx_Timer_6 /*<trigger_t> */trigger_SIFS;					
		compcxx_Timer_7 /*<trigger_t> */trigger_ACK_timeout;			
		compcxx_Timer_8 /*<trigger_t> */trigger_CTS_timeout;			
		compcxx_Timer_9 /*<trigger_t> */trigger_DATA_timeout; 		
		compcxx_Timer_10 /*<trigger_t> */trigger_NAV_timeout;  		
		compcxx_Timer_11 /*<trigger_t> */trigger_inter_bss_NAV_timeout;
		compcxx_Timer_12 /*<trigger_t> */trigger_preoccupancy; 		
		compcxx_Timer_13 /*<trigger_t> */trigger_restart_sta; 			
		compcxx_Timer_14 /*<trigger_t> */trigger_wait_collisions; 		
		compcxx_Timer_15 /*<trigger_t> */trigger_start_saving_logs; 	
		compcxx_Timer_16 /*<trigger_t> */trigger_recover_cts_timeout; 	
		compcxx_Timer_17 /*<trigger_t> */trigger_rho_measurement; 		
		compcxx_Timer_18 /*<trigger_t> */txop_sr_end;					

		
		/*inport */inline void EndBackoff(trigger_t& t1);
		/*inport */inline void MyTxFinished(trigger_t& t1);
		/*inport */inline void PrintProgressBar(trigger_t& t1);
		/*inport */inline void ResumeBackoff(trigger_t& t1);
		/*inport */inline void SendResponsePacket(trigger_t& t1);
		/*inport */inline void AckTimeout(trigger_t& t1);
		/*inport */inline void CtsTimeout(trigger_t& t1);
		/*inport */inline void DataTimeout(trigger_t& t1);
		/*inport */inline void NavTimeout(trigger_t& t1);
		/*inport */inline void StartTransmission(trigger_t& t1);
		/*inport */inline void CallRestartSta(trigger_t& t1);
		/*inport */inline void CallSensing(trigger_t& t1);
		/*inport */inline void StartSavingLogs(trigger_t& t1);
		/*inport */inline void RecoverFromCtsTimeout(trigger_t& t1);
		/*inport */inline void MeasureRho(trigger_t& t1);
		/*inport */inline void SpatialReuseOpportunityEnds(trigger_t& t1);

		
		compcxx_Node_23 () {
			trigger_end_backoff.p_compcxx_parent=this /*connect trigger_end_backoff.to_component,*/;
			trigger_toFinishTX.p_compcxx_parent=this /*connect trigger_toFinishTX.to_component,*/;
			trigger_sim_time.p_compcxx_parent=this /*connect trigger_sim_time.to_component,*/;
			trigger_start_backoff.p_compcxx_parent=this /*connect trigger_start_backoff.to_component,*/;
			trigger_SIFS.p_compcxx_parent=this /*connect trigger_SIFS.to_component,*/;
			trigger_ACK_timeout.p_compcxx_parent=this /*connect trigger_ACK_timeout.to_component,*/;
			trigger_CTS_timeout.p_compcxx_parent=this /*connect trigger_CTS_timeout.to_component,*/;
			trigger_DATA_timeout.p_compcxx_parent=this /*connect trigger_DATA_timeout.to_component,*/;
			trigger_NAV_timeout.p_compcxx_parent=this /*connect trigger_NAV_timeout.to_component,*/;
			trigger_inter_bss_NAV_timeout.p_compcxx_parent=this /*connect trigger_inter_bss_NAV_timeout.to_component,*/;
			trigger_preoccupancy.p_compcxx_parent=this /*connect trigger_preoccupancy.to_component,*/;
			trigger_restart_sta.p_compcxx_parent=this /*connect trigger_restart_sta.to_component,*/;
			trigger_wait_collisions.p_compcxx_parent=this /*connect trigger_wait_collisions.to_component,*/;
			trigger_start_saving_logs.p_compcxx_parent=this /*connect trigger_start_saving_logs.to_component,*/;
			trigger_recover_cts_timeout.p_compcxx_parent=this /*connect trigger_recover_cts_timeout.to_component,*/;
			trigger_rho_measurement.p_compcxx_parent=this /*connect trigger_rho_measurement.to_component,*/;
			txop_sr_end.p_compcxx_parent=this /*connect txop_sr_end.to_component,*/;
		}
};




class compcxx_TrafficGenerator_24;/*template <class T> */
#line 267 ".././COST/cost.h"
class compcxx_Timer_19 : public compcxx_component, public TimerBase
{
 public:
  struct event_t : public CostEvent { trigger_t data; };
  

  compcxx_Timer_19() { m_simeng = CostSimEng::Instance(); m_event.active= false; }
  inline void Set(trigger_t const &, double );
  inline void Set(double );
  inline double GetTime() { return m_event.time; }
  inline bool Active() { return m_event.active; }
  inline trigger_t & GetData() { return m_event.data; }
  inline void SetData(trigger_t const &d) { m_event.data = d; }
  void Cancel();
  /*outport void to_component(trigger_t &)*/;
  void activate(CostEvent*);
 private:
  CostSimEng* m_simeng;
  event_t m_event;
public:compcxx_TrafficGenerator_24* p_compcxx_parent;};


#line 60 "traffic_generator.h"
class compcxx_TrafficGenerator_24 : public compcxx_component, public TypeII{

	
	public:
		
		void Setup();
		void Start();
		void Stop();
		
		void InitializeTrafficGenerator();
		void GenerateTraffic();


	
	public:

		int node_type;			
		int node_id; 			
		int traffic_model;		
		double traffic_load;	
		
		double burst_rate;		
		int num_bursts;			

	
	private:

	
	public:

		
		/*inport */inline void NewPacketGenerated(trigger_t& t1);
		
		class my_TrafficGenerator_outportNewPacketGenerated_f_t:public compcxx_functor<TrafficGenerator_outportNewPacketGenerated_f_t>{ public:void  operator() () { for (unsigned int compcxx_i=1;compcxx_i<c.size();compcxx_i++)(c[compcxx_i]->*f[compcxx_i])(); return (c[0]->*f[0])();};};my_TrafficGenerator_outportNewPacketGenerated_f_t outportNewPacketGenerated_f;/*outport void outportNewPacketGenerated()*/;
		
		compcxx_Timer_19 /*<trigger_t> */trigger_new_packet_generated;
		
		compcxx_TrafficGenerator_24 () {
			trigger_new_packet_generated.p_compcxx_parent=this /*connect trigger_new_packet_generated.to_component,*/;
		}

};





#line 83 "komondor_main.cc"
class compcxx_Komondor_27 : public compcxx_component, public CostSimEng {

	
	public:

		void Setup(double simulation_time_komondor, int save_node_logs, int save_agent_logs,
			int print_node_logs, int print_system_logs, int print_agent_logs, const char *nodes_filename,
			const char *script_filename, const char *simulation_code, int seed_console, int agents_enabled, const char *agents_filename);
		void Stop();
		void Start();
		void InputChecker();

		void SetupEnvironmentByReadingConfigFile();
		void GenerateNodesByReadingInputFile(const char *nodes_filename);

		void GenerateAgents(const char *agents_filename, const char *simulation_code_console);
		void GenerateCentralController(const char *agents_filename);

		int GetNumOfLines(const char *nodes_filename);
		int GetNumOfNodes(const char *nodes_filename, int node_type, std::string wlan_code);
		int CheckCentralController(const char *agents_filename);

		void PrintSystemInfo();
		void PrintAllWlansInfo();
		void PrintAllAgentsInfo();
		void PrintCentralControllerInfo();
		void PrintAllNodesInfo(int info_detail_level);
		void PrintMlOperationInfo();
		void WriteSystemInfo(Logger logger);
		void WriteAllWlansInfo(Logger logger, std::string header_str);
		void WriteAllNodesInfo(Logger logger, int info_detail_level,  std::string header_str);
		void WriteAllAgentsInfo(Logger logger, std::string header_str);

	
	public:

		compcxx_array<compcxx_Node_23 >node_container;			
		Wlan *wlan_container;			
		compcxx_array<compcxx_TrafficGenerator_24 >traffic_generator_container; 

		int total_wlans_number;						
		int total_agents_number;					
		int total_controlled_agents_number;		

		
		int save_node_logs;					
		int print_node_logs;				
		int save_agent_logs;				
		int print_agent_logs;				
		double simulation_time_komondor;	

		
		int pdf_backoff;				
		int pdf_tx_time;				
		int path_loss_model;			
		int adjacent_channel_model;		
		int collisions_model;			
		double constant_per;			
		int backoff_type;				
		int capture_effect_model;		
		int simulation_index;			

		int agents_enabled;				

		
		public:

		
		compcxx_array<compcxx_Agent_25 >agent_container;		
		int num_arms_channel;		
		int num_arms_sensitivity;	
		int num_arms_tx_power;		
		int num_arms_max_bandwidth;		

		double *actions_pd;				
		double *actions_tx_power;		

		
		compcxx_array<compcxx_CentralController_26 >central_controller;	

	
	private:

		int seed;							
		int print_system_logs;				
		std::string simulation_code;		
		const char *nodes_input_filename;	
		const char *agents_input_filename;	
		FILE *script_output_file;			
		Logger logger_script;				

		
		int first_line_skiped_flag;		
		int central_controller_flag; 	

};



















#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_20/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_20/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_20/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_20/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->RequestInformationToAp(m_event.data));
}




#line 203 "agent.h"

#line 213 "agent.h"
void compcxx_Agent_25 :: Setup(){
	
}
#line 220 "agent.h"
void compcxx_Agent_25 :: Start(){

	
	if(save_agent_logs) {
		
		sprintf(own_file_path,"%s_%s_A%d_%s.txt","../output/logs_output", simulation_code.c_str(), agent_id, wlan_code.c_str());
		remove(own_file_path);
		output_log_file = fopen(own_file_path, "at");
		agent_logger.save_logs = save_agent_logs;
		agent_logger.file = output_log_file;
		agent_logger.SetVoidHeadString();
	}
	LOGS(save_agent_logs, agent_logger.file, "%.18f;A%d;%s;%s Start()\n", SimTime(), agent_id, LOG_B00, LOG_LVL1);

	
	InitializeMlPipeline();

	
	ComputeNewConfiguration();

}
#line 245 "agent.h"
void compcxx_Agent_25 :: Stop(){
	LOGS(save_agent_logs, agent_logger.file,
		"%.15f;A%d;%s;%s Agent Stop()\n", SimTime(), agent_id, LOG_C00, LOG_LVL1);
	
	PrintOrWriteAgentStatistics();
	
	if(save_agent_logs) fclose(agent_logger.file);
}
#line 263 "agent.h"
void compcxx_Agent_25 :: RequestInformationToAp(trigger_t &){
	LOGS(save_agent_logs, agent_logger.file,
		"%.15f;A%d;%s;%s RequestInformationToAp() (request #%d)\n",
		SimTime(), agent_id, LOG_F00, LOG_LVL1, num_requests);
	
	(outportRequestInformationToAp_f());
	
	++ num_requests;
}
#line 278 "agent.h"
void compcxx_Agent_25 :: InportReceivingInformationFromAp(Configuration &received_configuration, Performance &received_performance){

	LOGS(save_agent_logs, agent_logger.file,
		"%.15f;A%d;%s;%s InportReceivingInformationFromAp()\n",
		SimTime(), agent_id, LOG_F00, LOG_LVL1);

	
	configuration = received_configuration;
	performance = received_performance;
    
	processed_configuration = pre_processor.ProcessWlanConfiguration(MULTI_ARMED_BANDITS, configuration);
    
	processed_reward = pre_processor.ProcessWlanPerformance(performance, type_of_reward);
    
    if(controller_on) processed_reward_cc = pre_processor.ProcessWlanPerformance(performance, type_of_reward_cc);

	
	UpdateAction(processed_configuration);

	
	configuration.agent_capabilities.num_arms = num_arms;
	configuration.agent_capabilities.available_actions = list_of_available_actions;

	
	if(save_agent_logs) {
        char device_code[10];
        sprintf(device_code, "A%d", agent_id);
		actions[processed_configuration].WriteAction(agent_logger, save_agent_logs, SimTime(), device_code);
		pre_processor.WritePerformance(agent_logger, SimTime(), device_code, performance, type_of_reward);
	}

	
	flag_information_available = true;

	
	if (controller_on && (automatic_forward_enabled || flag_request_from_controller)) {
        
		ForwardInformationToController();
		flag_request_from_controller = false;
	}

	
	if (learning_mechanism == MONITORING_ONLY) {
		trigger_request_information_to_ap.Set(FixTimeOffset(SimTime() + time_between_requests,13,12));
	} else {
		ComputeNewConfiguration();
	}

}
#line 332 "agent.h"
void compcxx_Agent_25 :: SendNewConfigurationToAp(Configuration &configuration_to_send){

	LOGS(save_agent_logs, agent_logger.file,
		"%.15f;A%d;%s;%s SendNewConfigurationToAp()\n",
		SimTime(), agent_id, LOG_F00, LOG_LVL1);

	
    char device_code[10];
    sprintf(device_code, "A%d", agent_id);
    processed_configuration = pre_processor.ProcessWlanConfiguration(MULTI_ARMED_BANDITS, configuration_to_send);


	
	(outportSendConfigurationToAp_f(configuration_to_send));

	
	LOGS(save_agent_logs, agent_logger.file, "%.15f;A%d;%s;%s Next request to be sent at %f\n",
		SimTime(), agent_id, LOG_C00, LOG_LVL2, FixTimeOffset(SimTime() + time_between_requests,13,12));
	trigger_request_information_to_ap.Set(FixTimeOffset(SimTime() + time_between_requests,13,12));
	flag_compute_new_configuration = true;

}
#line 367 "agent.h"
void compcxx_Agent_25 :: InportReceiveCommandFromController(int destination_agent_id, int command_id,
		Configuration &received_configuration, int type_of_reward) {

	if(controller_on && agent_id == destination_agent_id ) {

		LOGS(save_agent_logs, agent_logger.file,
			"%.15f;A%d;%s;%s InportReceiveCommandFromController()\n",
			SimTime(), agent_id, LOG_F02, LOG_LVL1);

		
        type_of_reward_cc = type_of_reward;

        switch(command_id) {
			
			case SEND_CONFIGURATION_PERFORMANCE:{
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s SENDING the current configuration and performance to the CC...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				if ( CheckValidityOfData(configuration, performance, SimTime(),
						MAX_TIME_INFORMATION_VALID) && flag_information_available) {
					ForwardInformationToController();
				} else {
					
					trigger_request_information_to_ap.Set(FixTimeOffset(SimTime(),13,12));
					flag_request_from_controller = true;
				}
				break;
			}
			
			case UPDATE_CONFIGURATION:{
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s UPDATING configuration...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				
				configuration_from_controller = received_configuration;
				
				SendNewConfigurationToAp(configuration_from_controller);
				break;
			}
			
			case STOP_ACTING: {
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s STOPPING learning activity...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				learning_allowed = FALSE;
			}
			
			case RESUME_ACTIVITY: {
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s RESUMING learning activity...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				learning_allowed = TRUE;
				break;
			}
			
			case MODIFY_ITERATION_TIME: {
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s Modifying the iteration time to %f...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2, received_configuration.agent_capabilities.time_between_requests);
				time_between_requests = received_configuration.agent_capabilities.time_between_requests;
				break;
			}
			
			case BAN_CONFIGURATION:
			case UNBAN_CONFIGURATION: {
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s BANNING/RESTORING configuration...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				
				list_of_available_actions = received_configuration.agent_capabilities.available_actions;
				char device_code[10];
				sprintf(device_code, "A%d", agent_id);
				pre_processor.PrintOrWriteAvailableActions(WRITE_LOG, device_code,
					save_agent_logs, agent_logger, SimTime(), list_of_available_actions);
				break;
			}
			
			case COMMUNICATION_UPON_TRIGGER: {
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s Stop sending automatic reports. Waiting until receiving requests from the CC...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				automatic_forward_enabled = FALSE;
				break;
			}
			
			case COMMUNICATION_AUTOMATIC: {
				LOGS(save_agent_logs,agent_logger.file,
					"%.15f;A%d;%s;%s Start sending automatic reports...\n",
					SimTime(), agent_id, LOG_C00, LOG_LVL2);
				automatic_forward_enabled = TRUE;
				break;
			}
			
			default: {
				printf("[A%d] ERROR: Undefined command id %d\n", agent_id, command_id);
				exit(-1);
			}
		}
	}

}








#line 475 "agent.h"
void compcxx_Agent_25 :: ForwardInformationToController(){

	LOGS(save_agent_logs, agent_logger.file,
		"%.15f;A%d;%s;%s Forwarding information to the controller...\n",
		SimTime(), agent_id, LOG_F02, LOG_LVL2);

	
	for (int i = 0; i < num_arms; ++i) {
		UpdateConfigurationStatisticsController(i);
	}

	
	(outportAnswerToController_f(agent_id, configuration, performance, actions));

	
	ResetControllerStatistics();

}





#line 497 "agent.h"
void compcxx_Agent_25 :: ResetControllerStatistics() {
	for (int i = 0; i < num_arms; ++i) {
		actions[i].average_reward_since_last_cc_request = 0;
		actions[i].cumulative_reward_since_last_cc_request = 0;
		actions[i].times_played_since_last_cc_request = 0;
	}
}






#line 509 "agent.h"
void compcxx_Agent_25 :: UpdateConfigurationStatisticsController(int action_ix) {
	if (actions[action_ix].times_played_since_last_cc_request > 0) {
		actions[action_ix].average_reward_since_last_cc_request =
			actions[action_ix].cumulative_reward_since_last_cc_request /
			actions[action_ix].times_played_since_last_cc_request;
	} else {
		actions[action_ix].average_reward_since_last_cc_request = 0;
	}
}











#line 528 "agent.h"
void compcxx_Agent_25 :: ComputeNewConfiguration(){

	
	if (learning_allowed) {

		LOGS(save_agent_logs, agent_logger.file, "%.15f;A%d;%s;%s ComputeNewConfiguration()\n",
			SimTime(), agent_id, LOG_F00, LOG_LVL1);

		
		if ( CheckValidityOfData(configuration, performance, SimTime(), MAX_TIME_INFORMATION_VALID)
				&& flag_information_available) {
			
			
			switch(learning_mechanism) {
				
				case MULTI_ARMED_BANDITS:{
					
					ml_output = ml_model.ComputeIndividualConfiguration
						(processed_configuration, processed_reward, agent_logger,
						SimTime(), list_of_available_actions);
					break;
				}
				case RTOT_ALGORITHM:{
                    ml_output = ml_model.ComputeIndividualConfiguration
						(processed_configuration, processed_reward, agent_logger,
						SimTime(), list_of_available_actions);
					break;
				}
				default:{
					printf("[AGENT] ERROR: %d is not a correct learning mechanism\n", learning_mechanism);
					ml_model.PrintAvailableLearningMechanisms();
					exit(EXIT_FAILURE);
					break;
				}
			}
			
			new_configuration = pre_processor.ProcessMLOutput(learning_mechanism, configuration, ml_output);
			
			SendNewConfigurationToAp(new_configuration);

		} else {
			
			
			
			double extra_wait_test = 0.005 * (double) agent_id;
			trigger_request_information_to_ap.Set(FixTimeOffset(SimTime() + time_between_requests + extra_wait_test,13,12));
		}

	} else {
		printf("The learning operation is not allowed at this moment.\n");
	}

}






#line 586 "agent.h"
void compcxx_Agent_25 :: UpdateAction(int action_ix){
	
	actions[action_ix].performance_since_last_cc_request = performance;
	actions[action_ix].instantaneous_reward = processed_reward;
	
	actions[action_ix].cumulative_reward += processed_reward;
	++ actions[action_ix].times_played;
	
	actions[action_ix].cumulative_reward_since_last_cc_request += processed_reward_cc;
	++ actions[action_ix].times_played_since_last_cc_request;
}











#line 607 "agent.h"
void compcxx_Agent_25 :: InitializeAgent() {



	learning_allowed = 1;
	num_requests = 0;
	controller_on = FALSE;
	automatic_forward_enabled = TRUE;

	initial_reward = 0;

	flag_request_from_controller = false;
	flag_information_available = false;

	indexes_configuration = new int[NUM_FEATURES_ACTIONS];

	list_of_channels = new int[num_arms_channel];
	list_of_pd_values = new double[num_arms_sensitivity];
	list_of_tx_power_values = new double[num_arms_tx_power];
	list_of_max_bandwidth = new int[num_arms_max_bandwidth];

	actions = new Action[num_arms];
	list_of_available_actions = new int[num_arms];
	for (int i = 0; i < num_arms; ++i) {
		list_of_available_actions[i] = 1;
	}

}





#line 639 "agent.h"
void compcxx_Agent_25 :: InitializeMlPipeline() {
    
    InitializePreProcessor();
    
    InitializeMlModel();
}





#line 649 "agent.h"
void compcxx_Agent_25 :: InitializePreProcessor() {

	pre_processor.num_arms = num_arms;
	pre_processor.num_arms_channel = num_arms_channel;
	pre_processor.num_arms_sensitivity = num_arms_sensitivity;
	pre_processor.num_arms_tx_power = num_arms_tx_power;
	pre_processor.num_arms_max_bandwidth = num_arms_max_bandwidth;

	pre_processor.InitializeVariables();

	pre_processor.list_of_channels = list_of_channels;
	pre_processor.list_of_pd_values = list_of_pd_values;
	pre_processor.list_of_tx_power_values = list_of_tx_power_values;
	pre_processor.list_of_max_bandwidth = list_of_max_bandwidth;

    
    actions = pre_processor.InitializeActions();

}





#line 672 "agent.h"
void compcxx_Agent_25 :: InitializeMlModel() {
	
	ml_model.agent_id = agent_id;
	ml_model.num_stas = num_stas;
	
	ml_model.learning_mechanism = learning_mechanism;
	ml_model.action_selection_strategy = action_selection_strategy;
	
	ml_model.num_channels = num_arms_channel;
	ml_model.num_arms = num_arms;
	
	ml_model.save_logs = save_agent_logs;
	ml_model.print_logs = print_agent_logs;
	if (learning_mechanism == RTOT_ALGORITHM) {
		ml_model.margin_rtot = margin_rtot;
	}
	
	ml_model.InitializeVariables();
}











#line 701 "agent.h"
void compcxx_Agent_25 :: PrintAgentInfo(){
	printf("%s Agent %d info:\n", LOG_LVL3, agent_id);
	printf("%s wlan_code = %s\n", LOG_LVL4, wlan_code.c_str());
	printf("%s num_stas = %d\n", LOG_LVL4, num_stas);
	printf("%s agent_centralized = %d\n", LOG_LVL4, agent_centralized);
	printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
	printf("%s type_of_reward = %d\n", LOG_LVL4, type_of_reward);
	printf("%s initial_reward = %f\n", LOG_LVL4, initial_reward);
	printf("%s list_of_channels: ", LOG_LVL4);
	for (int i = 0; i < num_arms_channel; ++i) {
		printf("%d  ", list_of_channels[i]);
	}
	printf("\n");
	printf("%s list_of_pd_values: ", LOG_LVL4);
	for (int i = 0; i < num_arms_sensitivity; ++i) {
		printf("%f pW (%f dBm)  ", list_of_pd_values[i], ConvertPower(PW_TO_DBM, list_of_pd_values[i]));
	}
	printf("\n");
	printf("%s list_of_tx_power_values: ", LOG_LVL4);
	for (int i = 0; i < num_arms_tx_power; ++i) {
		printf("%f pW (%f dBm)  ", list_of_tx_power_values[i], ConvertPower(PW_TO_DBM, list_of_tx_power_values[i]));
	}
	printf("\n");
	printf("%s list_of_max_bandwidth: ", LOG_LVL4);
	for (int i = 0; i < num_arms_max_bandwidth; ++i) {
		printf("%d  ", list_of_max_bandwidth[i]);
	}
	printf("\n");
	printf("%s learning_mechanism: %d\n", LOG_LVL4, learning_mechanism);
	printf("%s action_selection_strategy: %d\n", LOG_LVL4, action_selection_strategy);
	printf("%s save_agent_logs: %d\n", LOG_LVL4, save_agent_logs);
	printf("%s print_agent_logs: %d\n", LOG_LVL4, print_agent_logs);
	printf("\n");
}







#line 741 "agent.h"
void compcxx_Agent_25 :: WriteAgentInfo(Logger logger, std::string header_str){
	fprintf(logger.file, "%s Agent %d info:\n", header_str.c_str(), agent_id);
	fprintf(logger.file, "%s - wlan_code = %s\n", header_str.c_str(), wlan_code.c_str());
	fprintf(logger.file, "%s - num_stas = %d\n", header_str.c_str(), num_stas);
	fprintf(logger.file, "%s - agent_centralized = %d\n", header_str.c_str(), agent_centralized);
	fprintf(logger.file, "%s - time_between_requests = %f\n", header_str.c_str(), time_between_requests);
	fprintf(logger.file, "%s - type_of_reward = %d\n", header_str.c_str(), type_of_reward);
	fprintf(logger.file, "%s - initial_reward = %f\n", header_str.c_str(), initial_reward);
	fprintf(logger.file, "%s - list_of_channels: ", header_str.c_str());
	for (int i = 0; i < num_arms_channel; ++i) {
		fprintf(logger.file, "%d  ", list_of_channels[i]);
	}
	fprintf(logger.file, "\n");
	fprintf(logger.file, "%s - list_of_pd_values: ", header_str.c_str());
	for (int i = 0; i < num_arms_sensitivity; ++i) {
		fprintf(logger.file, "%f pW (%f dBm)  ", list_of_pd_values[i], ConvertPower(PW_TO_DBM, list_of_pd_values[i]));
	}
	fprintf(logger.file, "\n");
	fprintf(logger.file, "%s - list_of_tx_power_values: ", header_str.c_str());
	for (int i = 0; i < num_arms_channel; ++i) {
		fprintf(logger.file, "%f pW (%f dBm)  ", list_of_tx_power_values[i], ConvertPower(PW_TO_DBM, list_of_tx_power_values[i]));
	}
	fprintf(logger.file, "\n");
	fprintf(logger.file, "%s - list_of_max_bandwidth: ", header_str.c_str());
	for (int i = 0; i < num_arms_channel; ++i) {
		fprintf(logger.file, "%d  ", list_of_max_bandwidth[i]);
	}
	fprintf(logger.file, "\n");
	fprintf(logger.file, "%s - learning_mechanism = %d\n", header_str.c_str(), learning_mechanism);
	fprintf(logger.file, "%s - action_selection_strategy = %d\n", header_str.c_str(), action_selection_strategy);
	fprintf(logger.file, "%s - save_agent_logs = %d\n", header_str.c_str(), save_agent_logs);
	fprintf(logger.file, "%s - print_agent_logs = %d\n", header_str.c_str(), print_agent_logs);
}





#line 778 "agent.h"
void compcxx_Agent_25 :: PrintOrWriteAgentStatistics() {
	if (print_agent_logs) printf("\n------- Agent A%d ------\n", agent_id);
	ml_model.PrintOrWriteStatistics(PRINT_LOG, agent_logger, SimTime());

}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_21/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_21/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_21/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_21/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->ApplyMlMethod(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_22/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_22/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_22/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_22/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->RequestInformationToAgents(m_event.data));
}




#line 183 "central_controller.h"

#line 184 "central_controller.h"

#line 197 "central_controller.h"
void compcxx_CentralController_26 :: Setup(){
	
}
#line 204 "central_controller.h"
void compcxx_CentralController_26 :: Start(){

	if (controller_on) {

		
		if(save_controller_logs) {
			sprintf(own_file_path, "%s_CENTRAL_CONTROLLER.txt","../output/logs_output");
			remove(own_file_path);
			output_log_file = fopen(own_file_path, "at");
			central_controller_logger.save_logs = save_controller_logs;
			central_controller_logger.file = output_log_file;
			central_controller_logger.SetVoidHeadString();
		}
		LOGS(save_controller_logs,central_controller_logger.file,
			"%.18f;CC;%s;%s Start()\n", SimTime(), LOG_B00, LOG_LVL1);

		
		InitializeMlPipeline();

		
		controller_mode = CC_MODE_ACTIVE; 

		
		StartCcActivity();

	} else {
		printf("The central controller is NOT active\n");
	}

}
#line 238 "central_controller.h"
void compcxx_CentralController_26 :: Stop() {

	if (controller_on) {
		LOGS(save_controller_logs,central_controller_logger.file,
			"%.15f;CC;%s;%s Central Controller Stop()\n", SimTime(), LOG_C00, LOG_LVL1);
		
		PrintOrWriteControllerStatistics(PRINT_LOG);
		PrintOrWriteControllerStatistics(WRITE_LOG);
		
		if(save_controller_logs) fclose(central_controller_logger.file);
	}

}
#line 261 "central_controller.h"
void compcxx_CentralController_26 :: StartCcActivity() {
    
    if (controller_mode == CC_MODE_ACTIVE) {
        
        SendCommandToAllAgents(COMMUNICATION_UPON_TRIGGER, configuration_array);    
        
        if (time_between_requests > 0) {
            trigger_request_information_to_agents.Set(FixTimeOffset(SimTime() + time_between_requests, 13, 12));
        } else {
            
        }
	} else if (controller_mode == CC_MODE_PASSIVE) {
		
	}
}






#line 281 "central_controller.h"
void compcxx_CentralController_26 :: UpdateControllerReport(int agent_id, Action *actions) {

	
    double cumulative_performance_per_action(0);
    double visited_actions(0);
    int times_action_played(0);

    controller_report.num_arms_per_agent = num_arms_per_agent;
    controller_report.cc_iteration = cc_iteration;

    for (int i = 0; i < max_number_of_actions; ++i) {
    	controller_report.times_action_played_per_agent[agent_id][i] = actions[i].times_played_since_last_cc_request;
        if (num_arms_per_agent[agent_id] >= i) {
        	controller_report.performance_action_per_agent[agent_id][i] = actions[i].average_reward_since_last_cc_request;
            cumulative_performance_per_action +=
            	actions[i].average_reward_since_last_cc_request *
                actions[i].times_played_since_last_cc_request;
            visited_actions += actions[i].times_played_since_last_cc_request;
            
            if (actions[i].times_played_since_last_cc_request > times_action_played) {
                times_action_played = actions[i].times_played_since_last_cc_request;
                controller_report.most_played_action_per_agent[agent_id] = i;
            }
        }
    }
    if (visited_actions > 0) {
    	controller_report.average_performance_per_agent[agent_id] = cumulative_performance_per_action / visited_actions;
    } else {
    	controller_report.average_performance_per_agent[agent_id] = 0;
    }

}











#line 323 "central_controller.h"
void compcxx_CentralController_26 :: RequestInformationToAgents(trigger_t &){
	
	SendCommandToAllAgents(SEND_CONFIGURATION_PERFORMANCE, configuration_array);
}
#line 333 "central_controller.h"
void compcxx_CentralController_26 :: SendCommandToAllAgents(int command_id, Configuration *conf_array){
	LOGS(save_controller_logs,central_controller_logger.file,
		"%.15f;CC;%s;%s SendCommandToAllAgents()\n", SimTime(), LOG_C00, LOG_LVL1);
	
	for (int ix = 0 ; ix < agents_number ; ++ ix ) {
		SendCommandToSingleAgent(ix, command_id, configuration_array[ix]);
	}
}








#line 348 "central_controller.h"
void compcxx_CentralController_26 :: SendCommandToSingleAgent(int destination_agent_id, int command_id, Configuration conf){

	

	
	switch(command_id) {

		case SEND_CONFIGURATION_PERFORMANCE:{
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to send the current conf. and performance\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id);
			break;
		}
		case UPDATE_CONFIGURATION:{
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Sending a new configuration to Agent %d\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id);
			break;
		}
		case STOP_ACTING:
		case RESUME_ACTIVITY: {
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to STOP/RESUME its learning activity (%d)\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id, command_id);
			break;
		}
		case MODIFY_ITERATION_TIME: {
			
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to modify the time of an iteration to %f\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id, agent_iteration_time[destination_agent_id]);
			break;
		}
		case BAN_CONFIGURATION: {
			
			
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to BAN a configuration\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id);
			break;
		}
		case UNBAN_CONFIGURATION: {
			
			
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to UNBAN a configuration\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id);
			break;
		}
		case COMMUNICATION_UPON_TRIGGER: {
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to send information only upon receiving triggers\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id);
			break;
		}
		case COMMUNICATION_AUTOMATIC: {
			LOGS(save_controller_logs,central_controller_logger.file,
				"%.15f;CC;%s;%s Requesting Agent %d to send information automatically\n",
				SimTime(), LOG_C00, LOG_LVL2, destination_agent_id);
			break;
		}
		
		default: {
			printf("[CC] ERROR: Undefined command id %d\n", command_id);
			exit(-1);
		}
	}

	(outportSendCommandToAgent_f(destination_agent_id, command_id, conf, type_of_reward));

}
#line 426 "central_controller.h"
void compcxx_CentralController_26 :: InportReceivingInformationFromAgent(int agent_id,
        Configuration &received_configuration, Performance &received_performance, Action *actions) {

	LOGS(save_controller_logs,central_controller_logger.file,
		"%.15f;CC;%s;%s InportReceivingInformationFromAgent()\n", SimTime(), LOG_F00, LOG_LVL1);
	LOGS(save_controller_logs,central_controller_logger.file,
		"%.15f;CC;%s;%s New information has been received from Agent %d\n", SimTime(), LOG_C00, LOG_LVL2, agent_id);

	++ counter_responses_received;

	
	
	configuration_array[agent_id] = received_configuration;
	performance_array[agent_id] = received_performance;

	
	UpdateControllerReport(agent_id, actions);

	
	if(save_controller_logs) {
	    WriteAgentPerformance(actions, agent_id);
	}

	
	switch(controller_mode) {
		
		case CC_MODE_PASSIVE: {
			break;
		}
		
		case CC_MODE_ACTIVE: {
			
			GenerateClusters(agent_id, performance_array[agent_id], configuration_array[agent_id]);
			
			if (counter_responses_received == agents_number) {
				trigger_apply_ml_method.Set(FixTimeOffset(SimTime(), 13, 12));
				counter_responses_received = 0;
			}
			break;
		}
		
		default:{
			printf("[CC] ERROR: Undefined controller mode %d\n"
				"	- Use CC_MODE_PASSIVE (%d) or CC_MODE_ACTIVE (%d)\n",
				controller_mode, CC_MODE_PASSIVE, CC_MODE_ACTIVE);
		}
	}

}
#line 485 "central_controller.h"
void compcxx_CentralController_26 :: ApplyMlMethod(trigger_t &){

	LOGS(save_controller_logs,central_controller_logger.file,
		"%.15f;CC;%s;%s Applying the ML method (iteration %d)\n", SimTime(), LOG_C00, LOG_LVL1, cc_iteration);

	
	UpdatePerformancePerCluster(MAX_MIN_PERFORMANCE); 

	
	ml_model.ComputeGlobalConfiguration(configuration_array, controller_report, central_controller_logger, SimTime());

	
	switch(ml_model.learning_mechanism) {
		
		case CENTRALIZED_ACTION_BANNING: {
			
			SendCommandToAllAgents(BAN_CONFIGURATION, configuration_array);
			break;
		}
		
		default:{
			printf("[CC] ERROR: Undefined centralized ML method %d\n"
				"	- Use CENTRALIZED_ACTION_BANNING (%d)\n", controller_mode, CENTRALIZED_ACTION_BANNING);
		}
	}

	
	trigger_request_information_to_agents.Set(FixTimeOffset(SimTime() + time_between_requests,13,12));
	++ cc_iteration;

}
#line 529 "central_controller.h"
void compcxx_CentralController_26 :: GenerateClusters(int wlan_id, Performance performance, Configuration configuration){

	int clustering_approach(CLUSTER_BY_CCA); 

	switch(clustering_approach) {
		
		case CLUSTER_BY_CCA :{
			double margin_db(5);	
			for (int j = 0; j < wlans_number; ++j) {
				if (wlan_id != j && ConvertPower(PW_TO_DBM, performance.max_received_power_in_ap_per_wlan[j])
					  > ConvertPower(PW_TO_DBM, configuration.capabilities.sensitivity_default) - margin_db ) {
					controller_report.clusters_per_wlan[wlan_id][j] = 1;
				}
			}
			break;
		}
		
		case CLUSTER_BY_DISTANCE :{
			
			break;
		}
		
		default :{
			printf("[CC] ERROR: clustering approach '%d' does not exist\n", clustering_approach);
			break;
		}
	}

	PrintOrWriteClusters(WRITE_LOG);

}






#line 565 "central_controller.h"
void compcxx_CentralController_26 :: UpdatePerformancePerCluster(int shared_performance_metric) {

	switch(shared_performance_metric) {
		
		case MAX_MIN_PERFORMANCE:{
			double min_performance;
			int applicable(0);
			for(int i = 0; i < agents_number; ++i) {
				min_performance = 1;
				for(int j = 0; j < agents_number; ++j) {
					if (controller_report.clusters_per_wlan[i][j] && controller_report.average_performance_per_agent[j] > 0) {
						applicable = 1;
						if (controller_report.average_performance_per_agent[j] < min_performance)
							min_performance = controller_report.average_performance_per_agent[j];
					}
				}
				if(applicable) controller_report.cluster_performance[i] = min_performance;
				else controller_report.cluster_performance[i] = -1;
			}
			break;
		}
		
		case PROP_FAIRNESS_PERFORMANCE:{
			double cumulative_log_performance(1);	
			for(int i = 0; i < agents_number; ++i) {
				for(int j = 0; j < agents_number; ++j) {
					if (controller_report.clusters_per_wlan[i][j]) {
						cumulative_log_performance += log(controller_report.average_performance_per_agent[j]);
					}
				}
				controller_report.cluster_performance[i] = cumulative_log_performance;
			}
			break;
		}
		
		case AVERAGE_PERFORMANCE:{
			double cumulative_performance(0);
			int num_agents_involved(0);
			for(int i = 0; i < agents_number; ++i) {
				for(int j = 0; j < agents_number; ++j) {
					if (controller_report.clusters_per_wlan[i][j]) {
						cumulative_performance += controller_report.average_performance_per_agent[j];
						++ num_agents_involved;
					}
				}
				controller_report.cluster_performance[i] = cumulative_performance / num_agents_involved;
			}
			break;
		}
		
		default :{
			printf("Unknown performance metric\n");
			break;
		}
	}

}






#line 627 "central_controller.h"
void compcxx_CentralController_26 :: PrintOrWriteClusters(int print_or_write){
	switch(print_or_write){
		case PRINT_LOG:{
			printf("Already identified clusters\n");
			for (int i = 0; i < wlans_number; ++i) {
				printf("	Agent %d:", i);
				for (int j = 0; j < wlans_number; ++j) {
					printf(" %d ", controller_report.clusters_per_wlan[i][j]);
				}
				printf("\n");
			}
			break;
		}
		case WRITE_LOG:{
			LOGS(save_controller_logs, central_controller_logger.file,
				"%.15f;CC;%s;%s Already identified clusters:\n", SimTime(), LOG_C00, LOG_LVL1);
			for (int i = 0; i < wlans_number; ++i) {
				LOGS(save_controller_logs, central_controller_logger.file,
					"%.15f;CC;%s;%s Agent %d:" , SimTime(), LOG_C00, LOG_LVL2, i);
				for (int j = 0; j < wlans_number; ++j) {
					LOGS(save_controller_logs, central_controller_logger.file,
						" %d ", controller_report.clusters_per_wlan[i][j]);
				}
                LOGS(save_controller_logs, central_controller_logger.file, "\n");
			}
			break;
		}
	}
}











#line 666 "central_controller.h"
void compcxx_CentralController_26 :: InitializeMlPipeline() {
    InitializePreProcessor();
    InitializeMlModel();
}






#line 675 "central_controller.h"
void compcxx_CentralController_26 :: InitializePreProcessor() {

	pre_processor.InitializeVariables();
}





#line 683 "central_controller.h"
void compcxx_CentralController_26 :: InitializeMlModel() {

	ml_model.learning_mechanism = learning_mechanism;
	ml_model.save_logs = save_controller_logs;
	ml_model.print_logs = print_controller_logs;
	ml_model.action_selection_strategy = action_selection_strategy;
	ml_model.agents_number = agents_number;
	ml_model.max_number_of_actions = max_number_of_actions;
	ml_model.InitializeVariables();

	
	for (int i = 0; i < agents_number; ++i) {
		
		for (int j = 0; j < max_number_of_actions; ++j) {
			if (num_arms_per_agent[i] >= j) {
				controller_report.list_of_available_actions_per_agent[i][j] = 1;		
				controller_report.performance_action_per_agent[i][j] = 0;		
				controller_report.times_action_played_per_agent[i][j] = 0;
			} else {
				controller_report.list_of_available_actions_per_agent[i][j] = -1;		
				controller_report.performance_action_per_agent[i][j] = -1;	
				controller_report.times_action_played_per_agent[i][j] = -1;
			}
		}
		
		for (int j = 0; j < agents_number; ++j) {
			if (i == j) controller_report.clusters_per_wlan[i][j] = 1;
			else controller_report.clusters_per_wlan[i][j] = 0;
		}
		controller_report.cluster_performance[i] = 0;
		controller_report.most_played_action_per_agent[i] = -1;
	}

}





#line 721 "central_controller.h"
void compcxx_CentralController_26 :: InitializeCentralController() {

	time_between_requests = 0;

	save_controller_logs = TRUE;
	print_controller_logs = TRUE;

	cc_iteration = 0;
	counter_responses_received = 0;

	configuration_array = new Configuration[agents_number];
	performance_array  = new Performance[agents_number];

	num_arms_per_agent = new int[agents_number];

	
	controller_report.agents_number = agents_number;
	controller_report.max_number_of_actions = max_number_of_actions;
	controller_report.SetSizeOfArrays();

}











#line 752 "central_controller.h"
void compcxx_CentralController_26 :: PrintControllerInfo() {
	printf("%s Central Controller info:\n", LOG_LVL3);
	printf("%s controller_on = %d\n", LOG_LVL4, controller_on);
	printf("%s agents_number = %d\n", LOG_LVL4, agents_number);
	printf("%s time_between_requests = %f\n", LOG_LVL4, time_between_requests);
	printf("%s learning_mechanism = %d\n", LOG_LVL4, learning_mechanism);
	printf("%s total_nodes_number = %d\n", LOG_LVL4, total_nodes_number);
	printf("%s list of agents: ", LOG_LVL4);
	for (int i = 0; i < agents_number; ++ i) {
		printf("%d ", list_of_agents[i]);
	}
	printf("\n");
}






#line 770 "central_controller.h"
void compcxx_CentralController_26 :: WriteControllerInfo(Logger logger) {
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s Central Controller info\n", SimTime(), LOG_C00, LOG_LVL3);
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s controller_on = %d\n", SimTime(), LOG_C00, LOG_LVL4, controller_on);
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s agents_number = %d\n", SimTime(), LOG_C00, LOG_LVL4, agents_number);
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s time_between_requests = %f\n", SimTime(), LOG_C00, LOG_LVL4, time_between_requests);
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s learning_mechanism = %d\n", SimTime(), LOG_C00, LOG_LVL4, learning_mechanism);
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s total_nodes_number = %d\n", SimTime(), LOG_C00, LOG_LVL4, total_nodes_number);
	LOGS(save_controller_logs, logger.file,
		"%.15f;CC;%s;%s list of agents: ", SimTime(), LOG_C00, LOG_LVL4);
	for (int i = 0; i < agents_number; ++ i) {
		LOGS(save_controller_logs, logger.file, "%d ", list_of_agents[i]);
	}
	LOGS(save_controller_logs, logger.file, "\n");
}







#line 796 "central_controller.h"
void compcxx_CentralController_26 :: WriteAgentPerformance(Action *actions, int agent_id) {
    LOGS(save_controller_logs, central_controller_logger.file,
         "%.15f;CC;%s;%s Average performance (A%d): %.2f\n",
         SimTime(), LOG_C00, LOG_LVL3, agent_id, controller_report.average_performance_per_agent[agent_id]);
    LOGS(save_controller_logs, central_controller_logger.file,
         "%.15f;CC;%s;%s Average performance of actions (A%d): ", SimTime(), LOG_C00, LOG_LVL3, agent_id);
    for (int i = 0; i < num_arms_per_agent[agent_id]; ++i) {
        LOGS(save_controller_logs, central_controller_logger.file, "%.2f ",
             actions[i].average_reward_since_last_cc_request);
    }
    LOGS(save_controller_logs, central_controller_logger.file, "\n");
    LOGS(save_controller_logs, central_controller_logger.file,
         "%.15f;CC;%s;%s Times each action has been played (A%d): ", SimTime(), LOG_C00, LOG_LVL3, agent_id);
    for (int i = 0; i < num_arms_per_agent[agent_id]; ++i) {
        LOGS(save_controller_logs, central_controller_logger.file, "%d ", actions[i].times_played_since_last_cc_request);
    }
    LOGS(save_controller_logs, central_controller_logger.file, "\n");
}






#line 819 "central_controller.h"
void compcxx_CentralController_26 :: PrintOrWriteControllerStatistics(int print_or_write) {
	switch(print_or_write){
		case PRINT_LOG:{
			if (print_controller_logs) printf("\n------- Central Controller ------\n");
			ml_model.PrintOrWriteStatistics(PRINT_LOG, central_controller_logger, SimTime());
			break;
		}
		case WRITE_LOG:{
			LOGS(save_controller_logs, central_controller_logger.file,
				"\n%.15f;CC;%s;%s ------- Central Controller ------\n", SimTime(), LOG_C00, LOG_LVL1);
			ml_model.PrintOrWriteStatistics(WRITE_LOG, central_controller_logger, SimTime());
			break;
		}
	}
}

#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_7/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_7/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_7/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_7/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->AckTimeout(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_8/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_8/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_8/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_8/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->CtsTimeout(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_9/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_9/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_9/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_9/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->DataTimeout(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_10/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_10/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_10/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_10/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->NavTimeout(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_6/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_6/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_6/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_6/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->SendResponsePacket(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_3/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_3/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_3/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_3/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->EndBackoff(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_11/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_11/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_11/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_11/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->NavTimeout(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_12/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_12/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_12/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_12/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->StartTransmission(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_16/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_16/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_16/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_16/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->RecoverFromCtsTimeout(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_13/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_13/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_13/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_13/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->CallRestartSta(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_17/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_17/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_17/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_17/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->MeasureRho(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_2/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_2/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_2/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_2/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->PrintProgressBar(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_4/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_4/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_4/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_4/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->ResumeBackoff(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_15/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_15/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_15/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_15/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->StartSavingLogs(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_5/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_5/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_5/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_5/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->MyTxFinished(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_14/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_14/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_14/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_14/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->CallSensing(m_event.data));
}




#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_18/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_18/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_18/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_18/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->SpatialReuseOpportunityEnds(m_event.data));
}




#line 461 "node.h"

#line 462 "node.h"

#line 463 "node.h"

#line 464 "node.h"

#line 465 "node.h"

#line 466 "node.h"

#line 467 "node.h"

#line 468 "node.h"

#line 469 "node.h"

#line 470 "node.h"

#line 471 "node.h"

#line 472 "node.h"

#line 473 "node.h"

#line 474 "node.h"

#line 475 "node.h"

#line 476 "node.h"

#line 503 "node.h"
void compcxx_Node_23 :: Setup(){
	
}
#line 510 "node.h"
void compcxx_Node_23 :: Start(){

	
	InitializeVariables();

	

	
	if(save_node_logs) {
		
		
		sprintf(own_file_path,"%s_%s_N%d_%s.txt","../output/logs_output", simulation_code.c_str(), node_id, node_code.c_str());
		remove(own_file_path);
		output_log_file = fopen(own_file_path, "at");
		node_logger.save_logs = save_node_logs;
		node_logger.file = output_log_file;
		node_logger.SetVoidHeadString();
	}

	LOGS(save_node_logs, node_logger.file,"%.18f;N%d;S%d;%s;%s Start()\n",
		SimTime(), node_id, STATE_UNKNOWN, LOG_B00, LOG_LVL1);

	
	std::string header_str;
	header_str.append(ToString(SimTime()));
	if(save_node_logs) WriteNodeInfo(node_logger, INFO_DETAIL_LEVEL_2, header_str);

	
	if(node_is_transmitter) {

		if (TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION) {

			for(int i = 0; i < max_num_packets_aggregated; ++i){
				new_packet = null_notification;
				new_packet.timestamp_generated = SimTime();
				new_packet.packet_id = last_packet_generated_id;
				buffer.PutPacket(new_packet);
				++last_packet_generated_id;
			}

			time_to_trigger = SimTime() + DIFS;

			trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));

		}

		
		if(flag_measure_rho) trigger_rho_measurement.Set(SimTime() + 980);

	} else {
		current_destination_id = wlan.ap_id;	
	}

	
	if(PROGRESS_BAR_DISPLAY){
		if(node_id == 0){
			if(print_node_logs) printf("%s PROGRESS BAR:\n", LOG_LVL1);
			trigger_sim_time.Set(SimTime() + PICO_VALUE);
		}
	}

	
	
	
	
	

	LOGS(save_node_logs, node_logger.file,"\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n");
	
}
#line 584 "node.h"
void compcxx_Node_23 :: Stop(){

	LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s Node Stop()\n",
		SimTime(), node_id, node_state, LOG_C00, LOG_LVL1);

	
	if (print_node_logs) PrintOrWriteNodeStatistics(PRINT_LOG);
	if (save_node_logs) PrintOrWriteNodeStatistics(WRITE_LOG);

	
	if(save_node_logs) fclose(node_logger.file);

	
	SaveSimulationPerformance();

	
	GenerateConfiguration();
	
}
#line 608 "node.h"
void compcxx_Node_23 :: InportSomeNodeStartTX(Notification &notification){

	LOGS(save_node_logs, node_logger.file,
			"%.15f;N%d;S%d;%s;%s InportSomeNodeStartTX(): N%d to N%d sends packet type %d in range %d-%d at power %.2f dBm\n",
			SimTime(), node_id, node_state, LOG_D00, LOG_LVL1,
			notification.source_id, notification.destination_id, notification.packet_type,
			notification.left_channel, notification.right_channel,
			ConvertPower(PW_TO_DBM, notification.tx_info.tx_power));

	LOGS(save_node_logs,node_logger.file,
	        "%.15f;N%d;S%d;%s;%s Nodes transmitting: ",
			SimTime(), node_id, node_state, LOG_D00, LOG_LVL3);

	
	nodes_transmitting[notification.source_id] = TRUE;
	if(save_node_logs) PrintOrWriteNodesTransmitting(WRITE_LOG, save_node_logs,
		print_node_logs, node_logger, total_nodes_number, nodes_transmitting);

	if(notification.source_id == node_id){ 

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s I have started a TX of packet #%d (type %d) to N%d in channels %d - %d of duration %.9f us\n",
			SimTime(), node_id, node_state, LOG_D02, LOG_LVL2, notification.packet_id,
			notification.packet_type, notification.destination_id,
			notification.left_channel, notification.right_channel, notification.tx_duration * pow(10,6));

	} else {	

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s N%d has started a TX of packet #%d (type %d) to N%d in channels %d - %d\n",
			SimTime(), node_id, node_state, LOG_D02, LOG_LVL2, notification.source_id,
			notification.packet_id,	notification.packet_type, notification.destination_id,
			notification.left_channel, notification.right_channel);

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Power sensed per channel BEFORE updating [dBm]: ",
			SimTime(), node_id, node_state, LOG_E18, LOG_LVL3);

		PrintOrWriteChannelPower(WRITE_LOG, save_node_logs, node_logger, print_node_logs,
					&channel_power);

        

        if (notification.tx_info.flag_change_in_tx_power) {
            received_power_array[notification.source_id] =
                ComputePowerReceived(distances_array[notification.source_id],
                notification.tx_info.tx_power, central_frequency, path_loss_model);
        }

		







		if (notification.tx_info.flag_change_in_tx_power) {
			received_power_array[notification.source_id] =
				ComputePowerReceived(distances_array[notification.source_id],
				notification.tx_info.tx_power, central_frequency, path_loss_model);
		}

		
		UpdateChannelsPower(&channel_power, notification, TX_INITIATED,
			central_frequency, path_loss_model, adjacent_channel_model, received_power_array[notification.source_id], node_id);

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Power sensed per channel [dBm]: ",
			SimTime(), node_id, node_state, LOG_E18, LOG_LVL3);

		PrintOrWriteChannelPower(WRITE_LOG, save_node_logs, node_logger, print_node_logs, &channel_power);

		
		UpdatePowerSensedPerNode(current_primary_channel, power_received_per_node, notification,
			central_frequency, path_loss_model, received_power_array[notification.source_id], TX_INITIATED);

		UpdateTimestamptChannelFreeAgain(timestampt_channel_becomes_free, &channel_power, current_pd, SimTime());
















		







		if (spatial_reuse_enabled) {
			
			type_last_sensed_packet = CheckPacketOrigin(notification, bss_color, srg);
			
			potential_obss_pd_threshold = GetSensitivitySpatialReuse(type_last_sensed_packet,
				srg_obss_pd, non_srg_obss_pd, current_pd, power_received_per_node[notification.source_id]);
			
			if (type_last_sensed_packet != INTRA_BSS_FRAME) {
				LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s SPATIAL REUSE OPERATION: \n",
					SimTime(), node_id, node_state, LOG_F02, LOG_LVL3);
				LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s type_last_sensed_packet = %d\n",
					SimTime(), node_id, node_state, LOG_F02, LOG_LVL4, type_last_sensed_packet);
				LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s Previous current_obss_pd_threshold = %f\n",
					SimTime(), node_id, node_state, LOG_F02, LOG_LVL4, ConvertPower(PW_TO_DBM, current_obss_pd_threshold));
				LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s previous txop_sr_identified = %d\n",
					SimTime(), node_id, node_state, LOG_F02, LOG_LVL4, txop_sr_identified);
				LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s New potential_obss_pd_threshold = %f\n",
					SimTime(), node_id, node_state, LOG_F02, LOG_LVL4, ConvertPower(PW_TO_DBM, potential_obss_pd_threshold));
			}
		}
		

		
		switch(node_state){

			







			case STATE_SENSING:{

				if(notification.destination_id == node_id){	

					
					power_rx_interest = power_received_per_node[notification.source_id];

					current_left_channel = notification.left_channel;
					current_right_channel = notification.right_channel;
					current_modulation = notification.modulation_id;

					LOGS(save_node_logs,node_logger.file,
						"%.15f;N%d;S%d;%s;%s I am the TX destination (N%d). Checking if notification can be received.\n",
						SimTime(), node_id, node_state, LOG_D07, LOG_LVL3,
						notification.destination_id);

					
					
					
					
					
					

					if(notification.packet_type == PACKET_TYPE_RTS){

						
						max_pw_interference = channel_power[current_primary_channel]
							- power_received_per_node[notification.source_id];

					} else {

						
						ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
							notification, node_state, power_received_per_node, &channel_power);
					}

					LOGS(save_node_logs, node_logger.file,
						"%.15f;N%d;S%d;%s;%s P[%d] = %f dBm - P_st = %.2f dBm - P_if = %.2f dBm - P_noise = %.2f dBm\n",
						SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
						channel_max_intereference,
						ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
						ConvertPower(PW_TO_DBM, power_rx_interest),
						ConvertPower(PW_TO_DBM, max_pw_interference),
						ConvertPower(PW_TO_DBM, NOISE_LEVEL_DBM));

					if(notification.packet_type == PACKET_TYPE_RTS) {	

						current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

						LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s SINR = %.2f dBm\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
							ConvertPower(LINEAR_TO_DB, current_sinr));

						
						loss_reason = IsPacketLost(current_primary_channel, notification, notification,
								current_sinr, capture_effect, current_pd,
								power_rx_interest, constant_per, node_id, capture_effect_model);

						if(loss_reason != PACKET_NOT_LOST) {	

							
							if(loss_reason == PACKET_LOST_INTERFERENCE){
								if(fabs(outrange_nav_notification.timestamp - notification.timestamp)
									< MAX_DIFFERENCE_SAME_TIME){
									loss_reason = PACKET_LOST_BO_COLLISION;
								}
							}

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Reception of notification %d from N%d CANNOT be started because of reason %d\n",
								SimTime(), node_id, node_state, LOG_D15, LOG_LVL4, notification.packet_id,
								notification.source_id, loss_reason);

							if(nack_activated) {
								
								logical_nack = GenerateLogicalNack(notification.packet_type, notification.packet_id,
									node_id, notification.source_id, NODE_ID_NONE, loss_reason, BER, current_sinr);
								SendLogicalNack(logical_nack);
							}

							if(node_is_transmitter){

								int pause (HandleBackoff(PAUSE_TIMER, &channel_power,
									current_primary_channel, current_pd, buffer.QueueSize()));

								
								if (pause) PauseBackoff();
							}

						} else {	

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Reception of RTS #%d from N%d CAN be started (SINR = %f dB)\n",
								SimTime(), node_id, node_state, LOG_D16, LOG_LVL4, notification.packet_id,
								notification.source_id, ConvertPower(LINEAR_TO_DB, current_sinr));

							



							incoming_notification = notification;

							
							data_duration = notification.tx_info.data_duration;
							ack_duration = notification.tx_info.ack_duration;
							rts_duration = notification.tx_info.rts_duration;
							cts_duration = notification.tx_info.cts_duration;

							current_left_channel = notification.left_channel;
							current_right_channel = notification.right_channel;

							node_state = STATE_RX_RTS;
							receiving_from_node_id = notification.source_id;
							receiving_packet_id = notification.packet_id;

							
							if(node_is_transmitter) PauseBackoff();

						}

					} else {	
						LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Unexpected packet type (%d) received!\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL4, notification.packet_type);
					}

				} else {	

					
					if(notification.packet_type == PACKET_TYPE_RTS
						|| notification.packet_type == PACKET_TYPE_CTS
						|| notification.packet_type == PACKET_TYPE_DATA
						|| notification.packet_type == PACKET_TYPE_ACK) {

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s I am not the TX destination (N%d to N%d). Checking if Frame can be decoded.\n",
							SimTime(), node_id, node_state, LOG_D07, LOG_LVL2,
							notification.source_id, notification.destination_id);

						
						
						power_rx_interest = power_received_per_node[notification.source_id];
						
						ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
							notification, node_state, power_received_per_node, &channel_power);
						
						current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);
						
						loss_reason = IsPacketLost(current_primary_channel, notification, notification, current_sinr,
							capture_effect, current_pd, power_rx_interest, constant_per, node_id, capture_effect_model);

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Pmax_intf[%d] = %f dBm - P_st = %f dBm - P_if = %f dBm, sinr = %f dB\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
							channel_max_intereference, ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
							ConvertPower(PW_TO_DBM, power_rx_interest),
							ConvertPower(PW_TO_DBM, max_pw_interference),
							ConvertPower(LINEAR_TO_DB,current_sinr));

						


						
						if (spatial_reuse_enabled && loss_reason == PACKET_NOT_LOST) {
							
							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s The packet could be decoded with the default pd (%f dBm)...\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL3, ConvertPower(PW_TO_DBM, current_pd));
							
							int new_txop_sr_identified(IdentifySpatialReuseOpportunity(power_rx_interest, potential_obss_pd_threshold));
							
							
							
							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s txop_sr_identified = %d / new_txop_sr_identified = %d\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL4, txop_sr_identified, new_txop_sr_identified);
							if ( (txop_sr_identified && new_txop_sr_identified &&
									potential_obss_pd_threshold <= current_obss_pd_threshold) ||
								(!txop_sr_identified && new_txop_sr_identified) ) {
								
								current_obss_pd_threshold = potential_obss_pd_threshold;
								
								txop_sr_identified = new_txop_sr_identified;
								
								loss_reason = PACKET_IGNORED_SPATIAL_REUSE;
								
								next_tx_power_limit = ApplyTxPowerRestriction(current_obss_pd_threshold, current_tx_power);
								
								time_to_trigger = SimTime() + notification.tx_info.nav_time;
								txop_sr_end.Set(FixTimeOffset(time_to_trigger,13,12));
								LOGS(save_node_logs, node_logger.file,
									"%.15f;N%d;S%d;%s;%s An SR TXOP was detected for OBSS_PD = %f dBm "
									"(received RTS/CTS while being in SENSING state.)\n",
									SimTime(), node_id, node_state, LOG_D08, LOG_LVL3,
									ConvertPower(PW_TO_DBM, current_obss_pd_threshold));
							}
						}
						

						if(loss_reason == PACKET_NOT_LOST) { 

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Packet type %d can be decoded\n",
								SimTime(), node_id, node_state, LOG_D07, LOG_LVL3, notification.packet_type);

							
							nav_notification = notification;

							if(node_is_transmitter){
								int pause (HandleBackoff(PAUSE_TIMER, &channel_power,
									current_primary_channel, current_pd, buffer.QueueSize()));
								
								if (pause) PauseBackoff();
							}

							
							current_nav_time = notification.tx_info.nav_time;

							
							
							
							time_to_trigger = SimTime() + current_nav_time - TIME_OUT_EXTRA_TIME;

							
							
							if (spatial_reuse_enabled && type_last_sensed_packet != INTRA_BSS_FRAME) {
								trigger_inter_bss_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
							} else {
								trigger_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
							}

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Entering in NAV during %.12f and setting NAV timeout to %.12f\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL3,
								current_nav_time, trigger_NAV_timeout.GetTime());






							node_state = STATE_NAV;
							last_time_not_in_nav = SimTime();
							++times_went_to_nav;

						} else { 

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Frame sent by N%d could not be decoded for reason %d\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL3,
								notification.source_id, loss_reason);

							
							outrange_nav_notification = notification;

							
							if(node_is_transmitter){

								LOGS(save_node_logs,node_logger.file,
									"%.15f;N%d;S%d;%s;%s Checking if BO must be paused...\n",
									SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);

								int pause;

								if(spatial_reuse_enabled && txop_sr_identified) {
									pause = HandleBackoff(PAUSE_TIMER, &channel_power,
										current_primary_channel, current_obss_pd_threshold, buffer.QueueSize());
								} else {
									pause = HandleBackoff(PAUSE_TIMER, &channel_power, current_primary_channel,
										current_pd, buffer.QueueSize());
								}

								
								if (pause) {

									PauseBackoff();

								} else {

									LOGS(save_node_logs,node_logger.file,
										"%.15f;N%d;S%d;%s;%s BO must not be paused (%f remaining slots).\n",
										SimTime(), node_id, node_state, LOG_D08, LOG_LVL5, remaining_backoff/SLOT_TIME);
								}

							}

						}

					}


















				}
				break;
			}

			



			case STATE_NAV:{

				


				int nav_collision(0);				
				int inter_bss_nav_collision(0);	
				

				if (spatial_reuse_enabled && type_last_sensed_packet != INTRA_BSS_FRAME) {
					inter_bss_nav_collision = fabs(nav_notification.timestamp -
						notification.timestamp) < MAX_DIFFERENCE_SAME_TIME;
				} else {
					nav_collision = fabs(nav_notification.timestamp -
						notification.timestamp) < MAX_DIFFERENCE_SAME_TIME;

				}
				

				if(notification.destination_id == node_id){	

					
					if(nav_collision || inter_bss_nav_collision) {

						if(notification.packet_type == PACKET_TYPE_RTS) {	

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s RTS from my AP N%d sent simultaneously\n",
								SimTime(), node_id, node_state, LOG_D16, LOG_LVL4,
								notification.source_id);

							
							power_rx_interest = power_received_per_node[notification.source_id];

							
							ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
								notification, node_state, power_received_per_node, &channel_power);

							current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s P[%d] = %f dBm - P_st = %f dBm - P_if = %f dBm\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL5, channel_max_intereference,
								ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
								ConvertPower(PW_TO_DBM, power_rx_interest),
								ConvertPower(PW_TO_DBM, max_pw_interference));

							
							
							loss_reason = IsPacketLost(current_primary_channel, notification, notification,
								current_sinr, capture_effect, current_pd,
								power_rx_interest, constant_per, node_id, capture_effect_model);

							if(loss_reason != PACKET_NOT_LOST) {	

								loss_reason = PACKET_LOST_BO_COLLISION;

								if(!node_is_transmitter) {

									
									
									
									

									
									LOGS(save_node_logs,node_logger.file,
										"%.15f;N%d;S%d;%s;%s RTS from my AP CANNOT be decoded\n",
										SimTime(), node_id, node_state, LOG_D08, LOG_LVL5);

									trigger_NAV_timeout.Cancel();
									time_to_trigger = SimTime() + MAX_DIFFERENCE_SAME_TIME;

									
									trigger_restart_sta.Set(FixTimeOffset(time_to_trigger,13,12));

								} else {

									printf("ALARM! Should not happen in downlink traffic\n");

								}
								

								if(nack_activated) {
									LOGS(save_node_logs,node_logger.file,
										"%.15f;N%d;S%d;%s;%s RTS cannot be decoded (SINR = %f dB) -> Sending NACK corresponding to BO collision to N%d\n",
										SimTime(), node_id, node_state, LOG_D16, LOG_LVL5,
										ConvertPower(LINEAR_TO_DB, current_sinr), notification.source_id);
									logical_nack = GenerateLogicalNack(notification.packet_type,
										notification.packet_id, node_id, notification.source_id,
										NODE_ID_NONE, loss_reason, BER, current_sinr);
									SendLogicalNack(logical_nack);
								}

							} else {	

								LOGS(save_node_logs,node_logger.file,
									"%.15f;N%d;S%d;%s;%s Reception of RTS #%d from N%d CAN be started (SINR = %f dB)\n",
									SimTime(), node_id, node_state, LOG_D16, LOG_LVL4, notification.packet_id,
									notification.source_id, ConvertPower(LINEAR_TO_DB, current_sinr));

								
								if ( spatial_reuse_enabled ) {
									trigger_inter_bss_NAV_timeout.Cancel(); 
									LOGS(save_node_logs,node_logger.file,
										"%.15f;N%d;S%d;%s;%s INTER-BSS NAV CANCELLED!\n",
										SimTime(), node_id, node_state, LOG_D16, LOG_LVL4);
								} else {
									trigger_NAV_timeout.Cancel();			
									LOGS(save_node_logs,node_logger.file,
										"%.15f;N%d;S%d;%s;%s DEFAULT NAV CANCELLED!\n",
										SimTime(), node_id, node_state, LOG_D16, LOG_LVL4);
								}

								
								data_duration = notification.tx_info.data_duration;
								ack_duration = notification.tx_info.ack_duration;
								rts_duration = notification.tx_info.rts_duration;
								cts_duration = notification.tx_info.cts_duration;

								current_left_channel = notification.left_channel;
								current_right_channel = notification.right_channel;

								node_state = STATE_RX_RTS;
								receiving_from_node_id = notification.source_id;
								receiving_packet_id = notification.packet_id;

								incoming_notification = notification;

								
								if(node_is_transmitter) PauseBackoff();

							}

						} else {	
							LOGS(save_node_logs,node_logger.file,
									"%.15f;N%d;S%d;%s;%s Unexpected packet type (%d) received!\n",
									SimTime(), node_id, node_state, LOG_D08, LOG_LVL4, notification.packet_type);
						}

					} else { 

						if (nack_activated) {
							
							logical_nack = GenerateLogicalNack(notification.packet_type, notification.packet_id,
								node_id, notification.source_id, NODE_ID_NONE, PACKET_LOST_RX_IN_NAV, BER, current_sinr);
							SendLogicalNack(logical_nack);
						}

					}


				} else { 

					if(notification.packet_type == PACKET_TYPE_RTS
						||  notification.packet_type == PACKET_TYPE_CTS
						|| notification.packet_type == PACKET_TYPE_DATA
						|| notification.packet_type == PACKET_TYPE_ACK) {	

						

						
						power_rx_interest = power_received_per_node[notification.source_id];
						
						ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
							notification, node_state, power_received_per_node, &channel_power);
						
						current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);
						LOGS(save_node_logs, node_logger.file,
							"%.15f;N%d;S%d;%s;%s P[%d] = %f dBm - P_st = %f dBm - P_if = %f dBm\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5, channel_max_intereference,
							ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
							ConvertPower(PW_TO_DBM, power_rx_interest),
							ConvertPower(PW_TO_DBM, max_pw_interference));
						
						
						int loss_reason (IsPacketLost(current_primary_channel, notification, notification,
							current_sinr, capture_effect, current_pd, power_rx_interest, constant_per,
							node_id, capture_effect_model));

						
						if((nav_collision || inter_bss_nav_collision) && loss_reason == PACKET_NOT_LOST)  {

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Updating the NAV according to the last sensed transmission\n",
								SimTime(), node_id, node_state, LOG_D07, LOG_LVL2);

							if(!node_is_transmitter) {

								
								time_to_trigger = SimTime() + MAX_DIFFERENCE_SAME_TIME;
								if (spatial_reuse_enabled && inter_bss_nav_collision) {
									trigger_inter_bss_NAV_timeout.Cancel(); 
									trigger_inter_bss_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s (workaround) setting inter-BSS NAV trigger to %.12f\n",
										SimTime(), node_id, node_state, LOG_D07, LOG_LVL3, time_to_trigger);
								} else {
									trigger_NAV_timeout.Cancel();			
									trigger_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s (workaround) setting NAV trigger to %.12f\n",
										SimTime(), node_id, node_state, LOG_D07, LOG_LVL3, time_to_trigger);
								}

							} else {

								if ( (nav_collision && nav_notification.packet_type == notification.packet_type)
									|| (inter_bss_nav_collision && nav_notification.packet_type == notification.packet_type) ) {

									
									
									

									
									if (spatial_reuse_enabled && inter_bss_nav_collision) {
										trigger_inter_bss_NAV_timeout.Cancel();		
									} else {
										trigger_NAV_timeout.Cancel();				
									}

									
									

									
									time_to_trigger =
										SimTime() + notification.tx_info.rts_duration
										+ SIFS + notification.tx_info.cts_duration
										- notification.tx_info.preoccupancy_duration;

									trigger_wait_collisions.Set(FixTimeOffset(time_to_trigger,13,12));

									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s Recovering from EIFS at %.12f (preoc. = %.12f)\n",
										SimTime(), node_id, node_state, LOG_D07, LOG_LVL4,
										trigger_wait_collisions.GetTime(),
										notification.tx_info.preoccupancy_duration);

								}
							}

							

						} else { 

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s I am not the TX destination (N%d to N%d). Checking if new RTS/CTS can be decoded.\n",
								SimTime(), node_id, node_state, LOG_D07, LOG_LVL2,
								notification.source_id, notification.destination_id);

							
							
							power_rx_interest = power_received_per_node[notification.source_id];

							
							ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
								notification, node_state, power_received_per_node, &channel_power);

							current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Pmax_intf[%d] = %f dBm - P_st = %f dBm - P_if = %f dBm, sinr = %f dB\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
								channel_max_intereference, ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
								ConvertPower(PW_TO_DBM, power_rx_interest),
								ConvertPower(PW_TO_DBM, max_pw_interference),
								ConvertPower(LINEAR_TO_DB,current_sinr));

							
							loss_reason = IsPacketLost(current_primary_channel, notification, notification,
								current_sinr, capture_effect, current_pd, power_rx_interest, constant_per,
								node_id, capture_effect_model);

							int power_condition (ConvertPower(PW_TO_DBM, channel_power[current_primary_channel]) > sensitivity_default);

							if (loss_reason == PACKET_NOT_LOST && power_condition) {	

								


								
								
								int loss_reason_sr (1);
								int power_condition_sr (1);
								if (spatial_reuse_enabled && type_last_sensed_packet != INTRA_BSS_FRAME && node_is_transmitter) { 	
									double power_interference (power_received_per_node[notification.source_id]);
									
									loss_reason_sr = IsPacketLost(current_primary_channel, notification, notification,
										current_sinr, capture_effect, potential_obss_pd_threshold, power_interference, constant_per,
										node_id, capture_effect_model);
									power_condition_sr = ConvertPower(PW_TO_DBM, channel_power[current_primary_channel]) > potential_obss_pd_threshold;
								}
								if (loss_reason_sr != PACKET_NOT_LOST && power_condition_sr) {
									txop_sr_identified = TRUE;	
									next_pd_spatial_reuse = potential_obss_pd_threshold;	
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s TXOP detected while being in NAV state\n",
										SimTime(), node_id, node_state, LOG_D08, LOG_LVL3);
								} else {
									if (loss_reason == PACKET_NOT_LOST && txop_sr_identified) txop_sr_identified = FALSE; 
								
									if (spatial_reuse_enabled && type_last_sensed_packet != INTRA_BSS_FRAME) { 
										nav_notification = notification;
										if(trigger_inter_bss_NAV_timeout.GetTime() < notification.tx_info.nav_time) {
											time_to_trigger = SimTime() +  notification.tx_info.nav_time + TIME_OUT_EXTRA_TIME;
											trigger_inter_bss_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
											LOGS(save_node_logs, node_logger.file,
												"%.15f;N%d;S%d;%s;%s Updating inter-BSS NAV timeout to the more restrictive one: From %.12f to %.12f\n",
												SimTime(), node_id, node_state, LOG_D07, LOG_LVL4,
												trigger_inter_bss_NAV_timeout.GetTime(), time_to_trigger);
										}
									} else {	
										nav_notification = notification;
										if(trigger_NAV_timeout.GetTime() < notification.tx_info.nav_time) {
											time_to_trigger = SimTime() +  notification.tx_info.nav_time + TIME_OUT_EXTRA_TIME;
											trigger_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
											LOGS(save_node_logs, node_logger.file,
												"%.15f;N%d;S%d;%s;%s Updating NAV timeout to the more restrictive one: From %.12f to %.12f\n",
												SimTime(), node_id, node_state, LOG_D07, LOG_LVL4,
												trigger_NAV_timeout.GetTime(), time_to_trigger);
										}
									}
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s New RTS/CTS arrived from (N%d). Setting NAV to new value %.18f\n",
										SimTime(), node_id, node_state, LOG_D07, LOG_LVL3,
										notification.source_id, trigger_NAV_timeout.GetTime());
								}

							} else {			
								if(notification.packet_type == PACKET_TYPE_RTS
										||  notification.packet_type == PACKET_TYPE_CTS){
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s RTS/CTS sent from N%d could not be decoded for reason %d\n",
										SimTime(), node_id, node_state, LOG_D08, LOG_LVL3,
										notification.source_id, loss_reason);
								}
							}
						}
					}
				}

				break;
			}

			



			case STATE_TX_DATA:
			case STATE_TX_ACK:
			case STATE_TX_RTS:
			case STATE_TX_CTS:{

				if(notification.destination_id == node_id){ 

					LOGS(save_node_logs, node_logger.file,
						"%.15f;N%d;S%d;%s;%s I am the TX destination (N%d)\n",
						SimTime(), node_id, node_state, LOG_D07, LOG_LVL3,
						notification.destination_id);

					LOGS(save_node_logs, node_logger.file,
						"%.15f;N%d;S%d;%s;%s I am transmitting, packet cannot be received\n",
						SimTime(), node_id, node_state, LOG_D18, LOG_LVL3);

					if(nack_activated) {
						
						logical_nack = GenerateLogicalNack(notification.packet_type, notification.packet_id,
							node_id, notification.source_id, NODE_ID_NONE, PACKET_LOST_DESTINATION_TX, BER, current_sinr);

						SendLogicalNack(logical_nack);
					}

				} else {	




				}


				


				int nav_collision;				
				int inter_bss_nav_collision;	
				
				if (spatial_reuse_enabled && type_last_sensed_packet != INTRA_BSS_FRAME) {
					inter_bss_nav_collision = abs(nav_notification.timestamp -
						notification.timestamp) < MAX_DIFFERENCE_SAME_TIME;
				} else {
					nav_collision = fabs(nav_notification.timestamp -
						notification.timestamp) < MAX_DIFFERENCE_SAME_TIME;
				}

				
				if(nav_collision || inter_bss_nav_collision) {

				}

					
					if (spatial_reuse_enabled && type_last_sensed_packet != INTRA_BSS_FRAME && node_is_transmitter) {

						double power_interference (power_received_per_node[notification.source_id]);
						double sinr_interference (UpdateSINR(power_interference, max_pw_interference));

						
						
						int loss_reason_legacy (IsPacketLost(current_primary_channel, notification, notification,
							sinr_interference, capture_effect, sensitivity_default, power_interference, constant_per,
							node_id, capture_effect_model));
						
						
						int loss_reason_sr (IsPacketLost(current_primary_channel, notification, notification,
							sinr_interference, capture_effect, potential_obss_pd_threshold, power_interference, constant_per,
							node_id, capture_effect_model));

						if(save_node_logs && node_id == 0) LOGS(save_node_logs, node_logger.file,
							"%.15f;N%d;S%d;%s;%s sinr_interference = %f - capture_effect = %f - pd_spatial_reuse = %f"
							" - power_interference = %f)\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL3,
							ConvertPower(LINEAR_TO_DB, sinr_interference), capture_effect,
							ConvertPower(PW_TO_DBM,pd_spatial_reuse),ConvertPower(PW_TO_DBM,power_interference));

						if(save_node_logs && node_id == 0) fprintf(node_logger.file,
							"%.15f;N%d;S%d;%s;%s CHECKING TXOP in TX state (pd_sr = %f - lost = %d)\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL3,
							ConvertPower(PW_TO_DBM,pd_spatial_reuse), loss_reason_sr);

						
						if (loss_reason_legacy == PACKET_NOT_LOST && loss_reason_sr != PACKET_NOT_LOST) {
							txop_sr_identified = TRUE;	
							current_obss_pd_threshold = potential_obss_pd_threshold;
							
							next_tx_power_limit = ApplyTxPowerRestriction(current_obss_pd_threshold, current_tx_power);
							
							time_to_trigger = SimTime() + notification.tx_info.nav_time;
							txop_sr_end.Set(FixTimeOffset(time_to_trigger,13,12));
							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s TXOP detected while being in TX state\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL3);
						} else if (loss_reason_legacy == PACKET_NOT_LOST && txop_sr_identified) {
							
							txop_sr_identified = FALSE;
							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Cancelling SR TXOP while being in TX state\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL3);
						}
					}

				

				break;
			}

			





			case STATE_RX_DATA:
			case STATE_RX_ACK:
			case STATE_RX_RTS:
			case STATE_RX_CTS:{

				if(notification.destination_id == node_id){	





					
					current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

					
					loss_reason = IsPacketLost(current_primary_channel, incoming_notification, notification,
						current_sinr, capture_effect, current_pd, power_rx_interest, constant_per, node_id, capture_effect_model);

					
					

					switch(capture_effect_model){

						case CE_DEFAULT:{
							if(loss_reason != PACKET_NOT_LOST
								&& loss_reason != PACKET_LOST_OUTSIDE_CH_RANGE)  {	
									
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s Pure collision! Already receiving from N%d\n",
										SimTime(), node_id, node_state, LOG_D19, LOG_LVL4, receiving_from_node_id);
									loss_reason = PACKET_LOST_PURE_COLLISION;
									
									if(fabs(notification.timestamp - incoming_notification.timestamp) < MAX_DIFFERENCE_SAME_TIME){
										
										loss_reason = PACKET_LOST_BO_COLLISION;
										if(!node_is_transmitter) {
											time_to_trigger = SimTime() + MAX_DIFFERENCE_SAME_TIME;
											trigger_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
										} else {
											printf("ALARM! Should not happen in downlink traffic\n");
										}
									}
									if(nack_activated) {
										
										logical_nack = GenerateLogicalNack(notification.packet_type, nav_notification.packet_id,
												node_id, nav_notification.source_id, notification.source_id, loss_reason, BER, current_sinr);
										SendLogicalNack(logical_nack);
									}

							} else {	

								if (nack_activated) {
									LOGS(save_node_logs, node_logger.file,
											"%.15f;N%d;S%d;%s;%s Low strength signal received while already receiving from N%d\n",
										SimTime(), node_id, node_state, LOG_D20, LOG_LVL4, receiving_from_node_id);

									
									logical_nack = GenerateLogicalNack(notification.packet_type, receiving_from_node_id,
											node_id, notification.source_id, NODE_ID_NONE, PACKET_LOST_LOW_SIGNAL_AND_RX, BER, current_sinr);

									SendLogicalNack(logical_nack);
								}

							}
							break;
						}

						case CE_IEEE_802_11:{
							int capture_effect_condition (power_received_per_node[notification.source_id] >
								power_received_per_node[receiving_from_node_id] + capture_effect);

							if (loss_reason == PACKET_NOT_LOST && capture_effect_condition) {
								if (notification.packet_type == PACKET_TYPE_RTS) {
									
									incoming_notification = notification;
									
									data_duration = notification.tx_info.data_duration;
									ack_duration = notification.tx_info.ack_duration;
									rts_duration = notification.tx_info.rts_duration;
									cts_duration = notification.tx_info.cts_duration;
									current_left_channel = notification.left_channel;
									current_right_channel = notification.right_channel;
									node_state = STATE_RX_RTS;
									receiving_from_node_id = notification.source_id;
									receiving_packet_id = notification.packet_id;
									
									if(node_is_transmitter) PauseBackoff();
									if (nack_activated) {
										
										logical_nack = GenerateLogicalNack(notification.packet_type, nav_notification.packet_id,
												node_id, NODE_ID_NONE, notification.source_id, PACKET_LOST_CAPTURE_EFFECT, BER, current_sinr);
										SendLogicalNack(logical_nack);
									}
								}  else {
									
									LOGS(save_node_logs, node_logger.file,
										"%.15f;N%d;S%d;%s;%s Pure collision! Already receiving from N%d\n",
										SimTime(), node_id, node_state, LOG_D19, LOG_LVL4, receiving_from_node_id);
									loss_reason = PACKET_LOST_PURE_COLLISION;
									
									if(fabs(notification.timestamp - incoming_notification.timestamp) < MAX_DIFFERENCE_SAME_TIME) {
										loss_reason = PACKET_LOST_BO_COLLISION;
										if(!node_is_transmitter) {
											time_to_trigger = SimTime() + MAX_DIFFERENCE_SAME_TIME;
											trigger_NAV_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
										} else {
											printf("ALARM! Should not happen in downlink traffic\n");
										}
									}
									if(nack_activated){
										
										logical_nack = GenerateLogicalNack(notification.packet_type, nav_notification.packet_id,
												node_id, nav_notification.source_id, notification.source_id, loss_reason, BER, current_sinr);
										SendLogicalNack(logical_nack);
									}
								}
							} else { 
								if(nack_activated){
									LOGS(save_node_logs, node_logger.file,
											"%.15f;N%d;S%d;%s;%s Low strength signal received while already receiving from N%d\n",
										SimTime(), node_id, node_state, LOG_D20, LOG_LVL4, receiving_from_node_id);
									
									logical_nack = GenerateLogicalNack(notification.packet_type, receiving_from_node_id,
											node_id, notification.source_id, NODE_ID_NONE, PACKET_LOST_LOW_SIGNAL_AND_RX, BER, current_sinr);
									SendLogicalNack(logical_nack);
								}
							}
							break;
						}
					}

				} else {	





					
					ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
						incoming_notification, node_state, power_received_per_node, &channel_power);

					
					current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

					LOGS(save_node_logs, node_logger.file,
						"%.15f;N%d;S%d;%s;%s P[%d] = %f dBm - P_st = %f dBm - P_if = %f dBm - current_sinr = %.2f dBm\n",
						SimTime(), node_id, node_state, LOG_D08, LOG_LVL5, channel_max_intereference,
						ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
						ConvertPower(PW_TO_DBM, power_rx_interest),
						ConvertPower(PW_TO_DBM, max_pw_interference),
						ConvertPower(LINEAR_TO_DB, current_sinr));

					
					if (spatial_reuse_enabled && txop_sr_identified) {
						loss_reason = IsPacketLost(current_primary_channel, incoming_notification, notification,
							current_sinr, capture_effect, current_obss_pd_threshold,
							power_rx_interest, constant_per, node_id, capture_effect_model);
					} else {
						loss_reason = IsPacketLost(current_primary_channel, incoming_notification, notification,
							current_sinr, capture_effect, current_pd, power_rx_interest, constant_per, node_id, capture_effect_model);
					}

					
					

					LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s loss_reason = %d\n",
						SimTime(), node_id, node_state, LOG_D19, LOG_LVL4, loss_reason);

					if(loss_reason != PACKET_NOT_LOST) { 	

						switch(capture_effect_model) {

							case CE_DEFAULT:{
								
								LOGS(save_node_logs, node_logger.file,
									"%.15f;N%d;S%d;%s;%s Collision by interferences!\n",
									SimTime(), node_id, node_state, LOG_D19, LOG_LVL4);

								 
								if(node_state == STATE_RX_RTS && notification.packet_type == PACKET_TYPE_RTS){
									if(fabs(notification.timestamp - incoming_notification.timestamp) < MAX_DIFFERENCE_SAME_TIME){
										loss_reason = PACKET_LOST_BO_COLLISION;
									}
								}
								
								if (nack_activated) {
									logical_nack = GenerateLogicalNack(incoming_notification.packet_type,
										incoming_notification.packet_id, node_id, incoming_notification.source_id,
										NODE_ID_NONE, loss_reason, BER, current_sinr);
									SendLogicalNack(logical_nack);
								}
								RestartNode(FALSE);
								break;
							}

							case CE_IEEE_802_11:{
								int capture_effect_condition = power_received_per_node[notification.source_id] >
									power_received_per_node[receiving_from_node_id] + capture_effect;
								if (capture_effect_condition) {
									loss_reason = PACKET_LOST_CAPTURE_EFFECT;
									printf("Node %d was in state RX (from %d), and a new notification arrived from %d:\n",
									        node_id, receiving_from_node_id, notification.source_id);
									printf("	* New RSSI: %f\n", power_received_per_node[notification.source_id]);
									printf("	* Old RSSI: %f:\n", power_received_per_node[receiving_from_node_id]);
									printf("	* CE: %f:\n", capture_effect);
									printf("	* loss_reason: %d:\n", loss_reason);
									if(nack_activated){
									
									logical_nack = GenerateLogicalNack(notification.packet_type, nav_notification.packet_id,
										node_id, nav_notification.source_id, notification.source_id, loss_reason, BER, current_sinr);
									SendLogicalNack(logical_nack);
									}
									RestartNode(FALSE);
								}
								break;
							}
						}
					}
				}

                
                if (node_type == NODE_TYPE_STA) {
                    aggregate_sinr = aggregate_sinr +  current_sinr;
                    num_sinr_measurements = num_sinr_measurements + 1;
                }



































				break;
			}

			






			case STATE_WAIT_ACK:{

				if(notification.destination_id == node_id){	

					power_rx_interest = power_received_per_node[notification.source_id];
					incoming_notification = notification;




					if(notification.packet_type == PACKET_TYPE_ACK){	

						
						ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
							incoming_notification, node_state, power_received_per_node, &channel_power);

						
						current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

						
						loss_reason = IsPacketLost(current_primary_channel, incoming_notification, notification,
								current_sinr, capture_effect, current_pd,
								power_rx_interest, constant_per, node_id, capture_effect_model);

						if(loss_reason != PACKET_NOT_LOST
								&& loss_reason != PACKET_LOST_OUTSIDE_CH_RANGE) {	

							LOGS(save_node_logs, node_logger.file,
									"%.15f;N%d;S%d;%s;%s Reception of notification %d from N%d CANNOT be started because of reason %d\n",
									SimTime(), node_id, node_state, LOG_D15, LOG_LVL4, notification.packet_id,
									notification.source_id, loss_reason);

							if(nack_activated){
								
								logical_nack = GenerateLogicalNack(incoming_notification.packet_type, incoming_notification.packet_id,
									node_id, receiving_from_node_id, NODE_ID_NONE, loss_reason, BER, current_sinr);
								SendLogicalNack(logical_nack);
							}

							

						} else {	

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Reception of ACK %d from N%d CAN be started\n",
								SimTime(), node_id, node_state, LOG_D16, LOG_LVL4, notification.packet_id, notification.source_id);

							
							trigger_ACK_timeout.Cancel();
							node_state = STATE_RX_ACK;
							receiving_from_node_id = notification.source_id;
							receiving_packet_id = notification.packet_id;










						}

					}  else {	
						LOGS(save_node_logs, node_logger.file,
							"%.15f;N%d;S%d;%s;%s Unexpected packet type received!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	


































				}
				break;
			}

			





			case STATE_WAIT_CTS:{

				if(notification.destination_id == node_id){	

					incoming_notification = notification;





					if(notification.packet_type == PACKET_TYPE_CTS){	

						power_rx_interest = power_received_per_node[notification.source_id];

						
						ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
							incoming_notification, node_state, power_received_per_node, &channel_power);

						
						current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);









						
						loss_reason = IsPacketLost(current_primary_channel, incoming_notification, notification,
							current_sinr, capture_effect, current_pd,
							power_rx_interest, constant_per, node_id, capture_effect_model);

						if(loss_reason != PACKET_NOT_LOST
								&& loss_reason != PACKET_LOST_OUTSIDE_CH_RANGE)  {	

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Reception of notification %d from N%d CANNOT be started because of reason %d\n",
								SimTime(), node_id, node_state, LOG_D15, LOG_LVL4, notification.packet_id,
								notification.source_id, loss_reason);

							if(nack_activated){
								
								logical_nack = GenerateLogicalNack(notification.packet_type, notification.packet_id,
										node_id, notification.source_id,
										NODE_ID_NONE, loss_reason, BER, current_sinr);
								SendLogicalNack(logical_nack);
							}

							

						} else {	

							LOGS(save_node_logs, node_logger.file,
									"%.15f;N%d;S%d;%s;%s Reception of CTS #%d from N%d CAN be started\n",
									SimTime(), node_id, node_state, LOG_D16, LOG_LVL4,
									notification.packet_id, notification.source_id);

							current_left_channel = notification.left_channel;
							current_right_channel = notification.right_channel;

							
							trigger_CTS_timeout.Cancel();
							node_state = STATE_RX_CTS;
							receiving_from_node_id = notification.source_id;
							receiving_packet_id = notification.packet_id;

							
							data_duration = notification.tx_info.data_duration;
							ack_duration = notification.tx_info.ack_duration;
							cts_duration = notification.tx_info.cts_duration;









						}

					}  else {	
						LOGS(save_node_logs, node_logger.file,
							"%.15f;N%d;S%d;%s;%s Unexpected packet type received!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	


































				}

				break;
			}

			




			case STATE_WAIT_DATA:{

				if(notification.destination_id == node_id){	

					power_rx_interest = power_received_per_node[notification.source_id];
					incoming_notification = notification;





					if(notification.packet_type == PACKET_TYPE_DATA){	

						
						ComputeMaxInterference(&max_pw_interference, &channel_max_intereference,
							incoming_notification, node_state, power_received_per_node, &channel_power);

						
						current_sinr = UpdateSINR(power_rx_interest, max_pw_interference);

						LOGS(save_node_logs, node_logger.file,
							"%.15f;N%d;S%d;%s;%s P[%d] = %f dBm - P_st = %f dBm - P_if = %f dBm - current_sinr = %.2f dBm\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5, channel_max_intereference,
							ConvertPower(PW_TO_DBM, channel_power[channel_max_intereference]),
							ConvertPower(PW_TO_DBM, power_rx_interest),
							ConvertPower(PW_TO_DBM, max_pw_interference),
							ConvertPower(LINEAR_TO_DB, current_sinr));

						
						loss_reason = IsPacketLost(current_primary_channel, incoming_notification, notification,
							current_sinr, capture_effect, current_pd,
							power_rx_interest, constant_per, node_id, capture_effect_model);

						if(loss_reason != PACKET_NOT_LOST
							&& loss_reason != PACKET_LOST_OUTSIDE_CH_RANGE)  {	

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Reception of notification %d from N%d CANNOT be started because of reason %d\n",
								SimTime(), node_id, node_state, LOG_D15, LOG_LVL4, notification.packet_id,
								notification.source_id, loss_reason);

							if(nack_activated){
								
								logical_nack = GenerateLogicalNack(notification.packet_type, notification.packet_id,
										node_id, notification.source_id,
										NODE_ID_NONE, loss_reason, BER, current_sinr);
								SendLogicalNack(logical_nack);
							}

						} else {	

							LOGS(save_node_logs, node_logger.file,
								"%.15f;N%d;S%d;%s;%s Reception of DATA %d from N%d CAN be started\n",
								SimTime(), node_id, node_state, LOG_D16, LOG_LVL4, notification.packet_id, notification.source_id);

							
							trigger_DATA_timeout.Cancel();
							node_state = STATE_RX_DATA;
							receiving_from_node_id = notification.source_id;
							receiving_packet_id = notification.packet_id;

							
							data_duration = notification.tx_info.data_duration;
							ack_duration = notification.tx_info.ack_duration;

						}

					}  else {	
						LOGS(save_node_logs, node_logger.file,
							"%.15f;N%d;S%d;%s;%s Unexpected packet type received!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	




				}

				




























				

				break;
			}

			case STATE_SLEEP:{
				
				break;
			}

			default:{
				printf("ERROR: %d is not a correct state\n", node_state);
				exit(EXIT_FAILURE);
				break;
			}
		}
	}

	
	if (node_id == 0 && channel_idle) {
		sum_time_channel_idle += (SimTime() - last_time_channel_is_idle);
		channel_idle = false;
	}

	
}
#line 2176 "node.h"
void compcxx_Node_23 :: InportSomeNodeFinishTX(Notification &notification){

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s InportSomeNodeFinishTX(): N%d to N%d (type %d)"
			" at range %d-%d "
			"- nodes transmitting: ",
		SimTime(), node_id, node_state, LOG_E00, LOG_LVL1,
		notification.source_id, notification.destination_id, notification.packet_type,
		notification.left_channel, notification.right_channel);

	
	nodes_transmitting[notification.source_id] = FALSE;
	if(save_node_logs) PrintOrWriteNodesTransmitting(WRITE_LOG, save_node_logs,
			print_node_logs, node_logger, total_nodes_number, nodes_transmitting);

	if(notification.source_id == node_id){	






	} else {	








		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Power sensed per channel BEFORE updating [dBm]: ",
			SimTime(), node_id, node_state, LOG_E18, LOG_LVL3);

		PrintOrWriteChannelPower(WRITE_LOG, save_node_logs, node_logger, print_node_logs,
					&channel_power);

		
		UpdateChannelsPower(&channel_power, notification, TX_FINISHED,
			central_frequency, path_loss_model, adjacent_channel_model, received_power_array[notification.source_id], node_id);

		
		
		int num_nodes_transmitting = 0;
		for(int i = 0; i < total_nodes_number; ++i){
			if(nodes_transmitting[i] == TRUE){
				++num_nodes_transmitting;
			}
		}
		if(num_nodes_transmitting == 0){
			for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){
				channel_power[i] = 0;
			}
		}
		
		

		


		if(spatial_reuse_enabled) {
			
			UpdateTypeOngoingTransmissions(type_ongoing_transmissions_sr,
				notification, bss_color, srg, 0);
		}
		

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Power sensed per channel [dBm]: ",
			SimTime(), node_id, node_state, LOG_E18, LOG_LVL3);

		PrintOrWriteChannelPower(WRITE_LOG, save_node_logs, node_logger, print_node_logs,
				&channel_power);

		
		UpdatePowerSensedPerNode(current_primary_channel, power_received_per_node, notification,
			central_frequency, path_loss_model, received_power_array[notification.source_id], TX_FINISHED);

		UpdateTimestamptChannelFreeAgain(timestampt_channel_becomes_free, &channel_power,
			current_pd, SimTime());
















		switch(node_state){

			


			case STATE_SENSING:{	

				if(node_is_transmitter) {
					if(!trigger_start_backoff.Active()
						&& !trigger_end_backoff.Active()){	

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s UNEXPECTED ERROR IN THE BACKOFF!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5);

						int resume (HandleBackoff(RESUME_TIMER, &channel_power, current_primary_channel, current_pd,
								buffer.QueueSize()));

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s P[%d] = %f dBm (%f)\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
							current_primary_channel, ConvertPower(PW_TO_DBM, channel_power[current_primary_channel]), channel_power[current_primary_channel]);

						if (resume) {	
							
							
							
							time_to_trigger = SimTime() + DIFS;
							
							trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));
							LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s BO will be resumed after DIFS at %.12f.\n",
								SimTime(), node_id, node_state, LOG_E11, LOG_LVL4,
								trigger_start_backoff.GetTime());


						} else {	
							LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s EIFS cannot be started.\n",
								SimTime(), node_id, node_state, LOG_E11, LOG_LVL4);
						}
					} else {	
						LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s BO was already active.\n",
								SimTime(), node_id, node_state, LOG_E11, LOG_LVL4);
					}
				}
				break;
			}

			





			case STATE_RX_DATA:{	

				if(notification.destination_id == node_id){ 	

					if(notification.packet_type == PACKET_TYPE_DATA){	

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Packet #%d reception from N%d is finished successfully.\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3, notification.packet_id,
							notification.source_id);

						
						node_state = STATE_TX_ACK;

						
						current_nav_time = ComputeNavTime(node_state, rts_duration, cts_duration, data_duration, ack_duration, SIFS);
						current_nav_time = FixTimeOffset(current_nav_time,13,12); 

						current_tx_duration = ack_duration;
						current_destination_id = notification.source_id;
						ack_notification = GenerateNotification(PACKET_TYPE_ACK, current_destination_id,
								notification.packet_id, notification.tx_info.num_packets_aggregated,
								notification.timestamp_generated, current_tx_duration);

                        
                        flag_change_in_tx_power = FALSE;

						if(backoff_type == BACKOFF_SLOTTED){
							ack_notification.tx_info.preoccupancy_duration = time_rand_value;
						}











						
						
						for(int c = current_left_channel; c <= current_right_channel; ++c){
							total_time_spectrum_per_channel[c] = total_time_spectrum_per_channel[c] + current_tx_duration;
						}
						

						
						time_to_trigger = SimTime() + SIFS;
						trigger_SIFS.Set(FixTimeOffset(time_to_trigger,13,12));

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s SIFS will be triggered in %.12f\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3,
							trigger_SIFS.GetTime());

					} else {	
						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Unexpected packet type transmission finished!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	

					LOGS(save_node_logs,node_logger.file,
						"%.15f;N%d;S%d;%s;%s Still noticing a packet transmission (#%d) from N%d.\n",
						SimTime(), node_id, node_state, LOG_E15, LOG_LVL3, notification.packet_id,
						notification.source_id);

				}

				break;
			}

			





			case STATE_RX_ACK:{	

				if(notification.destination_id == node_id){	

					if(notification.packet_type == PACKET_TYPE_ACK){	

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s ACK #%d reception from N%d is finished successfully.\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3, notification.packet_id,
							notification.source_id);

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s -------------------------------------\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL2);
						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s TRANSMISSION #%d SUCCESSFULLY FINISHED!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL2,
							data_packets_acked);
						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s -------------------------------------\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL2);

						
						++data_packets_acked;
						++data_packets_acked_per_sta[current_destination_id-node_id-1];

						current_tx_duration = current_tx_duration + (notification.tx_duration + SIFS);	

						
						
						
						for(int i = 0; i < limited_num_packets_aggregated; ++i){

							++data_frames_acked;
							++data_frames_acked_per_sta[current_destination_id-node_id-1];
							++num_delay_measurements;
							sum_delays = sum_delays + (SimTime() - buffer.GetFirstPacket().timestamp_generated);






							buffer.DelFirstPacket();

						}
						

						
						if(traffic_model == TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION) {

							for(int i = 0; i < max_num_packets_aggregated; ++i){
								new_packet = null_notification;
								new_packet.timestamp_generated = SimTime();
								new_packet.packet_id = last_packet_generated_id;
								buffer.PutPacket(new_packet);
								++last_packet_generated_id;
							}
						}

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Data packet/s removed from buffer (queue: %d/%d).\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3,
							buffer.QueueSize(), PACKET_BUFFER_SIZE);

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Handling contention window\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
						LOGS(save_node_logs,node_logger.file,
									"%.15f;N%d;S%d;%s;%s From CW = %d, b = %d, m = %d\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
							cw_current, cw_stage_current, cw_stage_max);
						
						
						HandleContentionWindow(
								cw_adaptation, RESET_CW, &cw_current, cw_min, &cw_stage_current, cw_stage_max);
						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s To CW = %d, b = %d, m = %d\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
							cw_current, cw_stage_current, cw_stage_max);
						


						
						RestartNode(FALSE);

					} else {	
						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Unexpected packet type transmission finished!\n",
							SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	

					LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Still receiving packet #%d reception from N%d.\n",
						SimTime(), node_id, node_state, LOG_E15, LOG_LVL3, incoming_notification.packet_id,
						incoming_notification.source_id);
				}

				break;
			}

			


			case STATE_TX_DATA:
			case STATE_TX_ACK:
			case STATE_WAIT_ACK:
			case STATE_TX_RTS:
			case STATE_TX_CTS:
			case STATE_WAIT_CTS:
			case STATE_WAIT_DATA:
			case STATE_NAV:{	
				break;
			}

			


			case STATE_RX_RTS:{

				if(notification.destination_id == node_id){	

					if(notification.packet_type == PACKET_TYPE_RTS){	

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s RTS #%d reception from N%d is finished successfully.\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3, notification.packet_id,
							notification.source_id);

						
						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Checking if CTS can be sent: P_sen = %f dBm, pd = %f dBm.\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3,
							ConvertPower(PW_TO_DBM, channel_power[current_primary_channel]),
							ConvertPower(PW_TO_DBM, current_pd));


						
						
						
						
						

						int CTS_transmission_possible = FALSE;

						GetChannelOccupancyByCCA(current_primary_channel, pifs_activated, channels_free, current_left_channel,
								current_right_channel, &channel_power, current_pd, timestampt_channel_becomes_free, SimTime(), PIFS);

						LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Channels founds free after RTS: ",
								SimTime(), node_id, node_state, LOG_F02, LOG_LVL3);

						PrintOrWriteChannelsFree(WRITE_LOG, save_node_logs, print_node_logs, node_logger,
							channels_free);

						GetTxChannels(channels_for_tx, current_dcb_policy, channels_free,
								current_left_channel, current_right_channel, current_primary_channel,
								NUM_CHANNELS_KOMONDOR, &channel_power, channel_aggregation_cca_model);

						LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Channels for transmitting after RTS: ",
								SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);

						PrintOrWriteChannelForTx(WRITE_LOG, save_node_logs, print_node_logs, node_logger,
							channels_for_tx);

						if(channels_for_tx[0] != TX_NOT_POSSIBLE){

							
							current_left_channel = GetFirstOrLastTrueElemOfArray(FIRST_TRUE_IN_ARRAY,
								channels_for_tx, NUM_CHANNELS_KOMONDOR);
							current_right_channel = GetFirstOrLastTrueElemOfArray(LAST_TRUE_IN_ARRAY,
								channels_for_tx, NUM_CHANNELS_KOMONDOR);

							CTS_transmission_possible = TRUE;

						} else{
							CTS_transmission_possible = FALSE;
						}


						

						if(CTS_transmission_possible){

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Channel(s) is (are) clear! Sending CTS to N%d (STATE = %d) ...\n",
								SimTime(), node_id, node_state, LOG_E14, LOG_LVL3, current_destination_id, node_state);

							node_state = STATE_TX_CTS;
							
							current_destination_id = notification.source_id;
							current_tx_duration = cts_duration;

							
							bits_ofdm_sym =  getNumberSubcarriers(current_right_channel - current_left_channel +1) *
								Mcs_array::modulation_bits[notification.modulation_id-1] *
								Mcs_array::coding_rates[notification.modulation_id-1] *
								IEEE_AX_SU_SPATIAL_STREAMS;

							ComputeFramesDuration(&rts_duration, &cts_duration, &data_duration, &ack_duration,
								num_channels_tx, notification.modulation_id, notification.tx_info.num_packets_aggregated,
								frame_length, bits_ofdm_sym);

							current_nav_time = ComputeNavTime(node_state, rts_duration, cts_duration, data_duration, ack_duration, SIFS);
							current_nav_time = FixTimeOffset(current_nav_time,13,12); 

							
							
							for(int c = current_left_channel; c <= current_right_channel; ++c){
								total_time_spectrum_per_channel[c] = total_time_spectrum_per_channel[c] + current_tx_duration;
							}
							

							time_to_trigger = SimTime() + SIFS;
							trigger_SIFS.Set(FixTimeOffset(time_to_trigger,13,12)); 

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s SIFS will be triggered in %.12f\n",
								SimTime(), node_id, node_state, LOG_E14, LOG_LVL3,
								trigger_SIFS.GetTime());

							cts_notification = GenerateNotification(PACKET_TYPE_CTS, current_destination_id,
								notification.packet_id, notification.tx_info.num_packets_aggregated,
								notification.timestamp_generated, notification.tx_info.total_tx_power);

                            
                            flag_change_in_tx_power = FALSE;












							
							
							if(backoff_type == BACKOFF_SLOTTED){
								cts_notification.tx_info.preoccupancy_duration = time_rand_value;
							}

						} else {
							

							LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s CTS TX NOT POSSIBLE\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);

							







							if(!node_is_transmitter) {
								time_to_trigger = SimTime() + MAX_DIFFERENCE_SAME_TIME;
								trigger_restart_sta.Set(FixTimeOffset(time_to_trigger,13,12));
							} else {
								RestartNode(FALSE);
							}
						}

					} else {	
						LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Unexpected packet type transmission finished!\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	

					LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Still receiving packet #%d reception from N%d.\n",
							SimTime(), node_id, node_state, LOG_E15, LOG_LVL3, incoming_notification.packet_id,
							incoming_notification.source_id);
				}

				break;
			}


			


			case STATE_RX_CTS:{

				if(notification.destination_id == node_id){	

					if(notification.packet_type == PACKET_TYPE_CTS){	

						LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s CTS #%d reception from N%d is finished successfully.\n",
								SimTime(), node_id, node_state, LOG_E14, LOG_LVL3,
								notification.packet_id, notification.source_id);

						node_state = STATE_TX_DATA;

						
						bits_ofdm_sym =  getNumberSubcarriers(current_right_channel - current_left_channel +1) *
							Mcs_array::modulation_bits[notification.modulation_id-1] *
							Mcs_array::coding_rates[notification.modulation_id-1] *
							IEEE_AX_SU_SPATIAL_STREAMS;

						ComputeFramesDuration(&rts_duration, &cts_duration, &data_duration, &ack_duration,
							num_channels_tx, notification.modulation_id, notification.tx_info.num_packets_aggregated,
							frame_length, bits_ofdm_sym);

						limited_num_packets_aggregated = notification.tx_info.num_packets_aggregated;

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s Transmitting DATA (N_agg = %d) in %d channels using modulation %d (%.0f bits per OFDM symbol ---> %.2f Mbps) \n",
							SimTime(), node_id, node_state, LOG_F04, LOG_LVL4, limited_num_packets_aggregated,
							(current_right_channel - current_left_channel + 1), current_modulation, bits_ofdm_sym,
							bits_ofdm_sym/IEEE_AX_OFDM_SYMBOL_GI32_DURATION * pow(10,-6));

						
						current_nav_time = ComputeNavTime(node_state, rts_duration, cts_duration, data_duration, ack_duration, SIFS);
						current_nav_time = FixTimeOffset(current_nav_time,13,12); 

						
						current_destination_id = notification.source_id;

						current_tx_duration = data_duration;	
						time_to_trigger = SimTime() + SIFS;

						
						
						for(int c = current_left_channel; c <= current_right_channel; ++c){
							total_time_spectrum_per_channel[c] = total_time_spectrum_per_channel[c] + current_tx_duration;
						}
						

						trigger_SIFS.Set(FixTimeOffset(time_to_trigger,13,12));

						LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s SIFS will be triggered in %.12f\n",
							SimTime(), node_id, node_state, LOG_E14, LOG_LVL3,
							trigger_SIFS.GetTime());

						data_notification = GenerateNotification(PACKET_TYPE_DATA, current_destination_id,
								notification.packet_id, notification.tx_info.num_packets_aggregated,
								notification.timestamp_generated, current_tx_duration);

						
                        flag_change_in_tx_power = FALSE;

						if(backoff_type == BACKOFF_SLOTTED){
							data_notification.tx_info.preoccupancy_duration = time_rand_value;
						}












					} else {	
						LOGS(save_node_logs,node_logger.file,
								"%.15f;N%d;S%d;%s;%s Unexpected packet type transmission finished!\n",
								SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
					}

				} else {	

					LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Still receiving packet #%d reception from N%d.\n",
						SimTime(), node_id, node_state, LOG_E15, LOG_LVL3, incoming_notification.packet_id,
						incoming_notification.source_id);
				}

				break;
			}

			case STATE_SLEEP:{
				
				break;
			}

			default:{
				printf("ERROR: %d is not a correct state\n", node_state);
				exit(EXIT_FAILURE);
				break;
			}
		}
	}

	
	if (node_id == 0) {
		int num_nodes_transmitting = 0;
		for(int i = 0; i < total_nodes_number; ++i){
			if(nodes_transmitting[i] == TRUE){
				++ num_nodes_transmitting;
			}
		}
		
		if (num_nodes_transmitting == 0) {
			
			last_time_channel_is_idle = SimTime();
			channel_idle = true;
		}
	}

	
}
#line 2823 "node.h"
void compcxx_Node_23 :: InportNackReceived(LogicalNack &logical_nack){

	int nack_reason;






	
	if(logical_nack.source_id != node_id &&
			(node_id == logical_nack.node_id_a || node_id == logical_nack.node_id_b)){

		LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s NACK of packet #%d received from N%d sent to a:N%d (and b:N%d) with reason %d\n",
				SimTime(), node_id, node_state, LOG_H00, LOG_LVL2, logical_nack.packet_id, logical_nack.source_id,
				logical_nack.node_id_a, logical_nack.node_id_b, logical_nack.loss_reason);

		
		nack_reason = ProcessNack(logical_nack, node_id, node_logger, node_state, save_node_logs,
			SimTime(), nacks_received, total_nodes_number, nodes_transmitting);

		if(nack_reason == PACKET_LOST_BO_COLLISION){
			++ rts_lost_slotted_bo;

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s ++++++++++++++++++++++++++++++++\n",
				SimTime(), node_id, node_state, LOG_H00, LOG_LVL2);

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s rts_lost_slotted_bo ++\n",
				SimTime(), node_id, node_state, LOG_H00, LOG_LVL2);

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s ++++++++++++++++++++++++++++++++\n",
				SimTime(), node_id, node_state, LOG_H00, LOG_LVL2);
		}

	} else {	






	}

	
}






#line 2877 "node.h"
void compcxx_Node_23 :: InportMCSRequestReceived(Notification &notification){

	if(notification.destination_id == node_id) {	

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s MCS request received from N%d\n",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL1, notification.source_id);









		
		if (notification.tx_info.flag_change_in_tx_power) {
			received_power_array[notification.source_id] =
				ComputePowerReceived(distances_array[notification.source_id],
				notification.tx_info.tx_power, central_frequency, path_loss_model);
		}

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s I am at distance: %.2f m (sensing P_rx = %.2f dBm)\n",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL2,
			distances_array[notification.source_id], ConvertPower(PW_TO_DBM,
			received_power_array[notification.source_id]));

		
		SelectMCSResponse(mcs_response, received_power_array[notification.source_id]);

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s mcs_response for 1, 2, 4 and 8 channels: ",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL3);

		PrintOrWriteArrayInt(mcs_response, 4, WRITE_LOG, save_node_logs,
			print_node_logs, node_logger);

		
		Notification response_mcs  = GenerateNotification(PACKET_TYPE_MCS_RESPONSE, notification.source_id,
			-1, -1, -1, TX_DURATION_NONE);

		(outportAnswerTxModulation_f(response_mcs));

	} else { 	
		
	}
}






#line 2928 "node.h"
void compcxx_Node_23 :: InportMCSResponseReceived(Notification &notification){

	if(notification.destination_id == node_id) {	

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s InportMCSResponseReceived()\n",
				SimTime(), node_id, node_state, LOG_F00, LOG_LVL1);

		int ix_aux (current_destination_id - wlan.list_sta_id[0]);	

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s MCS per number of channels: ",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL2);

		
		for (int i = 0; i < NUM_OPTIONS_CHANNEL_LENGTH; ++i){
			if (spatial_reuse_enabled && txop_sr_identified &&
					notification.tx_info.modulation_schemes[i] == MODULATION_FORBIDDEN) {
				
				mcs_per_node[ix_aux][i] = MODULATION_BPSK_1_2;
			} else {
				mcs_per_node[ix_aux][i] = notification.tx_info.modulation_schemes[i];
			}
			LOGS(save_node_logs,node_logger.file, "%d ", mcs_per_node[ix_aux][i]);
		}






		double max_achievable_bits_ofdm_sym (getNumberSubcarriers(NUM_CHANNELS_KOMONDOR) *
			Mcs_array::modulation_bits[mcs_per_node[ix_aux][(int) log2(NUM_CHANNELS_KOMONDOR)]-1] *
			Mcs_array::coding_rates[mcs_per_node[ix_aux][(int) log2(NUM_CHANNELS_KOMONDOR)]-1] *
			IEEE_AX_SU_SPATIAL_STREAMS);

		double max_achievable_throughput (max_achievable_bits_ofdm_sym / IEEE_AX_OFDM_SYMBOL_GI32_DURATION);

		
		performance_report.max_bound_throughput = max_achievable_throughput;

		LOGS(save_node_logs,node_logger.file, "\n");

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s max_achievable_throughput (%d - %d) = %.1f Mbps "
			"(%d channel/s: Y_sc = %d, MCS %d: Y_m = %d, Y_c = %.2f)\n",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
			min_channel_allowed, max_channel_allowed, max_achievable_throughput * pow(10,-6),
			max_channel_allowed - min_channel_allowed + 1,
			getNumberSubcarriers(current_right_channel - current_left_channel + 1),
			mcs_per_node[ix_aux][(int) log2(max_channel_allowed-min_channel_allowed + 1)]-1,
			Mcs_array::modulation_bits[mcs_per_node[ix_aux][(int) log2(max_channel_allowed-min_channel_allowed + 1)]-1],
			Mcs_array::coding_rates[mcs_per_node[ix_aux][(int) log2(max_channel_allowed-min_channel_allowed + 1)]-1]);
		

		
		if(mcs_per_node[ix_aux][0] == -1) {
			
			if(current_tx_power < ConvertPower(DBM_TO_PW,MAX_TX_POWER_DBM)) {


			} else {
				
				LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Unreachable node: transmissions to N%d are cancelled\n",
					SimTime(), node_id, node_state, LOG_G00, LOG_LVL3, current_destination_id);
				
			}
		}

	} else {	
		
	}
}





#line 3003 "node.h"
void compcxx_Node_23 :: InportNewPacketGenerated(){



	if(node_is_transmitter){

		if(buffer.QueueSize() == 0){
			
			timestamp_new_trial_started = SimTime();
		}

		if(traffic_model != TRAFFIC_POISSON_BURST) { 

			++ num_packets_generated;
			
			++ performance_report.num_packets_generated;

			if (buffer.QueueSize() < PACKET_BUFFER_SIZE) {

				
				new_packet = null_notification;
				new_packet.timestamp_generated = SimTime();
				new_packet.packet_id = last_packet_generated_id;
				buffer.PutPacket(new_packet);

				LOGS(save_node_logs,node_logger.file,
						"%.15f;N%d;S%d;%s;%s A new packet (id: %d) has been generated (queue: %d/%d)\n",
						SimTime(), node_id, node_state, LOG_F00, LOG_LVL4,
						new_packet.packet_id, buffer.QueueSize(), PACKET_BUFFER_SIZE);

				
				if(node_state == STATE_SENSING && buffer.QueueSize() == 1) {

					if(trigger_end_backoff.Active()) remaining_backoff =
							ComputeRemainingBackoff(backoff_type, trigger_end_backoff.GetTime() - SimTime());

					int resume (HandleBackoff(RESUME_TIMER, &channel_power, current_primary_channel, current_pd,
							buffer.QueueSize()));

					if (resume) {
						time_to_trigger = SimTime() + DIFS;
						trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));
					}

				}

			} else {
				
				LOGS(save_node_logs,node_logger.file,
					"%.15f;N%d;S%d;%s;%s A new packet (id: %d) has been dropped! (queue: %d/%d)\n",
					SimTime(), node_id, node_state, LOG_F00, LOG_LVL4,
					last_packet_generated_id, buffer.QueueSize(), PACKET_BUFFER_SIZE);
				++ num_packets_dropped;
				
				++ performance_report.num_packets_dropped;
			}

			++ last_packet_generated_id;

			

		} else {	

			++ num_bursts;

			int num_packets_generated_in_burst (burst_rate);

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s New traffic burst (#%d) generated %d packets\n",
				SimTime(), node_id, node_state, LOG_F00, LOG_LVL4,
				num_bursts,
				num_packets_generated_in_burst);

			num_packets_generated = num_packets_generated + num_packets_generated_in_burst;

			for(int i = 0; i < num_packets_generated_in_burst; ++i){

				if (buffer.QueueSize() < PACKET_BUFFER_SIZE) {

					
					Notification new_packet;
					new_packet.timestamp_generated = SimTime();
					new_packet.packet_id = last_packet_generated_id;
					buffer.PutPacket(new_packet);

					LOGS(save_node_logs,node_logger.file,
							"%.15f;N%d;S%d;%s;%s A new packet (id: %d) has been generated from burst %d (buffer queue: %d/%d)\n",
							SimTime(), node_id, node_state, LOG_F00, LOG_LVL4,
							new_packet.packet_id,
							num_bursts,
							buffer.QueueSize(),
							PACKET_BUFFER_SIZE);

					
					if(node_state == STATE_SENSING && buffer.QueueSize() == 1) {

						if(trigger_end_backoff.Active()) remaining_backoff =
								ComputeRemainingBackoff(backoff_type, trigger_end_backoff.GetTime() - SimTime());

						int resume (HandleBackoff(RESUME_TIMER, &channel_power, current_primary_channel,
							current_pd, buffer.QueueSize()));

						if (resume) {
							time_to_trigger = SimTime() + DIFS;
							trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));
						}

					}

				} else {  
					++num_packets_dropped;
				}

				++last_packet_generated_id;

			}

		} 

	}
}





#line 3128 "node.h"
void compcxx_Node_23 :: StartTransmission(trigger_t &){
	rts_notification.timestamp = SimTime();
	(outportSelfStartTX_f(rts_notification));
}





#line 3136 "node.h"
void compcxx_Node_23 :: EndBackoff(trigger_t &){

	LOGS(save_node_logs,node_logger.file, "\n----------------------------------------------------------\n");
	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s EndBackoff()\n",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL1);

	






	if (spatial_reuse_enabled) {
		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s txop_sr_identified = %d\n",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL1, txop_sr_identified);
		flag_change_in_tx_power = TRUE;
		if(txop_sr_identified) {
		
		current_tx_power_sr = next_tx_power_limit;
		
		for(int n = 0; n < wlan.num_stas; n++) {
			change_modulation_flag[n] = TRUE;
		}
	} else {
		
	}
	if(save_node_logs) fprintf(node_logger.file, "%.15f;N%d;S%d;%s;%s Intended values for the next TX: "
		"pd = %f dBm, Tx Power = %f dBm\n", SimTime(), node_id, node_state, LOG_F02, LOG_LVL3,
		ConvertPower(PW_TO_DBM, current_obss_pd_threshold), ConvertPower(PW_TO_DBM, current_tx_power_sr));
	}
	

	
	
	sum_waiting_time = sum_waiting_time + SimTime() - timestamp_new_trial_started;
	++num_average_waiting_time_measurements;
	
	trigger_NAV_timeout.Cancel();

	
	trigger_recover_cts_timeout.Cancel();

	
	for(int n = 0; n < wlan.num_stas; ++n) {
		current_destination_id = wlan.list_sta_id[n];
		
		if (change_modulation_flag[n]) {
			LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Requesting MCS to N%d\n",
				SimTime(), node_id, node_state, LOG_F02, LOG_LVL2, current_destination_id);
			RequestMCS();
		}
	}

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Allowed LEFT/RIGHT: %d - %d\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2, min_channel_allowed, max_channel_allowed);

	
	SelectDestination();

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Trying to start TX to STA N%d\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2, current_destination_id);

	
	++num_tx_init_tried;

	if (spatial_reuse_enabled && txop_sr_identified) {
		GetChannelOccupancyByCCA(current_primary_channel, pifs_activated, channels_free, min_channel_allowed,
			max_channel_allowed, &channel_power, current_obss_pd_threshold, timestampt_channel_becomes_free, SimTime(), PIFS);
	} else {
		GetChannelOccupancyByCCA(current_primary_channel, pifs_activated, channels_free, min_channel_allowed,
			max_channel_allowed, &channel_power, current_pd, timestampt_channel_becomes_free, SimTime(), PIFS);
	}

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s Power sensed per channel [dBm]: ",
		SimTime(), node_id, node_state, LOG_E18, LOG_LVL3);

	PrintOrWriteChannelPower(WRITE_LOG, save_node_logs, node_logger, print_node_logs,
		&channel_power);
















	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Channels founds free (mind PIFS if activated): ",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL3);

	PrintOrWriteChannelsFree(WRITE_LOG, save_node_logs, print_node_logs, node_logger,
		channels_free);

	
	int ix_mcs_per_node (current_destination_id - wlan.list_sta_id[0]);

	GetTxChannels(channels_for_tx, current_dcb_policy, channels_free,
			min_channel_allowed, max_channel_allowed, current_primary_channel,
			NUM_CHANNELS_KOMONDOR, &channel_power, channel_aggregation_cca_model);

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Channels for transmitting: ",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);

	PrintOrWriteChannelForTx(WRITE_LOG, save_node_logs, print_node_logs, node_logger,
		channels_for_tx);

	
	if(channels_for_tx[0] != TX_NOT_POSSIBLE) {
		

		
		node_state = STATE_TX_RTS;


		
		current_left_channel = GetFirstOrLastTrueElemOfArray(FIRST_TRUE_IN_ARRAY,
			channels_for_tx, NUM_CHANNELS_KOMONDOR);
		current_right_channel = GetFirstOrLastTrueElemOfArray(LAST_TRUE_IN_ARRAY,
			channels_for_tx, NUM_CHANNELS_KOMONDOR);

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Transmission is possible in range: %d - %d\n",
			SimTime(), node_id, node_state, LOG_F04, LOG_LVL3, current_left_channel, current_right_channel);

		int previous_num_channels = num_channels_tx;
		num_channels_tx = current_right_channel - current_left_channel + 1;
		++num_trials_tx_per_num_channels[(int)log2(num_channels_tx)];
		int ix_num_channels_used (log2(num_channels_tx));

		if(previous_num_channels != num_channels_tx) flag_change_in_tx_power = TRUE;

		
		current_modulation = mcs_per_node[ix_mcs_per_node][ix_num_channels_used];

		
		
		
		if(buffer.QueueSize() > max_num_packets_aggregated){
			current_num_packets_aggregated = max_num_packets_aggregated;
		} else {
			current_num_packets_aggregated = buffer.QueueSize();
		}

		
		bits_ofdm_sym =  getNumberSubcarriers(num_channels_tx) *
			Mcs_array::modulation_bits[current_modulation-1] *
			Mcs_array::coding_rates[current_modulation-1] *
			IEEE_AX_SU_SPATIAL_STREAMS;

		
		limited_num_packets_aggregated = findMaximumPacketsAggregated
			(current_num_packets_aggregated, frame_length, bits_ofdm_sym);

		

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Num. of packets to aggregate: %d/%d\n",
			SimTime(), node_id, node_state, LOG_F04, LOG_LVL4,
			limited_num_packets_aggregated, max_num_packets_aggregated);
		

		
		ComputeFramesDuration(&rts_duration, &cts_duration, &data_duration, &ack_duration,
			num_channels_tx, current_modulation, limited_num_packets_aggregated, frame_length, bits_ofdm_sym);











		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Transmitting (N_agg = %d) in %d channels using modulation %d (%.0f bits per OFDM symbol ---> %.2f Mbps) \n",
			SimTime(), node_id, node_state, LOG_F04, LOG_LVL4, limited_num_packets_aggregated,
			(int) pow(2, ix_num_channels_used), current_modulation, bits_ofdm_sym,
			bits_ofdm_sym/IEEE_AX_OFDM_SYMBOL_GI32_DURATION * pow(10,-6));

		if(spatial_reuse_enabled && txop_sr_identified) {
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s Using tx power = %f dBm \n",
				SimTime(), node_id, node_state, LOG_F04, LOG_LVL4,
				ConvertPower(PW_TO_DBM, current_tx_power_sr));
		} else {
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s Using tx power = %f dBm \n",
				SimTime(), node_id, node_state, LOG_F04, LOG_LVL4,
				ConvertPower(PW_TO_DBM, current_tx_power));
		}

		current_tx_duration = rts_duration;

		
		current_nav_time = ComputeNavTime(node_state, rts_duration, cts_duration, data_duration, ack_duration, SIFS);
		current_nav_time = FixTimeOffset(current_nav_time,13,12); 








		






		time_rand_value = 0;
		if(backoff_type == BACKOFF_SLOTTED){
			int rand_number (2 + rand() % (MAX_NUM_RAND_TIME-2));	
			time_rand_value = (double) rand_number * MAX_DIFFERENCE_SAME_TIME/MAX_NUM_RAND_TIME; 
			
			
			time_rand_value = FixTimeOffset(time_rand_value,13,12);
			current_nav_time = current_nav_time - time_rand_value;




		}

		
		Notification first_packet_buffer = buffer.GetFirstPacket();

		rts_notification = GenerateNotification(PACKET_TYPE_RTS, current_destination_id,
			first_packet_buffer.packet_id, limited_num_packets_aggregated,
			first_packet_buffer.timestamp_generated, current_tx_duration);

        
        flag_change_in_tx_power = FALSE;

        LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s -------------------------------------\n",
			SimTime(), node_id, node_state, LOG_D08, LOG_LVL2);
		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s TRANSMISSION #%d STARTED\n",
			SimTime(), node_id, node_state, LOG_D08, LOG_LVL2,
			rts_cts_sent);
		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s -------------------------------------\n",
			SimTime(), node_id, node_state, LOG_D08, LOG_LVL2);

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Transmission of RTS #%d started\n",
			SimTime(), node_id, node_state, LOG_F04, LOG_LVL3, rts_notification.packet_id);

		
		
		for(int c = current_left_channel; c <= current_right_channel; ++c){
			total_time_spectrum_per_channel[c] += current_tx_duration;
		}
		

		
		if(backoff_type == BACKOFF_SLOTTED){
			time_to_trigger = SimTime() + time_rand_value;
			trigger_preoccupancy.Set(FixTimeOffset(time_to_trigger,13,12));
			rts_notification.tx_info.preoccupancy_duration = time_rand_value;
		} else {
			(outportSelfStartTX_f(rts_notification));
		}

		time_to_trigger = SimTime() + current_tx_duration;






		trigger_toFinishTX.Set(FixTimeOffset(time_to_trigger,13,12));
		++rts_cts_sent;
		++rts_cts_sent_per_sta[current_destination_id-node_id-1];
		trigger_start_backoff.Cancel();	

	} else {	
		AbortRtsTransmission();
	}
	
}
#line 3435 "node.h"
void compcxx_Node_23 :: MyTxFinished(trigger_t &){




	switch(node_state){

		case STATE_TX_RTS:{		

			
			Notification notification = GenerateNotification(PACKET_TYPE_RTS, current_destination_id,
				rts_notification.packet_id, limited_num_packets_aggregated,
				rts_notification.timestamp_generated, TX_DURATION_NONE);

			(outportSelfFinishTX_f(notification));

			
			

			
			time_to_trigger = SimTime() + SIFS + notification.tx_info.cts_duration;

			trigger_CTS_timeout.Set(FixTimeOffset(time_to_trigger,13,12));

			node_state = STATE_WAIT_CTS;

			LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s RTS #%d tx finished. Waiting for CTS until %.12f\n",
				SimTime(), node_id, node_state, LOG_G00, LOG_LVL2,
				notification.packet_id, trigger_CTS_timeout.GetTime());

			break;
		}

		case STATE_TX_CTS:{		

			Notification notification = GenerateNotification(PACKET_TYPE_CTS, current_destination_id,
				cts_notification.packet_id, cts_notification.tx_info.num_packets_aggregated,
				cts_notification.timestamp_generated, TX_DURATION_NONE);

			(outportSelfFinishTX_f(notification));

			
			time_to_trigger = SimTime() + SIFS + TIME_OUT_EXTRA_TIME;
			trigger_DATA_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
			node_state = STATE_WAIT_DATA;

			LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s CTS %d tx finished. Waiting for DATA...\n",
				SimTime(), node_id, node_state, LOG_G00, LOG_LVL2, notification.packet_id);

			break;
		}

		case STATE_TX_DATA:{ 	

			Notification notification = GenerateNotification(PACKET_TYPE_DATA, current_destination_id,
				data_notification.packet_id, data_notification.tx_info.num_packets_aggregated,
				data_notification.timestamp_generated, TX_DURATION_NONE);

			(outportSelfFinishTX_f(notification));

			
			time_to_trigger = SimTime() + SIFS + TIME_OUT_EXTRA_TIME;
			trigger_ACK_timeout.Set(FixTimeOffset(time_to_trigger,13,12));
			node_state = STATE_WAIT_ACK;

			LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s DATA %d tx finished. Waiting for ACK...\n",
				SimTime(), node_id, node_state, LOG_G00, LOG_LVL2, notification.packet_id);

			break;
		}

		case STATE_TX_ACK:{		

			Notification notification = GenerateNotification(PACKET_TYPE_ACK, current_destination_id,
				ack_notification.packet_id, ack_notification.tx_info.num_packets_aggregated,
				ack_notification.timestamp_generated, TX_DURATION_NONE);

			(outportSelfFinishTX_f(notification));

			LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s ACK %d tx finished. Restarting node...\n",
				SimTime(), node_id, node_state, LOG_G00, LOG_LVL2, notification.packet_id);

			RestartNode(FALSE);

			break;
		}

		default:
			break;
	}

    
    flag_change_in_tx_power = FALSE;

	
}
#line 3535 "node.h"
void compcxx_Node_23 :: RequestMCS(){




	
	
	current_left_channel = current_primary_channel;
	current_right_channel = current_primary_channel;

	
	Notification request_modulation = GenerateNotification(PACKET_TYPE_MCS_REQUEST, current_destination_id,
		-1, -1, -1, TX_DURATION_NONE);

	request_modulation.tx_info.flag_change_in_tx_power = TRUE;

	(outportAskForTxModulation_f(request_modulation));

	int ix_aux (current_destination_id - wlan.list_sta_id[0]);	
	
	change_modulation_flag[ix_aux] = FALSE;

	if(first_time_requesting_mcs) {
		first_time_requesting_mcs = FALSE;
	}
	
}





#line 3566 "node.h"
void compcxx_Node_23 :: SelectDestination(){




	current_destination_id = PickRandomElementFromArray(wlan.list_sta_id, wlan.num_stas);
	
}


















#line 3591 "node.h"
Notification compcxx_Node_23 :: GenerateNotification(int packet_type, int destination_id, int packet_id,
	int num_packets_aggregated, double timestamp_generated, double tx_duration){

	Notification notification;

	notification.packet_id = packet_id;				
	notification.packet_type = packet_type;
	notification.source_id = node_id;
	notification.destination_id = destination_id;
	notification.tx_duration = tx_duration;
	notification.tx_info.total_tx_power = current_tx_power;

	if(first_time_requesting_mcs) {
		notification.left_channel = current_primary_channel;
		notification.right_channel = current_primary_channel;
		first_time_requesting_mcs = FALSE;
	} else {
		notification.left_channel = current_left_channel;
		notification.right_channel = current_right_channel;
	}

	notification.frame_length = -1;
	notification.modulation_id = current_modulation;
	notification.timestamp = SimTime();
	notification.timestamp_generated = timestamp_generated;

	
	num_channels_tx = current_right_channel - current_left_channel + 1;

	if (spatial_reuse_enabled && txop_sr_identified) {
		notification.tx_info = GenerateTxInfo(num_packets_aggregated, data_duration,
			ack_duration, rts_duration, cts_duration, current_tx_power_sr, num_channels_tx,
			bits_ofdm_sym, x, y, z, flag_change_in_tx_power);
	} else {
		notification.tx_info = GenerateTxInfo(num_packets_aggregated, data_duration,
			ack_duration, rts_duration, cts_duration, current_tx_power, num_channels_tx,
			bits_ofdm_sym, x, y, z, flag_change_in_tx_power);
	}

	
	notification.tx_info.bss_color = bss_color;
	notification.tx_info.srg = srg;




	switch(packet_type){

		case PACKET_TYPE_DATA:{
			notification.frame_length = frame_length;
			notification.tx_info.nav_time = current_nav_time;
			break;
		}

		case PACKET_TYPE_ACK:{
			notification.frame_length = IEEE_AX_ACK_LENGTH;
			notification.tx_info.nav_time = current_nav_time;
			break;
		}

		case PACKET_TYPE_MCS_REQUEST:{
			
			break;
		}

		case PACKET_TYPE_MCS_RESPONSE:{
			for(int i = 0; i < 4; ++i) {
				notification.tx_info.modulation_schemes[i] = mcs_response[i];
			}
			break;
		}

		case PACKET_TYPE_RTS:{
			notification.frame_length = IEEE_AX_RTS_LENGTH;
			notification.tx_info.nav_time = current_nav_time;
			break;
		}

		case PACKET_TYPE_CTS:{
			notification.frame_length = IEEE_AX_CTS_LENGTH;
			notification.tx_info.nav_time = current_nav_time;
			break;
		}

		default:{
			printf("ERROR: Packet type unknown\n");
			exit(EXIT_FAILURE);
			break;
		}
	}

	return notification;

}






#line 3690 "node.h"
void compcxx_Node_23 :: SendLogicalNack(LogicalNack logical_nack){

	(outportSendLogicalNack_f(logical_nack));

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s NACK of packet type %d sent to a:N%d (and b:N%d) with reason %d\n",
		SimTime(), node_id, node_state, LOG_I00, LOG_LVL4, logical_nack.packet_type,
		logical_nack.node_id_a, logical_nack.node_id_b, logical_nack.loss_reason);

}





#line 3704 "node.h"
void compcxx_Node_23 :: SendResponsePacket(trigger_t &){

	switch(node_state){

		case STATE_TX_ACK:{

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s SIFS completed after receiving DATA, sending ACK...\n",
				SimTime(), node_id, node_state, LOG_I00, LOG_LVL3);

			(outportSelfStartTX_f(ack_notification));

			
			
			time_to_trigger = SimTime() + current_tx_duration;
			trigger_toFinishTX.Set(FixTimeOffset(time_to_trigger,13,12));

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s TruncateDouble = %.12f - current_tx_duration = %.12f - trigger_toFinishTX = %.12f\n",
				SimTime(), node_id, node_state, LOG_I00, LOG_LVL3,
				TruncateDouble(SimTime() + FEMTO_VALUE,12), current_tx_duration, trigger_toFinishTX.GetTime());

			break;
		}

		case STATE_TX_CTS:{
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s SIFS completed after receiving RTS, sending CTS (duration = %f)\n",
				SimTime(), node_id, node_state, LOG_I00, LOG_LVL3, current_tx_duration);
			(outportSelfStartTX_f(cts_notification));

			time_to_trigger = SimTime() + current_tx_duration;
			trigger_toFinishTX.Set(FixTimeOffset(time_to_trigger,13,12));
			break;
		}

		case STATE_TX_DATA:{
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s SIFS completed after receiving CTS, sending DATA...\n",
				SimTime(), node_id, node_state, LOG_I00, LOG_LVL3);
			(outportSelfStartTX_f(data_notification));
			time_to_trigger = SimTime() + current_tx_duration;
			trigger_toFinishTX.Set(FixTimeOffset(time_to_trigger,13,12));
			++data_packets_sent;
			++data_packets_sent_per_sta[current_destination_id-node_id-1];
			
			++performance_report.data_packets_sent;
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s Data TX will be finished at %.15f\n",
				SimTime(), node_id, node_state, LOG_I00, LOG_LVL3,
				trigger_toFinishTX.GetTime());
			break;
		}
	}
}





#line 3763 "node.h"
void compcxx_Node_23 :: AbortRtsTransmission(){

	num_tx_init_not_possible ++;
	
	remaining_backoff = ComputeBackoff(pdf_backoff, cw_current, backoff_type);
	expected_backoff += remaining_backoff;
	num_new_backoff_computations++;
	node_state = STATE_SENSING;

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Transmission is NOT possible\n",
		SimTime(), node_id, node_state, LOG_F03, LOG_LVL3);

}











#line 3786 "node.h"
void compcxx_Node_23 :: AckTimeout(trigger_t &){

	current_tx_duration += SIFS + TIME_OUT_EXTRA_TIME;		

	for(int c = current_left_channel; c <= current_right_channel; ++c){
		total_time_transmitting_per_channel[c] += SIFS + TIME_OUT_EXTRA_TIME;
	}

	handlePacketLoss(PACKET_TYPE_DATA, total_time_lost_in_num_channels, total_time_lost_per_channel,
		data_packets_lost, rts_cts_lost, &data_packets_lost_per_sta, &rts_cts_lost_per_sta, current_right_channel,
		current_left_channel,current_tx_duration, node_id, current_destination_id);

	
	
	performance_report.total_time_lost_in_num_channels[(int)log2(current_right_channel - current_left_channel + 1)] += current_tx_duration;
	for(int c = current_left_channel; c <= current_right_channel; ++c){
		performance_report.total_time_lost_per_channel[c] += current_tx_duration;
	}
	performance_report.data_packets_lost++;

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s  ACK TIMEOUT! Data packet %d lost\n",
		SimTime(), node_id, node_state, LOG_D17, LOG_LVL4,
		packet_id);

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s Handling contention window\n",
		SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s From CW = %d, b = %d, m = %d\n",
		SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
		cw_current, cw_stage_current, cw_stage_max);
	
	HandleContentionWindow(
		cw_adaptation, INCREASE_CW, &cw_current, cw_min, &cw_stage_current, cw_stage_max);

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s To CW = %d, b = %d, m = %d\n",
		SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
		cw_current, cw_stage_current, cw_stage_max);

	RestartNode(TRUE);
}





#line 3832 "node.h"
void compcxx_Node_23 :: CtsTimeout(trigger_t &){

	handlePacketLoss(PACKET_TYPE_CTS, total_time_lost_in_num_channels, total_time_lost_per_channel,
		data_packets_lost, rts_cts_lost, &data_packets_lost_per_sta, &rts_cts_lost_per_sta, current_right_channel,
		current_left_channel,current_tx_duration, node_id, current_destination_id);

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s ---------------------------------------------\n",
		SimTime(), node_id, node_state, LOG_D17, LOG_LVL1);
	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s CTS TIMEOUT! RTS-CTS packet lost\n",
		SimTime(), node_id, node_state, LOG_D17, LOG_LVL2);

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s Handling contention window\n",
		SimTime(), node_id, node_state, LOG_D08, LOG_LVL4);
	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s From CW = %d, b = %d, m = %d\n",
		SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
		cw_current, cw_stage_current, cw_stage_max);
	
	HandleContentionWindow(
		cw_adaptation, INCREASE_CW, &cw_current, cw_min, &cw_stage_current, cw_stage_max);

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s To CW = %d, b = %d, m = %d\n",
		SimTime(), node_id, node_state, LOG_D08, LOG_LVL5,
		cw_current, cw_stage_current, cw_stage_max);

	
	total_time_transmitting_in_num_channels[(int)log2(current_right_channel - current_left_channel + 1)] += current_tx_duration;
	performance_report.total_time_transmitting_in_num_channels[(int)log2(current_right_channel - current_left_channel + 1)] += current_tx_duration;
	for(int c = current_left_channel; c <= current_right_channel; ++c){
		total_time_transmitting_per_channel[c] += current_tx_duration;
		performance_report.total_time_transmitting_per_channel[c] += current_tx_duration;
		performance_report.total_time_lost_per_channel[c] += current_tx_duration;
	}

	RestartNode(TRUE);
}





#line 3874 "node.h"
void compcxx_Node_23 :: DataTimeout(trigger_t &){

	handlePacketLoss(PACKET_TYPE_CTS, total_time_lost_in_num_channels, total_time_lost_per_channel,
		data_packets_lost, rts_cts_lost, &data_packets_lost_per_sta, &rts_cts_lost_per_sta, current_right_channel,
		current_left_channel,current_tx_duration, node_id, current_destination_id);

	performance_report.total_time_lost_in_num_channels[(int)log2(current_right_channel - current_left_channel + 1)] += current_tx_duration;

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s DATA TIMEOUT! RTS-CTS packet lost\n",
		SimTime(), node_id, node_state, LOG_D17, LOG_LVL4);

	

	RestartNode(TRUE);
}





#line 3893 "node.h"
void compcxx_Node_23 :: NavTimeout(trigger_t &){

	LOGS(save_node_logs,node_logger.file, "\n **********************************************************************\n");

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s NAV TIMEOUT!\n",
		SimTime(), node_id, node_state, LOG_D17, LOG_LVL1);

	time_in_nav = time_in_nav + (SimTime() - last_time_not_in_nav);

	if(node_is_transmitter){

		
		if (flag_apply_new_configuration) {
			ApplyNewConfiguration(new_configuration);
		}
		flag_apply_new_configuration = FALSE; 

		node_state = STATE_SENSING;

		int resume (HandleBackoff(RESUME_TIMER, &channel_power, current_primary_channel,
			current_pd, buffer.QueueSize()));

		
		if (resume) {

			time_to_trigger = SimTime() + DIFS - TIME_OUT_EXTRA_TIME;

			trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s Starting new DIFS to finsih in %.12f\n",
				SimTime(), node_id, node_state, LOG_D17, LOG_LVL3,
				trigger_start_backoff.GetTime());

		} else {
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s New DIFS cannot be started\n",
				SimTime(), node_id, node_state, LOG_D17, LOG_LVL3);
		}

	} else {

		RestartNode(TRUE);

	}

}











#line 3951 "node.h"
void compcxx_Node_23 :: PauseBackoff(){

	if(trigger_start_backoff.Active()){
		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Cancelling DIFS. BO still frozen at %.9f (%.2f slots)\n",
			SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
			remaining_backoff * pow(10,6), remaining_backoff / SLOT_TIME);

		trigger_start_backoff.Cancel();
	} else {

		if(trigger_end_backoff.Active()){	

			remaining_backoff = ComputeRemainingBackoff(backoff_type, trigger_end_backoff.GetTime() - SimTime());

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s BO is active. Freezing it from %.9f (%.2f slots) to %.9f (%.2f slots)\n",
				SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
				(trigger_end_backoff.GetTime() - SimTime()) * pow(10,6),
				(trigger_end_backoff.GetTime() - SimTime())/SLOT_TIME,
				remaining_backoff * pow(10,6), remaining_backoff/SLOT_TIME);












			trigger_end_backoff.Cancel();

		} else {	

			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s Backoff is NOT active - it is already frozen at %.9f us (%.2f slots)\n",
				SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
				remaining_backoff * pow(10,6), remaining_backoff / SLOT_TIME);

			trigger_end_backoff.Cancel(); 

		}

	}
}





#line 4002 "node.h"
void compcxx_Node_23 :: ResumeBackoff(trigger_t &){




	time_to_trigger = SimTime() + remaining_backoff;

	trigger_end_backoff.Set(FixTimeOffset(time_to_trigger,13,12));

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Resuming backoff in %.9f us (%.2f slots)\n",
		SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
		(remaining_backoff * pow(10,6)), (remaining_backoff / (double) SLOT_TIME));







}











#line 4032 "node.h"
void compcxx_Node_23 :: SpatialReuseOpportunityEnds(trigger_t &){
	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s SpatialReuseOpportunityEnds()\n",
		SimTime(), node_id, node_state, LOG_F00, LOG_LVL2);
	
	current_obss_pd_threshold = current_pd;
	txop_sr_identified = FALSE;
	current_tx_power_sr = current_tx_power;
	flag_change_in_tx_power = FALSE;
	
	for(int n = 0; n < wlan.num_stas; ++n) {
		change_modulation_flag[n] = true;
	}

	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s current_obss_pd_threshold = %f\n",
		SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
		ConvertPower(PW_TO_DBM,current_obss_pd_threshold));
	LOGS(save_node_logs,node_logger.file,
		"%.15f;N%d;S%d;%s;%s current_tx_power_sr = %f\n",
		SimTime(), node_id, node_state, LOG_F00, LOG_LVL3,
		ConvertPower(PW_TO_DBM,current_tx_power_sr));

}





#line 4060 "node.h"
void compcxx_Node_23 :: InportRequestSpatialReuseConfiguration() {
	
	spatial_reuse_configuration.spatial_reuse_enabled = spatial_reuse_enabled;
	spatial_reuse_configuration.bss_color = bss_color;
	spatial_reuse_configuration.srg = srg;
	spatial_reuse_configuration.non_srg_obss_pd = non_srg_obss_pd;
	spatial_reuse_configuration.srg_obss_pd = srg_obss_pd;
	
	(outportNewSpatialReuseConfiguration_f(spatial_reuse_configuration));
}






#line 4075 "node.h"
void compcxx_Node_23 :: InportNewSpatialReuseConfiguration(Configuration &received_configuration) {
	spatial_reuse_enabled = received_configuration.spatial_reuse_enabled;
	bss_color = received_configuration.bss_color;
	srg = received_configuration.srg;
	non_srg_obss_pd = received_configuration.non_srg_obss_pd;
	srg_obss_pd = received_configuration.srg_obss_pd;
}











#line 4092 "node.h"
void compcxx_Node_23 :: GenerateConfiguration(){

	
	Capabilities capabilities;
	capabilities.node_code = node_code.c_str();
	capabilities.node_id = node_id;
	capabilities.x = x;
	capabilities.y = y;
	capabilities.z = z;
	capabilities.node_type = node_type;
	capabilities.primary_channel = current_primary_channel;
	capabilities.min_channel_allowed = min_channel_allowed;
	capabilities.max_channel_allowed = max_channel_allowed;
	capabilities.num_channels_allowed = num_channels_allowed;
	capabilities.tx_power_default = tx_power_default;
	capabilities.sensitivity_default = sensitivity_default;
	capabilities.current_max_bandwidth = current_max_bandwidth;

	
	configuration.capabilities = capabilities;

	configuration.timestamp = SimTime();
	configuration.selected_primary_channel = current_primary_channel;
	configuration.selected_pd = current_pd;
	configuration.selected_tx_power = current_tx_power;
	configuration.selected_max_bandwidth = current_max_bandwidth;
	configuration.frame_length = frame_length;
	configuration.max_num_packets_aggregated = max_num_packets_aggregated;

	
	configuration.spatial_reuse_enabled = spatial_reuse_enabled;
	configuration.bss_color = bss_color;
	configuration.srg = srg;
	configuration.non_srg_obss_pd = non_srg_obss_pd;
	configuration.srg_obss_pd = srg_obss_pd;

}





#line 4133 "node.h"
void compcxx_Node_23 :: UpdatePerformanceMeasurements(){

	

	
	performance_report.throughput =
		(((double)(performance_report.data_packets_sent -
		performance_report.data_packets_lost) * frame_length
		* limited_num_packets_aggregated)) / (SimTime()-performance_report.timestamp);

	
	for (int i = 0 ; i < total_wlans_number; ++ i) {
		performance_report.rssi_list[i] = max_received_power_in_ap_per_wlan[i];
		performance_report.max_received_power_in_ap_per_wlan[i] = max_received_power_in_ap_per_wlan[i];
	}

	
	if(node_type == NODE_TYPE_AP) UpdateRssiPerSta(wlan, rssi_per_sta, received_power_array, total_nodes_number);
	performance_report.rssi_list_per_sta = rssi_per_sta;

	
	double successful_occupancy(0.0);
	double total_occupancy(0.0);
	for(int n = 0; n < num_channels_allowed; ++n){
		successful_occupancy += ((performance_report.total_time_transmitting_in_num_channels[n] -
			performance_report.total_time_lost_in_num_channels[n])) / (SimTime() - performance_report.timestamp);
		total_occupancy += performance_report.total_time_transmitting_in_num_channels[n] / (SimTime() - performance_report.timestamp);
	}
	performance_report.successful_channel_occupancy = successful_occupancy;
	performance_report.total_channel_occupancy = total_occupancy;




	performance_report.num_stas = wlan.num_stas;

}





#line 4174 "node.h"
void compcxx_Node_23 :: InportReceivingRequestFromAgent() {



	LOGS(save_node_logs, node_logger.file, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s InportReceivingRequestFromAgent()\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);

	
	GenerateConfiguration();

	
	UpdatePerformanceMeasurements();

	
	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Sending information to the Agent\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);

	(outportAnswerToAgent_f(configuration, performance_report));

	
	RestartPerformanceMetrics(&performance_report, SimTime(), num_channels_allowed);

	LOGS(save_node_logs,node_logger.file, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");

}






#line 4205 "node.h"
void compcxx_Node_23 :: InportReceiveConfigurationFromAgent(Configuration &received_configuration) {

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s New configuration received from the Agent\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);

	if(!flag_apply_new_configuration) {
		new_configuration = received_configuration;
		if(save_node_logs) WriteNodeConfiguration(node_logger, header_str);
		if(save_node_logs) WriteReceivedConfiguration(node_logger, header_str, new_configuration);
		
		flag_apply_new_configuration = TRUE;
		if(node_state == STATE_SENSING) {
			
			RestartNode(FALSE);
		}
	} else {
		printf("%.15f;N%d Received a new configuration before applying the last one!\n", SimTime(), node_id);
	}

}






#line 4230 "node.h"
void compcxx_Node_23 :: ApplyNewConfiguration(Configuration &new_configuration) {
	
	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Applying the new received configuration\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);
	
	current_primary_channel = new_configuration.selected_primary_channel;
	current_pd = new_configuration.selected_pd;
	if(current_tx_power != new_configuration.selected_tx_power) flag_change_in_tx_power = TRUE;
	current_tx_power = new_configuration.selected_tx_power;
	current_max_bandwidth = new_configuration.selected_max_bandwidth;

	
	GetMinAndMaxAllowedChannels(min_channel_allowed, max_channel_allowed,
			current_primary_channel, current_max_bandwidth);

	non_srg_obss_pd = new_configuration.non_srg_obss_pd;
	
	if (node_type == NODE_TYPE_AP) {
		for(int n = 0; n < wlan.num_stas; ++n) {
			change_modulation_flag[n] = TRUE;
		}
		
		BroadcastNewConfigurationToStas(new_configuration);
	}
	
	if(save_node_logs) WriteNodeConfiguration(node_logger, header_str);
}






#line 4262 "node.h"
void compcxx_Node_23 :: BroadcastNewConfigurationToStas(Configuration &new_configuration) {
	
	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Broadcasting the new configuration to STAs\n",
		SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);
	
	(outportSetNewWlanConfiguration_f(new_configuration));
}






#line 4274 "node.h"
void compcxx_Node_23 :: InportNewWlanConfigurationReceived(Configuration &received_configuration) {

	if (node_type == NODE_TYPE_STA) {

		LOGS(save_node_logs, node_logger.file, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");

		LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s New configuration received from the AP\n",
			SimTime(), node_id, node_state, LOG_F02, LOG_LVL2);

		
		new_configuration = received_configuration;
		if (save_node_logs) WriteReceivedConfiguration(node_logger, header_str, new_configuration);
		
		flag_apply_new_configuration = TRUE;
		LOGS(save_node_logs,node_logger.file, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");


		
		if(node_state == STATE_SENSING || node_state == STATE_NAV) {
            RestartNode(FALSE);
		}

	} else {
		printf("ERROR: the broadcast of a new configuration cannot be received at APs\n");
	}

}


















#line 4318 "node.h"
void compcxx_Node_23 :: CallRestartSta(trigger_t &){

	RestartNode(FALSE);

}






#line 4328 "node.h"
void compcxx_Node_23 :: RestartNode(int called_by_time_out){

	LOGS(save_node_logs, node_logger.file, "\n **********************************************************************\n");
	LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s Node Restarted (%d)\n",
		SimTime(), node_id, node_state, LOG_Z00, LOG_LVL1,
		called_by_time_out);

	

	int ix_num_ch = (int)log2(current_right_channel - current_left_channel + 1);

	total_time_transmitting_in_num_channels[ix_num_ch] +=
			current_tx_duration;

	performance_report.total_time_transmitting_in_num_channels[(int)log2(current_right_channel - current_left_channel + 1)] += current_tx_duration;
	for(int c = current_left_channel; c <= current_right_channel; ++c){
		total_time_transmitting_per_channel[c] += current_tx_duration;
		performance_report.total_time_transmitting_per_channel[c] += current_tx_duration;
	}

	
	if (flag_apply_new_configuration) {
		ApplyNewConfiguration(new_configuration);
	}
	flag_apply_new_configuration = FALSE; 
	

	
	node_state = STATE_SENSING;
	current_tx_duration = 0;
	power_rx_interest = 0;
	max_pw_interference = 0;

	receiving_from_node_id = NODE_ID_NONE;
	receiving_packet_id = NO_PACKET_ID;

	
	trigger_end_backoff.Cancel();
	trigger_recover_cts_timeout.Cancel();
	trigger_start_backoff.Cancel();

	LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s node_is_transmitter = %d "
			"/ buffer.QueueSize() = %d\n",
		SimTime(), node_id, node_state, LOG_Z00, LOG_LVL3,
		node_is_transmitter, buffer.QueueSize());

	
	if(node_is_transmitter && buffer.QueueSize() > 0){

		
		
		timestamp_new_trial_started = SimTime();

		
		++packet_id;

		
		remaining_backoff = ComputeBackoff(pdf_backoff, cw_current, backoff_type);
		expected_backoff = expected_backoff + remaining_backoff;
		++num_new_backoff_computations;

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s New backoff computed: %f (%.0f slots).\n",
			SimTime(), node_id, node_state, LOG_Z00, LOG_LVL3,
			remaining_backoff, remaining_backoff/SLOT_TIME);

		
		remaining_backoff = remaining_backoff + SLOT_TIME;

		LOGS(save_node_logs,node_logger.file, "%.15f;N%d;S%d;%s;%s Extra slot added --> remaining BO %f slots\n",
			SimTime(), node_id, node_state, LOG_Z00, LOG_LVL4,
			remaining_backoff / SLOT_TIME);

		LOGS(save_node_logs,node_logger.file,
			"%.15f;N%d;S%d;%s;%s Checking if BO can be resumed. Pow(primary #%d) =  %.2f dBm\n",
			SimTime(), node_id, node_state, LOG_Z00, LOG_LVL4,
			current_primary_channel, ConvertPower(PW_TO_DBM, channel_power[current_primary_channel]));

		
		int resume;
		if (spatial_reuse_enabled && txop_sr_identified) {
			resume = HandleBackoff(RESUME_TIMER, &channel_power, current_primary_channel,
				current_obss_pd_threshold, buffer.QueueSize());
		} else {
			resume = HandleBackoff(RESUME_TIMER, &channel_power, current_primary_channel,
				current_pd, buffer.QueueSize());
		}

		
		if (resume) {
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s BO can be resumed! Starting DIFS...\n",
				SimTime(), node_id, node_state, LOG_Z00, LOG_LVL5);
			
			time_to_trigger = SimTime() + DIFS;
			trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));
		} else {
			LOGS(save_node_logs,node_logger.file,
				"%.15f;N%d;S%d;%s;%s BO cannot be resumed!\n",
				SimTime(), node_id, node_state, LOG_Z00, LOG_LVL5);
		}
	}

	
	CleanNack(&logical_nack);

	
	trigger_ACK_timeout.Cancel();			
	trigger_CTS_timeout.Cancel();			
	trigger_DATA_timeout.Cancel();			
	trigger_NAV_timeout.Cancel();  			

}





#line 4444 "node.h"
void compcxx_Node_23:: StartSavingLogs(trigger_t &){
	save_node_logs = TRUE;
}











#line 4457 "node.h"
void compcxx_Node_23:: HandleSlottedBackoffCollision() {
	
	loss_reason = PACKET_LOST_BO_COLLISION;
	if(!node_is_transmitter) {
		node_state = STATE_SLEEP; 
		time_to_trigger = SimTime() + MAX_DIFFERENCE_SAME_TIME;
		trigger_restart_sta.Set(FixTimeOffset(time_to_trigger,13,12));
	} else {
		
		RestartNode(FALSE);
	}
}





#line 4473 "node.h"
void compcxx_Node_23:: RecoverFromCtsTimeout(trigger_t &) {
	
	
	LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s RecoverFromCtsTimeout\n",
		SimTime(), node_id, node_state, LOG_Z00, LOG_LVL3);
	
	trigger_recover_cts_timeout.Cancel();
	RestartNode(TRUE);
}





#line 4486 "node.h"
void compcxx_Node_23:: MeasureRho(trigger_t &){
	
	if (node_state == STATE_SENSING && channel_power[current_primary_channel] < current_pd){
		LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s RHO: Sensing + free\n",
			SimTime(), node_id, node_state, LOG_Z00, LOG_LVL3);
		++num_measures_rho;
		
		if (buffer.QueueSize() > 0){
			LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s RHO: Packet in buffer\n",
				SimTime(), node_id, node_state, LOG_Z00, LOG_LVL4);
			num_measures_rho_accomplished ++;
		} else {
			LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s RHO: Not packet in buffer\n",
				SimTime(), node_id, node_state, LOG_Z00, LOG_LVL4);
		}
	} else {



	}
	
	++num_measures_utilization;
	if (buffer.QueueSize() > 0) ++num_measures_buffer_with_packets;
	trigger_rho_measurement.Set(SimTime() + delta_measure_rho);
}





#line 4515 "node.h"
void compcxx_Node_23:: CallSensing(trigger_t &){

	LOGS(save_node_logs, node_logger.file, "%.15f;N%d;S%d;%s;%s State changed to sensing due to NAV collision\n",
		SimTime(), node_id, node_state, LOG_Z00, LOG_LVL3);

	node_state = STATE_SENSING;

	int resume (HandleBackoff(RESUME_TIMER, &channel_power,
		current_primary_channel, current_pd, buffer.QueueSize()));

	
	if (resume) {
		LOGS(save_node_logs, node_logger.file,
			"%.15f;N%d;S%d;%s;%s BO can be resumed! Starting DIFS...\n",
			SimTime(), node_id, node_state, LOG_Z00, LOG_LVL5);
		
		time_to_trigger = SimTime() + DIFS;
		trigger_start_backoff.Set(FixTimeOffset(time_to_trigger,13,12));
	} else {
		


		int loss_reason_sr = 1;	
		
		if (loss_reason == PACKET_NOT_LOST && spatial_reuse_enabled) {
			
			loss_reason_sr = IsPacketLost(current_primary_channel, nav_notification, nav_notification,
				current_sinr, capture_effect, potential_obss_pd_threshold, power_rx_interest, constant_per, node_id, capture_effect_model);
			if (loss_reason_sr != PACKET_NOT_LOST && node_is_transmitter) {
				txop_sr_identified = TRUE;	
				current_obss_pd_threshold = potential_obss_pd_threshold;	
				if(save_node_logs) fprintf(node_logger.file,
					"%.15f;N%d;S%d;%s;%s TXOP detected for OBSS_PD = %f dBm (in CallSensing())\n",
					SimTime(), node_id, node_state, LOG_D08, LOG_LVL3, ConvertPower(PW_TO_DBM, current_obss_pd_threshold));
			}
		
		} else {
			LOGS(save_node_logs, node_logger.file,
				"%.15f;N%d;S%d;%s;%s BO canot be resumed!\n",
				SimTime(), node_id, node_state, LOG_Z00, LOG_LVL5);
		}
	}

}












#line 4570 "node.h"
void compcxx_Node_23 :: PrintNodeInfo(int info_detail_level){
	printf("\n%s Node %s info:\n", LOG_LVL3, node_code.c_str());
	printf("%s node_id = %d\n", LOG_LVL4, node_id);
	printf("%s node_type = %d\n", LOG_LVL4, node_type);
	printf("%s position = (%.2f, %.2f, %.2f)\n", LOG_LVL4, x, y, z);
	printf("%s current_primary_channel = %d (range = [%d - %d])\n",
		LOG_LVL4, current_primary_channel, min_channel_allowed, max_channel_allowed);
	printf("%s current_dcb_policy = %d\n", LOG_LVL4, current_dcb_policy);
	printf("%s tx_power_default = %f pW (%f dBm)\n", LOG_LVL4, tx_power_default, ConvertPower(PW_TO_DBM, tx_power_default));
	printf("%s sensitivity_default = %f pW (%f dBm)\n", LOG_LVL4, sensitivity_default, ConvertPower(PW_TO_DBM, sensitivity_default));
	printf("%s spatial_reuse_enabled = %d\n", LOG_LVL4, (bss_color>=0));
	if(bss_color>=0) {
		printf("%s bss_color = %d\n", LOG_LVL5, bss_color);
		printf("%s srg = %d\n", LOG_LVL5, srg);
		printf("%s non_srg_obss_pd = %f dBm\n", LOG_LVL5, ConvertPower(PW_TO_DBM,non_srg_obss_pd));
		printf("%s srg_obss_pd = %f dBm\n", LOG_LVL5, ConvertPower(PW_TO_DBM,srg_obss_pd));
	}
	if(info_detail_level > INFO_DETAIL_LEVEL_0 && node_type == NODE_TYPE_AP){
		printf("%s wlan:\n", LOG_LVL4);
		printf("%s wlan code = %s\n", LOG_LVL5, wlan.wlan_code.c_str());
		printf("%s wlan id = %d\n", LOG_LVL5, wlan.wlan_id);
		printf("%s wlan AP id = %d\n", LOG_LVL5, wlan.ap_id);
		printf("%s Identifiers of STAs in WLAN (total number of STAs = %d): ", LOG_LVL5, wlan.num_stas);
		wlan.PrintStaIds();
	}
	if(info_detail_level > INFO_DETAIL_LEVEL_1){
		printf("%s cw_adaptation = %d\n", LOG_LVL4, cw_adaptation);
		printf("%s cw_min = %d\n", LOG_LVL4, cw_min);
		printf("%s cw_stage_max = %d\n", LOG_LVL4, cw_stage_max);
		printf("%s central_frequency = %f Hz (%f GHz)\n", LOG_LVL4, central_frequency, central_frequency * pow(10,-9));
		printf("%s capture_effect = %f [linear] (%f dB)\n", LOG_LVL4, capture_effect, ConvertPower(LINEAR_TO_DB, capture_effect));
		printf("%s Constant PER = %f\n", LOG_LVL4, constant_per);
	}
}








#line 4611 "node.h"
void compcxx_Node_23 :: WriteNodeInfo(Logger node_logger, int info_detail_level, std::string header_str){

	fprintf(node_logger.file, "%s Node %s info:\n", header_str.c_str(), node_code.c_str());
	fprintf(node_logger.file, "%s - node_id = %d\n", header_str.c_str(), node_id);
	fprintf(node_logger.file, "%s - node_type = %d\n", header_str.c_str(), node_type);
	fprintf(node_logger.file, "%s - position = (%.2f, %.2f, %.2f)\n", header_str.c_str(), x, y, z);
	fprintf(node_logger.file, "%s - current_primary_channel = %d\n", header_str.c_str(), current_primary_channel);
	fprintf(node_logger.file, "%s - min_channel_allowed = %d\n", header_str.c_str(), min_channel_allowed);
	fprintf(node_logger.file, "%s - max_channel_allowed = %d\n", header_str.c_str(), max_channel_allowed);
	fprintf(node_logger.file, "%s - current_dcb_policy = %d\n", header_str.c_str(), current_dcb_policy);
	fprintf(node_logger.file, "%s - spatial_reuse_enabled = %d\n", header_str.c_str(), (bss_color>=0));
	if(bss_color>=0) {
		fprintf(node_logger.file, "%s bss_color = %d\n", header_str.c_str(), bss_color);
		fprintf(node_logger.file, "%s srg = %d\n", header_str.c_str(), srg);
		fprintf(node_logger.file, "%s non_srg_obss_pd = %f dBm\n", header_str.c_str(), ConvertPower(PW_TO_DBM,non_srg_obss_pd));
		fprintf(node_logger.file, "%s srg_obss_pd = %f dBm\n", header_str.c_str(), ConvertPower(PW_TO_DBM,srg_obss_pd));
	}

	if(info_detail_level > INFO_DETAIL_LEVEL_0){
		wlan.WriteWlanInfo(node_logger, header_str);
	}

	if(info_detail_level > INFO_DETAIL_LEVEL_1){
		fprintf(node_logger.file, "%s - cw_min = %d\n", header_str.c_str(), cw_min);
		fprintf(node_logger.file, "%s - cw_stage_max = %d\n", header_str.c_str(), cw_stage_max);
		fprintf(node_logger.file, "%s - tx_power_default = %f pW\n", header_str.c_str(), tx_power_default);
		fprintf(node_logger.file, "%s - sensitivity_default = %f pW\n", header_str.c_str(), sensitivity_default);
	}

}







#line 4647 "node.h"
void compcxx_Node_23 :: WriteNodeConfiguration(Logger node_logger, std::string header_str){
	fprintf(node_logger.file, "%s Configuration %s info:\n", header_str.c_str(), node_code.c_str());
	fprintf(node_logger.file, "%s - current_primary = %d\n", header_str.c_str(), current_primary_channel);
	fprintf(node_logger.file, "%s - current_pd = %f (%f dBm)\n", header_str.c_str(), current_pd, ConvertPower(PW_TO_DBM,current_pd));
	fprintf(node_logger.file, "%s - current_tx_power = %f (%f dBm)\n", header_str.c_str(), current_tx_power, ConvertPower(PW_TO_DBM,current_tx_power));
	fprintf(node_logger.file, "%s - current_max_bandwidth = %d\n", header_str.c_str(), current_max_bandwidth);
}








#line 4661 "node.h"
void compcxx_Node_23 :: WriteReceivedConfiguration(Logger node_logger, std::string header_str, Configuration new_configuration) {
	fprintf(node_logger.file, "%s Received Configuration:\n", header_str.c_str());
	fprintf(node_logger.file, "%s - selected_primary_channel = %d\n", header_str.c_str(), new_configuration.selected_primary_channel);
	fprintf(node_logger.file, "%s - selected_pd = %f (%f dBm)\n", header_str.c_str(), new_configuration.selected_pd, ConvertPower(PW_TO_DBM,new_configuration.selected_pd));
	fprintf(node_logger.file, "%s - current_tx_power = %f (%f dBm)\n", header_str.c_str(), new_configuration.selected_tx_power, ConvertPower(PW_TO_DBM,new_configuration.selected_tx_power));
	fprintf(node_logger.file, "%s - selected_max_bandwidth = %d\n", header_str.c_str(), new_configuration.selected_max_bandwidth);
}





#line 4672 "node.h"
void compcxx_Node_23 :: PrintNodeConfiguration(){
	printf("Node%d - Configuration info:\n", node_id);
	printf(" - current_pd = %f (%f dBm)\n", current_pd, ConvertPower(PW_TO_DBM,current_pd));
	printf(" - current_tx_power = %f (%f dBm)\n", current_tx_power, ConvertPower(PW_TO_DBM,current_tx_power));
}





#line 4681 "node.h"
void compcxx_Node_23 :: PrintProgressBar(trigger_t &){
	
	printf("* %d %% *\n", progress_bar_counter * PROGRESS_BAR_DELTA);
	trigger_sim_time.Set(RoundToDigits(SimTime() + simulation_time_komondor / (100/PROGRESS_BAR_DELTA),15));
	
	if(node_id == 0 && progress_bar_counter == (100/PROGRESS_BAR_DELTA)-1){
		trigger_sim_time.Set(RoundToDigits(SimTime() + simulation_time_komondor/(100/PROGRESS_BAR_DELTA) - MIN_VALUE_C_LANGUAGE,15));
	}
	++progress_bar_counter;
}






#line 4696 "node.h"
void compcxx_Node_23 :: PrintOrWriteNodeStatistics(int write_or_print){
	
	double data_packets_lost_percentage (0);
	double generation_drop_ratio (0);
	double rts_cts_lost_percentage (0);
	double tx_init_failure_percentage (0);
	double rts_lost_bo_percentage (0);

	if (num_delay_measurements > 0) average_delay = sum_delays / (double) num_delay_measurements;
	if (flag_measure_rho && num_measures_rho > 0) average_rho = (double) num_measures_rho_accomplished/(double) num_measures_rho;
	if (num_measures_utilization > 0) average_utilization = (double) num_measures_buffer_with_packets / (double) num_measures_utilization;
	tx_init_failure_percentage = double(num_tx_init_not_possible * 100)/double(num_tx_init_tried);
	if (data_packets_sent > 0) data_packets_lost_percentage = double(data_packets_lost * 100)/double(data_packets_sent);
	if (rts_cts_sent > 0){
		rts_cts_lost_percentage = double(rts_cts_lost * 100)/double(rts_cts_sent);
		rts_lost_bo_percentage = double(rts_lost_slotted_bo *100)/double(rts_cts_sent);
		prob_slotted_bo_collision = double(rts_lost_bo_percentage / double(100));
	}
	if (num_packets_generated > 1){
		generation_drop_ratio = num_packets_dropped * 100/ num_packets_generated;
	}
	throughput = ((double) data_frames_acked * frame_length) / SimTime();
	for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
		bandwidth_used_txing += (total_time_spectrum_per_channel[c]/SimTime()) * 20;
	}




	average_waiting_time = sum_waiting_time / (double) num_average_waiting_time_measurements;
	expected_backoff = expected_backoff / (double) num_new_backoff_computations;

	switch(write_or_print){

		case PRINT_LOG:{

			if (node_is_transmitter && print_node_logs) {
				printf("------- %s (N%d) ------\n", node_code.c_str(), node_id);
				
				printf("%s Throughput = %f Mbps (%.2f pkt/s)\n", LOG_LVL2,
					throughput * pow(10,-6),
					throughput / (frame_length * limited_num_packets_aggregated));
				
				printf("%s Average delay from %d measurements = %f s (%.2f ms)\n", LOG_LVL2,
					num_delay_measurements, average_delay, average_delay * 1000);
				
				printf("%s Average rho = %f (%.2f %%)\n", LOG_LVL2,
					average_rho, average_rho * 100);
				printf("%s %d/%d\n", LOG_LVL3,
					num_measures_rho_accomplished, num_measures_rho);
				
				printf("%s Average utilization = %f (%.2f %%)\n", LOG_LVL2,
					average_utilization, average_utilization * 100);
				printf("%s %d/%d\n", LOG_LVL3,
					num_measures_buffer_with_packets, num_measures_utilization);
				
				printf("%s RTS/CTS sent/lost = %d/%d  (%.2f %% lost)\n",
					LOG_LVL2, rts_cts_sent, rts_cts_lost, rts_cts_lost_percentage);
				
				printf("%s RTS lost due to slotted BO = %d (%f %%)\n",
					LOG_LVL3, rts_lost_slotted_bo, rts_lost_bo_percentage);
				
				printf("%s Data packets sent = %d - ACKed = %d -  Lost = %d  (%f %% lost)\n",
					LOG_LVL2, data_packets_sent, data_packets_acked, data_packets_lost, data_packets_lost_percentage);
				printf("%s Frames ACKed = %d, Av. frames sent per packet = %.2f\n",
					LOG_LVL2, data_frames_acked, (double) data_frames_acked/data_packets_acked);
				
				printf("%s Buffer: packets generated = %.0f (%.2f pkt/s) - Packets dropped = %.0f  (%f %% drop ratio)\n",
					LOG_LVL2, num_packets_generated, num_packets_generated / SimTime(), num_packets_dropped, generation_drop_ratio);
				if(TRAFFIC_POISSON_BURST){
					printf("%s Buffer: num bursts = %d\n",
						LOG_LVL2,
						num_bursts);
				}
				
				printf("%s num_tx_init_tried = %d - num_tx_init_not_possible = %d (%f %% failed)\n",
					LOG_LVL2, num_tx_init_tried, num_tx_init_not_possible, tx_init_failure_percentage);
				
				printf("%s Time EFFECTIVELY transmitting in N channels:", LOG_LVL3);
				for(int n = 0; n < num_channels_allowed; ++n){
					printf("\n%s - %d: %f s (%.2f %%)",
							LOG_LVL3, (int) pow(2,n),
							total_time_transmitting_in_num_channels[n] - total_time_lost_in_num_channels[n],
							((total_time_transmitting_in_num_channels[n] -
									total_time_lost_in_num_channels[n])) * 100 /SimTime());
					if((int) pow(2,n) == NUM_CHANNELS_KOMONDOR) break;
				}
				printf("\n");
				
				printf("%s Time EFFECTIVELY transmitting in each channel:", LOG_LVL3);
				double time_effectively_txing;
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					time_effectively_txing = total_time_transmitting_per_channel[c] -
						total_time_lost_per_channel[c];
					printf("\n%s - %d = %.2f s (%.2f %%)",
						LOG_LVL3, c, time_effectively_txing,
						(time_effectively_txing * 100 /SimTime()));
				}
				printf("\n");
				
				printf("%s Time occupying the spectrum in each channel:", LOG_LVL3);
				for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
					printf("\n%s - %d = %.2f s (%.2f %%)",
						LOG_LVL3, c, total_time_spectrum_per_channel[c],
						(total_time_spectrum_per_channel[c] * 100 /SimTime()));
				}
				printf("\n%s - Average bandwidth used for transmitting = %.2f MHz / %d MHz (%.2f %%)\n",
					LOG_LVL4,
					bandwidth_used_txing,
					num_channels_allowed * 20,
					bandwidth_used_txing * 100 / (num_channels_allowed * 20));
				printf("\n");


















				
				printf("%s Number of tx trials per number of channels:", LOG_LVL3);
				for(int n = 0; n < NUM_CHANNELS_KOMONDOR; ++n){
					printf("\n%s - %d: %d (%.2f %%)",
						LOG_LVL3, (int) pow(2,n),
						num_trials_tx_per_num_channels[n],
						(((double) num_trials_tx_per_num_channels[n] * 100) / (double) (rts_cts_sent)));

					if((int) pow(2,n) == NUM_CHANNELS_KOMONDOR) break;
				}
				printf("\n");
				
				printf("%s num_tx_init_not_possible = %d\n", LOG_LVL2, num_tx_init_not_possible);













				printf("%s times_went_to_nav = %d\n", LOG_LVL2, times_went_to_nav);
				printf("%s time_in_nav = %f (%.2f %% of the total time)\n", LOG_LVL2,
					time_in_nav, (time_in_nav/simulation_time_komondor*100));

				printf("%s average_waiting_time = %f (%f slots)\n", LOG_LVL2, average_waiting_time, average_waiting_time / SLOT_TIME);
				printf("%s Expected BO = %f (%f slots)\n", LOG_LVL2, expected_backoff, expected_backoff / SLOT_TIME);

				
				printf("%s Per-STA report:\n", LOG_LVL2);
				
				printf("%s Throughput: {", LOG_LVL3);
				for(int n = 0; n < wlan.num_stas; ++n){
					throughput_per_sta[n] = ((double)data_frames_acked_per_sta[n] * (double)frame_length) / SimTime();
					printf("%.2f Mbps",  throughput_per_sta[n] * pow(10,-6));
					if(n<wlan.num_stas-1) printf(", ");
				}
				printf("}\n%s RTS/CTS sent /	 RTS/CTS lost: {", LOG_LVL3);
				for(int n = 0; n < wlan.num_stas; ++n){
					printf("%d/%d (%.2f %%)", rts_cts_sent_per_sta[n], rts_cts_lost_per_sta[n],
						double(rts_cts_lost_per_sta[n] * 100)/double(rts_cts_sent_per_sta[n]));
					if(n<wlan.num_stas-1) printf(", ");
				}
				printf("}\n%s Data packets sent / Data packets lost: {", LOG_LVL3);
				for(int n = 0; n < wlan.num_stas; ++n){
					printf("%d/%d (%.2f %%)", data_packets_sent_per_sta[n], data_packets_lost_per_sta[n],
							double(data_packets_lost_per_sta[n] * 100)/double(data_packets_sent_per_sta[n]));
					if(n<wlan.num_stas-1) printf(", ");
				}
				printf("}");
				printf("\n\n");

			}
			break;
		}

		case WRITE_LOG:{

			if (save_node_logs){

				if (node_is_transmitter) {
					
					fprintf(node_logger.file, "%.15f;N%d;S%d;%s;%s Throughput = %f Mbps\n",
						SimTime(), node_id, node_state, LOG_C02, LOG_LVL2, throughput * pow(10,-6));

					
					fprintf(node_logger.file,
						"%.15f;N%d;S%d;%s;%s Data packets sent: %d\n",
						SimTime(), node_id, node_state, LOG_C03, LOG_LVL2, data_packets_sent);
					fprintf(node_logger.file,
						"%.15f;N%d;S%d;%s;%s Data packets lost: %d\n",
						SimTime(), node_id, node_state, LOG_C04, LOG_LVL2, data_packets_lost);
					fprintf(node_logger.file,
						"%.15f;N%d;S%d;%s;%s Loss ratio: %f\n",
						SimTime(), node_id, node_state, LOG_C05, LOG_LVL2, data_packets_lost_percentage);

					
					fprintf(node_logger.file, "%.15f;N%d;S%d;%s;%s Time EFFECTIVELY transmitting in N channels: ",
						SimTime(), node_id, node_state, LOG_C06, LOG_LVL2);
					for(int n = 0; n < num_channels_allowed; ++n){
						fprintf(node_logger.file, "(%d) %f  ",
							n+1, total_time_transmitting_in_num_channels[n] - total_time_lost_in_num_channels[n]);
					}
					fprintf(node_logger.file, "\n");

					
					fprintf(node_logger.file,
						"%.15f;N%d;S%d;%s;%s Time EFFECTIVELY transmitting in each channel: ",
						SimTime(), node_id, node_state, LOG_C07, LOG_LVL2);
					for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
						fprintf(node_logger.file, "(#%d) %f ",
							c, total_time_transmitting_per_channel[c] - total_time_lost_per_channel[c]);
					}
					fprintf(node_logger.file, "\n");

					
					fprintf(node_logger.file, "%.15f;N%d;S%d;%s;%s Time LOST transmitting in N channels: ",
						SimTime(), node_id, node_state, LOG_C08, LOG_LVL2);
					for(int n = 0; n < num_channels_allowed; ++n){
						fprintf(node_logger.file, "(%d) %f  ", n+1, total_time_lost_in_num_channels[n]);
					}
					fprintf(node_logger.file, "\n");

					
					fprintf(node_logger.file, "%.15f;N%d;S%d;%s;%s Time LOST transmitting in each channel: ",
						SimTime(), node_id, node_state, LOG_C09, LOG_LVL2);
					for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
						fprintf(node_logger.file, "(#%d) %f ", c, total_time_lost_per_channel[c]);
					}
					fprintf(node_logger.file, "\n");

					
					fprintf(node_logger.file, "%.15f;N%d;S%d;%s;%s num_tx_init_not_possible = %d\n",
						SimTime(), node_id, node_state, LOG_C09, LOG_LVL2, num_tx_init_not_possible);

					
					fprintf(node_logger.file,"%s Time occupying the spectrum in each channel:", LOG_LVL3);
					for(int c = 0; c < NUM_CHANNELS_KOMONDOR; ++c){
						fprintf(node_logger.file,"\n%s - %d = %.2f s (%.2f %%)",
							LOG_LVL3, c, total_time_spectrum_per_channel[c],
							(total_time_spectrum_per_channel[c] * 100 /SimTime()));
					}

					fprintf(node_logger.file,"\n%s - Average bandwidth used for transmitting = %.2f MHz / %d MHz (%.2f %%)\n",
						LOG_LVL4, bandwidth_used_txing, num_channels_allowed * 20, bandwidth_used_txing * 100 / (num_channels_allowed * 20));

					fprintf(node_logger.file,"\n");

				}














			}
			break;
		}
	}
}





#line 4983 "node.h"
void compcxx_Node_23 :: SaveSimulationPerformance() {

	if(node_id == 0) simulation_performance.sum_time_channel_idle = sum_time_channel_idle;

	simulation_performance.num_stas = wlan.num_stas;
    simulation_performance.min_channel_allowed = min_channel_allowed;
    simulation_performance.max_channel_allowed = max_channel_allowed;

	
	simulation_performance.throughput = throughput;
	simulation_performance.throughput_loss = throughput_loss;

	
	simulation_performance.data_packets_acked = data_packets_acked;
	simulation_performance.data_frames_acked = data_frames_acked;
	simulation_performance.data_packets_sent = data_packets_sent;
	simulation_performance.data_packets_lost = data_packets_lost;
	simulation_performance.rts_cts_sent = rts_cts_sent;
	simulation_performance.rts_cts_lost = rts_cts_lost;
	simulation_performance.rts_lost_slotted_bo = rts_lost_slotted_bo;

	
	simulation_performance.num_packets_generated = num_packets_generated;
	simulation_performance.num_packets_dropped = num_packets_dropped;
	simulation_performance.num_delay_measurements = num_delay_measurements;
	simulation_performance.sum_delays = sum_delays;
	simulation_performance.average_delay = average_delay;
	simulation_performance.average_rho = average_rho;
	simulation_performance.average_utilization = average_utilization;
	simulation_performance.generation_drop_ratio = generation_drop_ratio;

	
	simulation_performance.expected_backoff = expected_backoff;
	simulation_performance.num_new_backoff_computations = num_new_backoff_computations;
	simulation_performance.num_trials_tx_per_num_channels = num_trials_tx_per_num_channels;
	simulation_performance.average_waiting_time = average_waiting_time;
	simulation_performance.bandwidth_used_txing = bandwidth_used_txing;
	simulation_performance.total_time_transmitting_per_channel = total_time_transmitting_per_channel;
	simulation_performance.total_time_transmitting_in_num_channels = total_time_transmitting_in_num_channels;
	simulation_performance.total_time_lost_per_channel = total_time_lost_per_channel;
	simulation_performance.total_time_lost_in_num_channels = total_time_lost_in_num_channels;
	simulation_performance.total_time_spectrum_per_channel = total_time_spectrum_per_channel;
	simulation_performance.time_in_nav = time_in_nav;

	
	if(node_type == NODE_TYPE_AP) {
		simulation_performance.throughput_per_sta = throughput_per_sta;
		simulation_performance.data_packets_sent_per_sta = data_packets_sent_per_sta;
		simulation_performance.rts_cts_sent_per_sta = rts_cts_sent_per_sta;
		simulation_performance.data_packets_lost_per_sta = data_packets_lost_per_sta;
		simulation_performance.rts_cts_lost_per_sta = rts_cts_lost_per_sta;
		simulation_performance.data_packets_acked_per_sta = data_packets_acked_per_sta;
		simulation_performance.data_frames_acked_per_sta = data_frames_acked_per_sta;
		simulation_performance.rssi_list_per_sta = rssi_per_sta;
		UpdatePerformanceMeasurements();
		simulation_performance.max_received_power_in_ap_per_wlan = max_received_power_in_ap_per_wlan;



	}
	simulation_performance.received_power_array = received_power_array;

    if(node_type == NODE_TYPE_AP) {
        simulation_performance.average_sinr = 0;
    } else {
        simulation_performance.average_sinr = aggregate_sinr/num_sinr_measurements;
    }
	
	simulation_performance.num_tx_init_tried = num_tx_init_tried;
	simulation_performance.num_tx_init_not_possible = num_tx_init_not_possible;
	simulation_performance.prob_slotted_bo_collision = prob_slotted_bo_collision;

	configuration.non_srg_obss_pd = non_srg_obss_pd;

}











#line 5068 "node.h"
void compcxx_Node_23 :: InitializeVariables() {

	




	burst_rate = 10;
	num_bursts = 0;
	
	nack_activated = FALSE;
	



	current_max_bandwidth = max_channel_allowed - min_channel_allowed + 1;

	current_sinr = 0;
    aggregate_sinr = 0;
    num_sinr_measurements = 0;
	max_pw_interference = 0;
	rts_lost_slotted_bo = 0;
	last_packet_generated_id = 0;

	num_delay_measurements = 0;
	sum_delays = 0;
	average_delay = 0;
	num_packets_generated = 0;
	num_packets_dropped = 0;

	num_channels_tx = 0;

	flag_measure_rho = TRUE;
	delta_measure_rho = 0.00001;
	num_measures_rho = 0;
	num_measures_rho_accomplished = 0;
	average_utilization = 0;
	average_rho = 0;
	bandwidth_used_txing = 0;

	num_measures_utilization = 0;
	num_measures_buffer_with_packets = 0;
	generation_drop_ratio = 0;

	
	node_logger.save_logs = save_node_logs;
	node_logger.file = node_logger.file;

	
	channel_power = new double[NUM_CHANNELS_KOMONDOR];
	num_channels_allowed = (max_channel_allowed - min_channel_allowed + 1);
	total_time_transmitting_per_channel = new double[NUM_CHANNELS_KOMONDOR];
	channels_free = new int[NUM_CHANNELS_KOMONDOR];
	channels_for_tx = new int[NUM_CHANNELS_KOMONDOR];
	total_time_lost_per_channel = new double[NUM_CHANNELS_KOMONDOR];
	total_time_spectrum_per_channel = new double[NUM_CHANNELS_KOMONDOR];
	timestampt_channel_becomes_free = new double[NUM_CHANNELS_KOMONDOR];
	num_trials_tx_per_num_channels = new int[NUM_CHANNELS_KOMONDOR];

	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){
		channel_power[i] = 0;
		total_time_transmitting_per_channel[i] = 0;
		channels_free[i] = FALSE;
		channels_for_tx[i] = FALSE;
		total_time_lost_per_channel[i] = 0;
		timestampt_channel_becomes_free[i] = 0;
		num_trials_tx_per_num_channels[i] = 0;
		total_time_spectrum_per_channel[i] = 0;
	}

	total_time_transmitting_in_num_channels = new double[NUM_CHANNELS_KOMONDOR];
	total_time_lost_in_num_channels = new double[NUM_CHANNELS_KOMONDOR];
	for(int i = 0; i < NUM_CHANNELS_KOMONDOR; ++i){
		total_time_transmitting_in_num_channels[i] = 0;
		total_time_lost_in_num_channels[i] = 0;
	}

	nodes_transmitting = new int[total_nodes_number];




	for(int n = 0; n < total_nodes_number; ++n){
		nodes_transmitting[n] = FALSE;


	}

	power_received_per_node.clear();


	nacks_received = new int[NUM_PACKET_LOST_REASONS];
	for(int i = 0; i < NUM_PACKET_LOST_REASONS; ++i){
		nacks_received[i] = 0;
	}

	
	power_rx_interest = 0;
	progress_bar_counter = 0;
	current_left_channel =  min_channel_allowed;
	current_right_channel = max_channel_allowed;
	sum_waiting_time = 0;
	timestamp_new_trial_started = 0;
	num_average_waiting_time_measurements = 0;
	expected_backoff = 0;
	remaining_backoff = 0;
	num_new_backoff_computations = 0;

	data_packets_acked = 0;
	data_frames_acked = 0;

	node_state = STATE_SENSING;
	current_modulation = 1;
	cw_current = cw_min;
	cw_stage_current = 0;
	packet_id = 0;

	if(node_type == NODE_TYPE_AP) {
		node_is_transmitter = TRUE;
		remaining_backoff = ComputeBackoff(pdf_backoff, cw_current, backoff_type);
		expected_backoff += remaining_backoff;
		num_new_backoff_computations++;
	} else {
		node_is_transmitter = FALSE;
	}

	current_tx_power = tx_power_default;
	current_pd = sensitivity_default;
	channel_max_intereference = current_primary_channel;

	data_duration = 0;
	ack_duration = 0;
	rts_duration = 0;
	cts_duration = 0;

	default_modulation = MODULATION_NONE;

	mcs_response = new int[4];
	for(int n = 0; n < 4; ++n){
		mcs_response[n] = 0;
	}

	change_modulation_flag = new int[wlan.num_stas];
	for(int n = 0; n < wlan.num_stas; ++n){
		change_modulation_flag[n] = TRUE;
	}
	mcs_per_node = new int *[wlan.num_stas] ;
	for( int i = 0 ; i < wlan.num_stas ; ++i ) mcs_per_node[i] = new int[NUM_OPTIONS_CHANNEL_LENGTH];
	for ( int i=0; i< wlan.num_stas; ++i) {
		for (int j=0; j< NUM_OPTIONS_CHANNEL_LENGTH; ++j) {
			mcs_per_node[i][j] = -1;
		}
	}

	first_time_requesting_mcs = TRUE;

	
	null_notification.packet_id = -1;
	null_notification.packet_type = -1;
	null_notification.source_id = -1;
	null_notification.destination_id = -1;
	null_notification.tx_duration = -1;
	null_notification.left_channel = -1;
	null_notification.right_channel = -1;
	null_notification.frame_length = -1;
	null_notification.modulation_id = -1;
	null_notification.timestamp = -1;

	TxInfo null_tx_info;

	null_tx_info.data_duration = 0;
	null_tx_info.ack_duration = 0;
	null_tx_info.rts_duration = 0;
	null_tx_info.cts_duration = 0;
	null_tx_info.tx_power = 0;
	null_tx_info.bits_ofdm_sym = 0;
	null_tx_info.SetSizeOfMCS(4);	
	null_tx_info.x = 0;
	null_tx_info.y = 0;
	null_tx_info.z = 0;
	null_tx_info.nav_time = 0;

	null_notification.tx_info = null_tx_info;

	data_notification = null_notification;
	ack_notification= null_notification;
	incoming_notification = null_notification;
	rts_notification = null_notification;
	cts_notification = null_notification;
	new_packet = null_notification;

	
	data_packets_sent = 0;
	rts_cts_sent = 0;
	throughput = 0;
	throughput_loss = 0;
	data_packets_lost = 0;
	rts_cts_lost = 0;
	num_tx_init_not_possible = 0;
	num_tx_init_tried = 0;

	throughput_per_sta = new double[wlan.num_stas];
	data_packets_sent_per_sta = new int[wlan.num_stas];
	rts_cts_sent_per_sta = new int[wlan.num_stas];
	data_packets_lost_per_sta = new int[wlan.num_stas];
	rts_cts_lost_per_sta = new int[wlan.num_stas];
	data_packets_acked_per_sta = new int[wlan.num_stas];
	data_frames_acked_per_sta = new int[wlan.num_stas];

	for(int i = 0; i < wlan.num_stas; ++i){
		throughput_per_sta[i] = 0;
		data_packets_sent_per_sta[i] = 0;
		rts_cts_sent_per_sta[i] = 0;
		data_packets_lost_per_sta[i] = 0;
		rts_cts_lost_per_sta[i] = 0;
		data_packets_acked_per_sta[i] = 0;
		data_frames_acked_per_sta[i] = 0;
	}

	performance_report.SetSizeOfChannelLists(NUM_CHANNELS_KOMONDOR);
	performance_report.SetSizeOfRssiList(total_wlans_number);

	performance_report.SetSizeOfRssiPerStaList(wlan.num_stas);

	
	RestartPerformanceMetrics(&performance_report, 0, num_channels_allowed);
	performance_report.SetSizeOfRssiList(total_wlans_number);

	flag_apply_new_configuration = FALSE;

	
	sum_time_channel_idle = 0;
	last_time_channel_is_idle = 0;

	


	
	if (node_type == NODE_TYPE_AP && bss_color >= 0) {
		spatial_reuse_enabled = TRUE;
	} else {
		spatial_reuse_enabled = FALSE;
	}











	
	if (node_type == NODE_TYPE_STA) {
		(outportRequestSpatialReuseConfiguration_f());
	}
	
	txop_sr_identified = FALSE;
	
	for (int i = 0; i < 3; i ++) {
		type_ongoing_transmissions_sr[i] = 0;
	}
	next_pd_spatial_reuse = current_pd;
	

	if(node_type == NODE_TYPE_AP) {
		rssi_per_sta = new double[wlan.num_stas];
		for (int i = 0; i < wlan.num_stas; ++i) {
			rssi_per_sta[i] = 0;
		}
	}

	


	
	channel_aggregation_cca_model = CHANNEL_AGGREGATION_CCA_11AX;
}


#line 288 ".././COST/cost.h"

#line 288 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_19/*<trigger_t >*/::Set(trigger_t const & data, double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.data = data;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 300 ".././COST/cost.h"

#line 300 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_19/*<trigger_t >*/::Set(double time)
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.time = time;
  m_event.object = this;
  m_event.active=true;
  m_simeng->ScheduleEvent(&m_event);
}


#line 311 ".././COST/cost.h"

#line 311 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_19/*<trigger_t >*/::Cancel()
{
  if(m_event.active)
    m_simeng->CancelEvent(&m_event);
  m_event.active = false;
}


#line 319 ".././COST/cost.h"

#line 319 ".././COST/cost.h"
/*template <class T>
*/void compcxx_Timer_19/*<trigger_t >*/::activate(CostEvent*e)
{
  assert(e==&m_event);
  m_event.active=false;
  (p_compcxx_parent->NewPacketGenerated(m_event.data));
}




#line 106 "traffic_generator.h"
void compcxx_TrafficGenerator_24 :: Setup(){
	
}
#line 113 "traffic_generator.h"
void compcxx_TrafficGenerator_24 :: Start(){

	if (node_type == NODE_TYPE_AP) { 
		InitializeTrafficGenerator();
	}

}
#line 124 "traffic_generator.h"
void compcxx_TrafficGenerator_24 :: Stop(){

}
#line 131 "traffic_generator.h"
void compcxx_TrafficGenerator_24 :: GenerateTraffic() {

	double time_for_next_packet (0);
	double time_to_trigger (0);


	switch(traffic_model) {

		
		case TRAFFIC_FULL_BUFFER_NO_DIFFERENTIATION:{
			

			break;
		}

		
		
		
		
		case TRAFFIC_FULL_BUFFER:{
			if(node_id == 0) printf("WARNING: FULL BUFFER NOT IMPLEMENTED! SIMULATE IT: just use Poisson traffic with large traffic loads\n");
			
			traffic_model = TRAFFIC_POISSON;
			traffic_load = 1000;
			
			time_for_next_packet = Exponential(1/traffic_load);
			time_to_trigger = SimTime() + time_for_next_packet;
			trigger_new_packet_generated.Set(FixTimeOffset(time_to_trigger,13,12));
			break;
		}

		
		case TRAFFIC_POISSON:{
			
			
			
			
			
			time_for_next_packet = Exponential(1/traffic_load);
			time_to_trigger = SimTime() + time_for_next_packet;
			trigger_new_packet_generated.Set(FixTimeOffset(time_to_trigger,13,12));
			break;
		}

		
		case TRAFFIC_DETERMINISTIC:{
			int lambda = 10000;
			time_for_next_packet = 1/lambda;
			time_to_trigger = SimTime() + time_for_next_packet;
			trigger_new_packet_generated.Set(FixTimeOffset(time_to_trigger,13,12));
			break;
		}

		
		case TRAFFIC_POISSON_BURST:{
			
			
			time_for_next_packet = Exponential(burst_rate/traffic_load);
			time_to_trigger = SimTime() + time_for_next_packet;



			trigger_new_packet_generated.Set(FixTimeOffset(time_to_trigger,13,12));
			break;
		}

		default:{
			printf("Wrong traffic model!\n");
			exit(EXIT_FAILURE);
			break;
		}
	}
}





#line 208 "traffic_generator.h"
void compcxx_TrafficGenerator_24 :: NewPacketGenerated(trigger_t &){

	(outportNewPacketGenerated_f());
	GenerateTraffic();
}





#line 217 "traffic_generator.h"
void compcxx_TrafficGenerator_24 :: InitializeTrafficGenerator() {
	




	burst_rate = 10;
	num_bursts = 0;
	GenerateTraffic();
}


#line 198 "komondor_main.cc"
void compcxx_Komondor_27 :: Setup(double sim_time_console, int save_node_logs_console,
		int save_agent_logs_console, int print_system_logs_console, int print_node_logs_console,
		int print_agent_logs_console, const char *nodes_input_filename_console,
		const char *script_output_filename, const char *simulation_code_console, int seed_console,
		int agents_enabled_console, const char *agents_input_filename_console){

	
	simulation_time_komondor = sim_time_console;
	save_node_logs = save_node_logs_console;
	save_agent_logs = save_agent_logs_console;
	print_node_logs = print_node_logs_console;
	print_system_logs = print_system_logs_console;
	print_agent_logs = print_agent_logs_console;
	nodes_input_filename = nodes_input_filename_console;
	agents_input_filename = agents_input_filename_console;


	seed = seed_console;
	agents_enabled = agents_enabled_console;
	total_wlans_number = 0;

    
	if (print_system_logs) printf("\n%s Creating output files\n", LOG_LVL1);
	std::string simulation_filename_remove;
	simulation_filename_remove.append("output/logs_console_").append(simulation_code_console).append(".txt");
	std::string simulation_filename_fopen;
	simulation_filename_fopen.append("../").append(simulation_filename_remove);
	if(remove(simulation_filename_remove.c_str()) == 0){
		if (print_system_logs) printf("%s Simulation output file '%s' found and removed. New one created!\n",
			LOG_LVL2, simulation_filename_remove.c_str());
	} else {
		if (print_system_logs) printf("%s Simulation output file '%s' created!\n",
			LOG_LVL2, simulation_filename_remove.c_str());
	}

	
	script_output_file = fopen(script_output_filename, "at");	
	logger_script.save_logs = SAVE_LOG;
	logger_script.file = script_output_file;
	fprintf(logger_script.file, "%s KOMONDOR SIMULATION '%s' (seed %d)", LOG_LVL1, simulation_code_console, seed);

	
	SetupEnvironmentByReadingConfigFile();

	
	GenerateNodesByReadingInputFile(nodes_input_filename);

	
	for(int i = 0; i < total_nodes_number; ++i) {
		node_container[i].distances_array = new double[total_nodes_number];
		node_container[i].received_power_array = new double[total_nodes_number];
		for(int j = 0; j < total_nodes_number; ++j) {
			
			node_container[i].distances_array[j] = ComputeDistance(node_container[i].x,node_container[i].y,
				node_container[i].z,node_container[j].x,node_container[j].y,node_container[j].z);
			
			if(i == j) {
				node_container[i].received_power_array[j] = 0;
			} else {
				node_container[i].received_power_array[j] = ComputePowerReceived(node_container[i].distances_array[j],
					node_container[j].tx_power_default, node_container[i].central_frequency, path_loss_model);
			}
		}
	}

	
	for(int i = 0; i < total_nodes_number; ++i) {
		double max_power_received_per_wlan;
		if (node_container[i].node_type == NODE_TYPE_AP) {
			node_container[i].max_received_power_in_ap_per_wlan = new double[total_wlans_number];
			for(int j = 0; j < total_wlans_number; ++j) {
				if (strcmp(node_container[i].wlan_code.c_str(),wlan_container[j].wlan_code.c_str()) == 0) {
					
					node_container[i].max_received_power_in_ap_per_wlan[j] = 0;
				} else {
					
					max_power_received_per_wlan = -1000;
					for (int k = 0; k < total_nodes_number; ++k) {
						
						if(strcmp(node_container[k].wlan_code.c_str(),wlan_container[j].wlan_code.c_str()) == 0) {
							if (node_container[i].received_power_array[k] > max_power_received_per_wlan) {
								max_power_received_per_wlan = node_container[i].received_power_array[k];
							}
						}
					}
					node_container[i].max_received_power_in_ap_per_wlan[j] = max_power_received_per_wlan;
				}
			}
		}
	}

	
	central_controller_flag = 0;
	if (agents_enabled) { GenerateAgents(agents_input_filename, simulation_code_console); }
	
	if (agents_enabled && central_controller_flag) { GenerateCentralController(agents_input_filename); }

	
	if (print_system_logs) {
		printf("%s System configuration: \n", LOG_LVL2);
		PrintSystemInfo();
		printf("%s Wlans generated!\n", LOG_LVL2);
		PrintAllWlansInfo();
		if (print_system_logs) printf("\n");
		printf("%s Nodes generated!\n", LOG_LVL2);
		PrintAllNodesInfo(INFO_DETAIL_LEVEL_2);
		if (print_system_logs) printf("\n");
		if (print_system_logs && agents_enabled) PrintMlOperationInfo();
	}

	
	InputChecker();

	
	for(int n = 0; n < total_nodes_number; ++n){

		traffic_generator_container[n].outportNewPacketGenerated_f.Connect(node_container[n],(compcxx_component::TrafficGenerator_outportNewPacketGenerated_f_t)&compcxx_Node_23::InportNewPacketGenerated) /*connect traffic_generator_container[n].outportNewPacketGenerated,node_container[n].InportNewPacketGenerated*/;

		for(int m=0; m < total_nodes_number; ++m) {

			node_container[n].outportSelfStartTX_f.Connect(node_container[m],(compcxx_component::Node_outportSelfStartTX_f_t)&compcxx_Node_23::InportSomeNodeStartTX) /*connect node_container[n].outportSelfStartTX,node_container[m].InportSomeNodeStartTX*/;
			node_container[n].outportSelfFinishTX_f.Connect(node_container[m],(compcxx_component::Node_outportSelfFinishTX_f_t)&compcxx_Node_23::InportSomeNodeFinishTX) /*connect node_container[n].outportSelfFinishTX,node_container[m].InportSomeNodeFinishTX*/;
			node_container[n].outportSendLogicalNack_f.Connect(node_container[m],(compcxx_component::Node_outportSendLogicalNack_f_t)&compcxx_Node_23::InportNackReceived) /*connect node_container[n].outportSendLogicalNack,node_container[m].InportNackReceived*/;

			
			if(strcmp(node_container[n].wlan_code.c_str(),node_container[m].wlan_code.c_str()) == 0 && n!=m) {
				
				node_container[n].outportAskForTxModulation_f.Connect(node_container[m],(compcxx_component::Node_outportAskForTxModulation_f_t)&compcxx_Node_23::InportMCSRequestReceived) /*connect node_container[n].outportAskForTxModulation,node_container[m].InportMCSRequestReceived*/;
				node_container[n].outportAnswerTxModulation_f.Connect(node_container[m],(compcxx_component::Node_outportAnswerTxModulation_f_t)&compcxx_Node_23::InportMCSResponseReceived) /*connect node_container[n].outportAnswerTxModulation,node_container[m].InportMCSResponseReceived*/;
				
				node_container[n].outportSetNewWlanConfiguration_f.Connect(node_container[m],(compcxx_component::Node_outportSetNewWlanConfiguration_f_t)&compcxx_Node_23::InportNewWlanConfigurationReceived) /*connect node_container[n].outportSetNewWlanConfiguration,node_container[m].InportNewWlanConfigurationReceived*/;
				
				if(node_container[n].node_type == NODE_TYPE_AP && node_container[m].node_type == NODE_TYPE_STA) {
					node_container[m].outportRequestSpatialReuseConfiguration_f.Connect(node_container[n],(compcxx_component::Node_outportRequestSpatialReuseConfiguration_f_t)&compcxx_Node_23::InportRequestSpatialReuseConfiguration) /*connect node_container[m].outportRequestSpatialReuseConfiguration,node_container[n].InportRequestSpatialReuseConfiguration*/;
					node_container[n].outportNewSpatialReuseConfiguration_f.Connect(node_container[m],(compcxx_component::Node_outportNewSpatialReuseConfiguration_f_t)&compcxx_Node_23::InportNewSpatialReuseConfiguration) /*connect node_container[n].outportNewSpatialReuseConfiguration,node_container[m].InportNewSpatialReuseConfiguration*/;
				}
			}
		}

		if (agents_enabled) {
			
			if ( node_container[n].node_type == NODE_TYPE_AP ) {
				for(int w = 0; w < total_agents_number; ++w){
					
					if (strcmp(node_container[n].wlan_code.c_str(), agent_container[w].wlan_code.c_str()) == 0) {

						agent_container[w].outportRequestInformationToAp_f.Connect(node_container[n],(compcxx_component::Agent_outportRequestInformationToAp_f_t)&compcxx_Node_23::InportReceivingRequestFromAgent) /*connect agent_container[w].outportRequestInformationToAp,node_container[n].InportReceivingRequestFromAgent*/;
						node_container[n].outportAnswerToAgent_f.Connect(agent_container[w],(compcxx_component::Node_outportAnswerToAgent_f_t)&compcxx_Agent_25::InportReceivingInformationFromAp) /*connect node_container[n].outportAnswerToAgent,agent_container[w].InportReceivingInformationFromAp*/;
						agent_container[w].outportSendConfigurationToAp_f.Connect(node_container[n],(compcxx_component::Agent_outportSendConfigurationToAp_f_t)&compcxx_Node_23::InportReceiveConfigurationFromAgent) /*connect agent_container[w].outportSendConfigurationToAp,node_container[n].InportReceiveConfigurationFromAgent*/;
					}
				}
			}
		}
	}

	
	if (agents_enabled && central_controller_flag) {
		for(int w = 0; w < total_agents_number; ++w){
			if(agent_container[w].agent_centralized && central_controller[0].controller_on) {

				agent_container[w].outportAnswerToController_f.Connect(central_controller[0],(compcxx_component::Agent_outportAnswerToController_f_t)&compcxx_CentralController_26::InportReceivingInformationFromAgent) /*connect agent_container[w].outportAnswerToController,central_controller[0].InportReceivingInformationFromAgent*/;
				central_controller[0].outportSendCommandToAgent_f.Connect(agent_container[w],(compcxx_component::CentralController_outportSendCommandToAgent_f_t)&compcxx_Agent_25::InportReceiveCommandFromController) /*connect central_controller[0].outportSendCommandToAgent,agent_container[w].InportReceiveCommandFromController*/;
			}
		}
	}
}
#line 368 "komondor_main.cc"
void compcxx_Komondor_27 :: Start(){
	
}
#line 375 "komondor_main.cc"
void compcxx_Komondor_27 :: Stop(){

	printf("\n%s STOP KOMONDOR SIMULATION '%s' (seed %d)", LOG_LVL1, simulation_code.c_str(), seed);

	
	Performance *performance_per_node = new Performance[total_nodes_number];
	Configuration *configuration_per_node = new Configuration[total_nodes_number];
	for (int i = 0; i < total_nodes_number; ++i) {
		performance_per_node[i] = node_container[i].simulation_performance;
		configuration_per_node[i] = node_container[i].configuration;
	}

	
	GenerateScriptOutput(simulation_index, performance_per_node, configuration_per_node, logger_script,
		total_wlans_number, total_nodes_number, wlan_container, simulation_time_komondor);

	
	fclose(script_output_file);

	printf("%s SIMULATION '%s' FINISHED\n", LOG_LVL1, simulation_code.c_str());
	printf("------------------------------------------\n");

}
#line 402 "komondor_main.cc"
void compcxx_Komondor_27 :: InputChecker(){

	
	int nodes_ids[total_nodes_number];
	double nodes_x[total_nodes_number];
	double nodes_y[total_nodes_number];
	double nodes_z[total_nodes_number];
	for(int i = 0; i<total_nodes_number;++i){
		nodes_ids[i] = 0;
		nodes_x[i] = 0;
		nodes_y[i] = 0;
		nodes_z[i] = 0;
	}

	if (print_system_logs) printf("%s Validating input files...\n", LOG_LVL2);

	for (int i = 0; i < total_nodes_number; ++i) {

		nodes_ids[i] = node_container[i].node_id;
		nodes_x[i] = node_container[i].x;
		nodes_y[i] = node_container[i].y;
		nodes_z[i] = node_container[i].z;

		
		if (node_container[i].tx_power_default > ConvertPower(DBM_TO_PW, MAX_TX_POWER_DBM)
				|| node_container[i].tx_power_default < ConvertPower(DBM_TO_PW, MIN_TX_POWER_DBM)) {
			printf("\nERROR: tx_power values are not properly configured at node in line %d\n"
				"MIN_TX_POWER_DBM = %d\nnode_container[i].tx_power_default = %f\nMAX_TX_POWER_DBM = %d\n\n",
				i+2, MIN_TX_POWER_DBM, ConvertPower(PW_TO_DBM, node_container[i].tx_power_default), MAX_TX_POWER_DBM);
			exit(-1);
		}

		
		if (node_container[i].sensitivity_default > ConvertPower(DBM_TO_PW,MAX_SENSITIVITY_DBM)
				|| node_container[i].sensitivity_default > ConvertPower(DBM_TO_PW,MAX_SENSITIVITY_DBM)) {
			printf("\nERROR: sensitivity values are not properly configured at node in line %d\n\n",i+2);
			exit(-1);
		}

		
		if (node_container[i].current_primary_channel > node_container[i].max_channel_allowed
				|| node_container[i].current_primary_channel < node_container[i].min_channel_allowed
				|| node_container[i].min_channel_allowed > node_container[i].max_channel_allowed
				|| node_container[i].current_primary_channel > NUM_CHANNELS_KOMONDOR
				|| node_container[i].min_channel_allowed > (NUM_CHANNELS_KOMONDOR-1)
				|| node_container[i].max_channel_allowed > (NUM_CHANNELS_KOMONDOR-1)) {
			printf("\nERROR: Channels are not properly configured at node in line %d\n\n",i+2);
			exit(-1);
		}
	}

	for (int i = 0; i < total_nodes_number; ++i) {
		for (int j = 0; j < total_nodes_number; ++j) {
			
			if(i!=j && nodes_ids[i] == nodes_ids[j] && i < j) {
				printf("\nERROR: Nodes in lines %d and %d have the same ID\n\n",i+2,j+2);
				exit(-1);
			}
			
			if(i!=j && nodes_x[i] == nodes_x[j] && nodes_y[i] == nodes_y[j] && nodes_z[i] == nodes_z[j] && i < j) {
				printf("%s nERROR: Nodes in lines %d and %d are exactly at the same position\n\n", LOG_LVL2, i+2,j+2);
				exit(-1);
			}
		}
	}

	if (print_system_logs) printf("%s Input files validated!\n", LOG_LVL3);

}






#line 476 "komondor_main.cc"
void compcxx_Komondor_27 :: SetupEnvironmentByReadingConfigFile() {

	const char *filename_test = "../config_models";
	char delim[] = "=";
	char *ptr;
	int ix_param = 0;
	if (print_system_logs) printf("\n%s Reading system configuration file '%s'...\n", LOG_LVL1, filename_test);
	FILE* test_input_config = fopen(filename_test, "r");
	if (!test_input_config){
		printf("%s Test file '%s' not found!\n", LOG_LVL3, filename_test);
		exit(-1);
	}
	char line_system[CHAR_BUFFER_SIZE];
	while (fgets(line_system, CHAR_BUFFER_SIZE, test_input_config)){
		
		if(line_system[0] == '#') {
			continue;
		}
		
		ptr = strtok(line_system, delim);
		ptr = strtok(NULL, delim);
		
		if (ix_param == 0){
			
			path_loss_model = atoi(ptr);
		} else if (ix_param == 1) {
			
			adjacent_channel_model = atoi(ptr);
		} else if (ix_param == 2) {
			
			collisions_model = atoi(ptr);
		} else if (ix_param == 3) {
			
			backoff_type = atoi(ptr);
		} else if (ix_param == 4) {
			
			pdf_backoff = atoi(ptr);
		} else if (ix_param == 5) {
			
			pdf_tx_time = atoi(ptr);
		} else if (ix_param == 6) {
			
			simulation_index = atoi(ptr);
		}
		ix_param++;
	}
	fclose(test_input_config);

	if (print_system_logs) printf("%s System environment properly set!\n", LOG_LVL2);

}











#line 537 "komondor_main.cc"
void compcxx_Komondor_27 :: GenerateNodesByReadingInputFile(const char *nodes_filename) {

	if (print_system_logs) printf("\n%s Generating nodes DETERMINISTICALLY through NODES input file...\n", LOG_LVL1);

	if (print_system_logs) printf("%s Reading nodes input file '%s'...\n", LOG_LVL2, nodes_filename);

		total_wlans_number = GetNumOfNodes(nodes_filename, NODE_TYPE_AP, ToString(""));
		if (print_system_logs) printf("%s Num. of WLANs detected: %d\n", LOG_LVL3, total_wlans_number);
		wlan_container = new Wlan[total_wlans_number];
		FILE* stream_nodes = fopen(nodes_filename, "r");
		char line_nodes[CHAR_BUFFER_SIZE];
		first_line_skiped_flag = 0;	
		int wlan_ix (0);			

		
		while (fgets(line_nodes, CHAR_BUFFER_SIZE, stream_nodes)){
			if(!first_line_skiped_flag){	
				first_line_skiped_flag = 1;
			} else{
				
				tmp_nodes = strdup(line_nodes);
				int node_type (atoi(GetField(tmp_nodes, IX_NODE_TYPE)));
				if(node_type == NODE_TYPE_AP){	
					
					wlan_container[wlan_ix].wlan_id = wlan_ix;
					
					tmp_nodes = strdup(line_nodes);
					std::string wlan_code_aux = ToString(GetField(tmp_nodes, IX_WLAN_CODE));
					wlan_container[wlan_ix].wlan_code = wlan_code_aux;
					++wlan_ix;
					free(tmp_nodes);
				}
			}
		}

		
		for(int w = 0; w < total_wlans_number; ++w){
			int num_stas_in_wlan (GetNumOfNodes(nodes_filename, NODE_TYPE_STA, wlan_container[w].wlan_code));
			wlan_container[w].num_stas = num_stas_in_wlan;
			wlan_container[w].SetSizeOfSTAsArray(num_stas_in_wlan);
		}

		
		if (print_system_logs) printf("%s Generating nodes...\n", LOG_LVL3);
		total_nodes_number = GetNumOfNodes(nodes_filename, NODE_TYPE_UNKWNOW, ToString(""));
		node_container.SetSize(total_nodes_number);
		traffic_generator_container.SetSize(total_nodes_number);
		stream_nodes = fopen(nodes_filename, "r");
		int node_ix (0);	
		wlan_ix = 0;		
		first_line_skiped_flag = 0;

		while (fgets(line_nodes, CHAR_BUFFER_SIZE, stream_nodes)){	

			if(!first_line_skiped_flag){	
				first_line_skiped_flag = 1;
			} else {
				
				node_container[node_ix].node_id = node_ix;
				
				tmp_nodes = strdup(line_nodes);
				std::string node_code = ToString(GetField(tmp_nodes, IX_NODE_CODE));
				node_container[node_ix].node_code = node_code;
				
				tmp_nodes = strdup(line_nodes);
				int node_type (atoi(GetField(tmp_nodes, IX_NODE_TYPE)));
				node_container[node_ix].node_type = node_type;
				
				tmp_nodes = strdup(line_nodes);
				const char *wlan_code_aux (GetField(tmp_nodes, IX_WLAN_CODE));
				std::string wlan_code;
				wlan_code.append(ToString(wlan_code_aux));
				node_container[node_ix].wlan_code = wlan_code;
				for(int w = 0; w < total_wlans_number; ++w){
					if(strcmp(wlan_code.c_str(), wlan_container[w].wlan_code.c_str()) == 0){	
						if(node_container[node_ix].node_type == NODE_TYPE_AP){	
							wlan_container[w].ap_id = node_container[node_ix].node_id;
						} else if (node_container[node_ix].node_type == NODE_TYPE_STA){	
							for(int s = 0; s < wlan_container[w].num_stas; ++s){
								if(wlan_container[w].list_sta_id[s] == NODE_ID_NONE){
									wlan_container[w].list_sta_id[s] = node_container[node_ix].node_id;
									break;
								}
							}
						}
					}
				}
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].x = atof(GetField(tmp_nodes, IX_POSITION_X));
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].y = atof(GetField(tmp_nodes, IX_POSITION_Y));
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].z = atof(GetField(tmp_nodes, IX_POSITION_Z));
				
				tmp_nodes = strdup(line_nodes);
				const char* central_frequency_char (GetField(tmp_nodes, IX_CENTRAL_FREQ));
				node_container[node_ix].central_frequency = atof(central_frequency_char) * pow(10,9);
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].current_dcb_policy = atoi(GetField(tmp_nodes, IX_CHANNEL_BONDING_MODEL));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].current_primary_channel = atoi(GetField(tmp_nodes, IX_PRIMARY_CHANNEL));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].min_channel_allowed = atoi(GetField(tmp_nodes, IX_MIN_CH_ALLOWED));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].max_channel_allowed = atoi(GetField(tmp_nodes, IX_MAX_CH_ALLOWED));
				
				tmp_nodes = strdup(line_nodes);
				double tx_power_default_dbm (atof(GetField(tmp_nodes, IX_TX_POWER_DEFAULT)));
				node_container[node_ix].tx_power_default = ConvertPower(DBM_TO_PW, tx_power_default_dbm);
				
				tmp_nodes = strdup(line_nodes);
				double sensitivity_default_dbm (atoi(GetField(tmp_nodes, IX_PD_DEFAULT)));
				node_container[node_ix].sensitivity_default = ConvertPower(DBM_TO_PW, sensitivity_default_dbm);
				
				tmp_nodes = strdup(line_nodes);
				const char* traffic_model_char (GetField(tmp_nodes, IX_TRAFFIC_MODEL));
				
				tmp_nodes = strdup(line_nodes);
				const char* traffic_load_char (GetField(tmp_nodes, IX_TRAFFIC_LOAD));
				
				tmp_nodes = strdup(line_nodes);
				const char* packet_length_char (GetField(tmp_nodes, IX_PACKET_LENGTH));
				node_container[node_ix].frame_length = atoi(packet_length_char);
				
				tmp_nodes = strdup(line_nodes);
				const char* packets_aggregated_char (GetField(tmp_nodes, IX_NUM_PACKETS_AGG));
				node_container[node_ix].max_num_packets_aggregated = atoi(packets_aggregated_char);
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].capture_effect_model = atoi(GetField(tmp_nodes, IX_CAPTURE_EFFECT_MODEL));
				
				tmp_nodes = strdup(line_nodes);
				const char* capture_effect_char (GetField(tmp_nodes, IX_CAPTURE_EFFECT_THR));
				node_container[node_ix].capture_effect = ConvertPower(DB_TO_LINEAR, atof(capture_effect_char));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].constant_per = atof(GetField(tmp_nodes, IX_CONSTANT_PER));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].pifs_activated = atoi(GetField(tmp_nodes, IX_PIFS_ACTIVATED));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].cw_adaptation = atoi(GetField(tmp_nodes, IX_CW_ADAPTATION_FLAG));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].cw_min = atoi(GetField(tmp_nodes, IX_CW_MIN));
				
				tmp_nodes = strdup(line_nodes);
				node_container[node_ix].cw_stage_max = atoi(GetField(tmp_nodes, IX_CW_STAGE_MAX));
				
				
				tmp_nodes = strdup(line_nodes);
				const char* bss_color_char = GetField(tmp_nodes, IX_BSS_COLOR);
				
				tmp_nodes = strdup(line_nodes);
				const char* srg_char = GetField(tmp_nodes, IX_SRG);
				
				tmp_nodes = strdup(line_nodes);
				const char* non_srg_obss_pd_char = GetField(tmp_nodes, IX_NON_SRG_OBSS_PD);
				
				tmp_nodes = strdup(line_nodes);
				const char* srg_obss_pd_char = GetField(tmp_nodes, IX_SRG_OBSS_PD);
				
				node_container[node_ix].simulation_time_komondor = simulation_time_komondor;
				node_container[node_ix].total_wlans_number = total_wlans_number;
				node_container[node_ix].total_nodes_number = total_nodes_number;
				node_container[node_ix].collisions_model = collisions_model;
				node_container[node_ix].save_node_logs = save_node_logs;
				node_container[node_ix].print_node_logs = print_node_logs;
				node_container[node_ix].adjacent_channel_model = adjacent_channel_model;
				node_container[node_ix].pdf_backoff = pdf_backoff;
				node_container[node_ix].path_loss_model = path_loss_model;
				node_container[node_ix].pdf_tx_time = pdf_tx_time;
				node_container[node_ix].backoff_type = backoff_type;
				node_container[node_ix].simulation_code = simulation_code;
				
				if (bss_color_char != NULL) { 
					node_container[node_ix].bss_color = atoi(bss_color_char);
					node_container[node_ix].srg = atoi(srg_char);
					double non_srg_obss_pd_dbm = atof(non_srg_obss_pd_char);
					node_container[node_ix].non_srg_obss_pd = ConvertPower(DBM_TO_PW, non_srg_obss_pd_dbm);
					double srg_obss_pd_dbm = atof(srg_obss_pd_char);
					node_container[node_ix].srg_obss_pd = ConvertPower(DBM_TO_PW, srg_obss_pd_dbm);
				} else {
					node_container[node_ix].bss_color = -1;
					node_container[node_ix].srg = -1;
					node_container[node_ix].non_srg_obss_pd = -1;
					node_container[node_ix].srg_obss_pd = -1;
				}
				
				traffic_generator_container[node_ix].node_type = node_type;
				traffic_generator_container[node_ix].node_id = node_ix;
				traffic_generator_container[node_ix].traffic_model = atoi(traffic_model_char);
				node_container[node_ix].traffic_model = atoi(traffic_model_char); 
				traffic_generator_container[node_ix].traffic_load = atof(traffic_load_char);

				++node_ix;
				free(tmp_nodes);
			}
		}
		
		for(int n = 0; n < total_nodes_number; ++n){
			for(int w = 0; w < total_wlans_number; ++w){
				if (strcmp(node_container[n].wlan_code.c_str(), wlan_container[w].wlan_code.c_str()) == 0) {
					node_container[n].wlan = wlan_container[w];
				}
			}
		}

		if (print_system_logs) printf("%s Nodes generated!\n", LOG_LVL3);
}






#line 758 "komondor_main.cc"
void compcxx_Komondor_27 :: GenerateAgents(const char *agents_filename, const char *simulation_code_console) {

	if (print_system_logs) printf("%s Generating agents...\n", LOG_LVL1);
	if (print_system_logs) printf("%s Reading agents input file '%s'...\n", LOG_LVL2, agents_filename);

	
	central_controller_flag = CheckCentralController(agents_filename);
	
	total_agents_number = GetNumOfLines(agents_filename) - central_controller_flag;
	agent_container.SetSize(total_agents_number);
	if (print_system_logs) printf("%s Num. of agents (WLANs): %d/%d\n", LOG_LVL3, total_agents_number, total_wlans_number);
	
	if (print_system_logs) printf("%s Setting action space...\n", LOG_LVL4);
	FILE* stream_agents = fopen(agents_filename, "r");
	char line_agents[CHAR_BUFFER_SIZE];
	first_line_skiped_flag = 0;	
	int agent_ix (0);	
	while (fgets(line_agents, CHAR_BUFFER_SIZE, stream_agents)){
		if(!first_line_skiped_flag){	
			first_line_skiped_flag = 1;
		} else{
			char* tmp_agents = strdup(line_agents);
			const char *wlan_code_aux (GetField(tmp_agents, IX_AGENT_WLAN_CODE));
			std::string wlan_code;
			wlan_code.append(ToString(wlan_code_aux));
			
			if (strcmp(wlan_code.c_str(), "NULL") == 0) continue;
			
			tmp_agents = strdup(line_agents);
			const char *channel_values_aux (GetField(tmp_agents, IX_AGENT_CHANNEL_VALUES));
			std::string channel_values_text;
			channel_values_text.append(ToString(channel_values_aux));
			const char *channel_aux;
			channel_aux = strtok ((char*)channel_values_text.c_str(),",");
			num_arms_channel = 0;
			while (channel_aux != NULL) {
				channel_aux = strtok (NULL, ",");
				++ num_arms_channel;
			}
			
			agent_container[agent_ix].num_arms_channel = num_arms_channel;
			
			tmp_agents = strdup(line_agents);
			const char *pd_values_aux (GetField(tmp_agents, IX_AGENT_PD_VALUES));
			std::string pd_values_text;
			pd_values_text.append(ToString(pd_values_aux));
			const char *pd_aux;
			pd_aux = strtok ((char*)pd_values_text.c_str(),",");
			num_arms_sensitivity = 0;
			while (pd_aux != NULL) {
				pd_aux = strtok (NULL, ",");
				++ num_arms_sensitivity;
			}
			
			agent_container[agent_ix].num_arms_sensitivity = num_arms_sensitivity;
			
			tmp_agents = strdup(line_agents);
			const char *tx_power_values_aux (GetField(tmp_agents, IX_AGENT_TX_POWER_VALUES));
			std::string tx_power_values_text;
			tx_power_values_text.append(ToString(tx_power_values_aux));
			const char *tx_power_aux;
			tx_power_aux = strtok ((char*)tx_power_values_text.c_str(),",");
			num_arms_tx_power = 0;
			while (tx_power_aux != NULL) {
				tx_power_aux = strtok (NULL, ",");
				++ num_arms_tx_power;
			}
			
			agent_container[agent_ix].num_arms_tx_power = num_arms_tx_power;
			
			tmp_agents = strdup(line_agents);
			const char *max_bandwidth_values_aux (GetField(tmp_agents, IX_AGENT_MAX_BANDWIDTH));
			std::string max_bandwidth_values_text;
			max_bandwidth_values_text.append(ToString(max_bandwidth_values_aux));
			const char *max_bandwidth_aux;
			max_bandwidth_aux = strtok ((char*)max_bandwidth_values_text.c_str(),",");
			num_arms_max_bandwidth = 0;
			while (max_bandwidth_aux != NULL) {
				max_bandwidth_aux = strtok (NULL, ",");
				++num_arms_max_bandwidth;
			}
			
			agent_container[agent_ix].num_arms_max_bandwidth = num_arms_max_bandwidth;

			
			agent_container[agent_ix].num_arms = num_arms_channel * num_arms_sensitivity
				* num_arms_tx_power * num_arms_max_bandwidth;

			
			agent_container[agent_ix].simulation_code.append(ToString(simulation_code_console));

			++agent_ix;
			free(tmp_agents);
		}
	}

	if (print_system_logs) printf("%s Action space set!\n", LOG_LVL4);

	
	if (print_system_logs) printf("%s Setting agents parameters...\n", LOG_LVL4);
	stream_agents = fopen(agents_filename, "r");
	first_line_skiped_flag = 0;		
	agent_ix = 0;	
	total_controlled_agents_number = 0;
	while (fgets(line_agents, CHAR_BUFFER_SIZE, stream_agents)){
		if(!first_line_skiped_flag){	
			first_line_skiped_flag = 1;
		} else{
			
			char* tmp_agents (strdup(line_agents));
			const char *wlan_code_aux (GetField(tmp_agents, IX_AGENT_WLAN_CODE));
			std::string wlan_code;
			wlan_code.append(ToString(wlan_code_aux));
			
			if (strcmp(wlan_code.c_str(), "NULL") == 0) {
				continue;
			} else {
				
				agent_container[agent_ix].agent_id = agent_ix;
				agent_container[agent_ix].wlan_code = wlan_code.c_str();
				
				for(int w=0; w < total_wlans_number; ++w){
					if(strcmp(wlan_container[w].wlan_code.c_str(), agent_container[agent_ix].wlan_code.c_str()) == 0) {
						agent_container[agent_ix].wlan_id = w;
					}
				}
				
				agent_container[agent_ix].InitializeAgent();
				
				tmp_agents = strdup(line_agents);
				int agent_centralized (atoi(GetField(tmp_agents, IX_COMMUNICATION_LEVEL)));
				agent_container[agent_ix].agent_centralized = agent_centralized;
				
				if(agent_centralized) ++total_controlled_agents_number;
				
				tmp_agents = strdup(line_agents);
				double time_between_requests (atof(GetField(tmp_agents, IX_AGENT_TIME_BW_REQUESTS)));
				agent_container[agent_ix].time_between_requests = time_between_requests;
				
				tmp_agents = strdup(line_agents);
				std::string channel_values_text = ToString(GetField(tmp_agents, IX_AGENT_CHANNEL_VALUES));
				
				char *channel_aux_2;
				char *channel_values_text_char = new char[channel_values_text.length() + 1];
				strcpy(channel_values_text_char, channel_values_text.c_str());
				channel_aux_2 = strtok (channel_values_text_char,",");
				int ix (0);
				while (channel_aux_2 != NULL) {
					int a (atoi(channel_aux_2));
					agent_container[agent_ix].list_of_channels[ix] = a;
					channel_aux_2 = strtok (NULL, ",");
					++ix;
				}
				
				tmp_agents = strdup(line_agents);
				std::string pd_values_text = ToString(GetField(tmp_agents, IX_AGENT_PD_VALUES));
				
				char *pd_aux_2;
				char *pd_values_text_char = new char[pd_values_text.length() + 1];
				strcpy(pd_values_text_char, pd_values_text.c_str());
				pd_aux_2 = strtok (pd_values_text_char,",");
				ix = 0;
				while (pd_aux_2 != NULL) {
					int a = atoi(pd_aux_2);
					agent_container[agent_ix].list_of_pd_values[ix] = ConvertPower(DBM_TO_PW, a);
					pd_aux_2 = strtok (NULL, ",");
					++ix;
				}
				
				tmp_agents = strdup(line_agents);
				std::string tx_power_values_text = ToString(GetField(tmp_agents, IX_AGENT_TX_POWER_VALUES));
				
				char *tx_power_aux_2;
				char *tx_power_values_text_char = new char[tx_power_values_text.length() + 1];
				strcpy(tx_power_values_text_char, tx_power_values_text.c_str());
				tx_power_aux_2 = strtok (tx_power_values_text_char,",");
				ix = 0;
				while (tx_power_aux_2 != NULL) {
					int a (atoi(tx_power_aux_2));
					agent_container[agent_ix].list_of_tx_power_values[ix] = ConvertPower(DBM_TO_PW, a);
					tx_power_aux_2 = strtok (NULL, ",");
					++ix;
				}
				
				tmp_agents = strdup(line_agents);
				std::string max_bandwidth_values_text = ToString(GetField(tmp_agents, IX_AGENT_MAX_BANDWIDTH));
				
				char *max_bandwidth_aux_2;
				char *max_bandwidth_values_text_char = new char[max_bandwidth_values_text.length() + 1];
				strcpy(max_bandwidth_values_text_char, max_bandwidth_values_text.c_str());
				max_bandwidth_aux_2 = strtok (max_bandwidth_values_text_char,",");
				ix = 0;
				while (max_bandwidth_aux_2 != NULL) {
					int a (atoi(max_bandwidth_aux_2));
					agent_container[agent_ix].list_of_max_bandwidth[ix] = a;
					max_bandwidth_aux_2 = strtok (NULL, ",");
					++ix;
				}
				
				tmp_agents = strdup(line_agents);
				int type_of_reward (atoi(GetField(tmp_agents, IX_AGENT_TYPE_OF_REWARD)));
				agent_container[agent_ix].type_of_reward = type_of_reward;
				
				tmp_agents = strdup(line_agents);
				int learning_mechanism (atoi(GetField(tmp_agents, IX_AGENT_LEARNING_MECHANISM)));
				agent_container[agent_ix].learning_mechanism = learning_mechanism;
				
				tmp_agents = strdup(line_agents);
				int action_selection_strategy (atoi(GetField(tmp_agents, IX_AGENT_SELECTED_STRATEGY)));
				agent_container[agent_ix].action_selection_strategy = action_selection_strategy;
				
				agent_container[agent_ix].save_agent_logs = save_agent_logs;
				agent_container[agent_ix].print_agent_logs = print_agent_logs;
				agent_container[agent_ix].num_stas = wlan_container[agent_container[agent_ix].wlan_id].num_stas;
				
				if(agent_container[agent_ix].learning_mechanism == RTOT_ALGORITHM) {
					agent_container[agent_ix].margin_rtot = agent_container[agent_ix].list_of_pd_values[0];
				}

				agent_container[agent_ix].PrintAgentInfo();

				++agent_ix;

			}
			free(tmp_agents);
		}
	}
	if (print_system_logs) printf("%s Agents parameters set!\n", LOG_LVL4);

}






#line 993 "komondor_main.cc"
void compcxx_Komondor_27 :: GenerateCentralController(const char *agents_filename) {

	if (print_system_logs) printf("%s Generating the Central Controller...\n", LOG_LVL1);
	
	if (central_controller_flag) central_controller.SetSize(1);
	if (total_controlled_agents_number > 0) {	
		central_controller[0].controller_on = TRUE;
		central_controller[0].agents_number = total_controlled_agents_number;
		central_controller[0].wlans_number = total_wlans_number;
		int max_number_of_actions(0);
		for (int agent_ix = 0; agent_ix < total_controlled_agents_number; ++agent_ix) {
			if(agent_container[agent_ix].num_arms > max_number_of_actions) max_number_of_actions = agent_container[agent_ix].num_arms;
		}
		central_controller[0].max_number_of_actions = max_number_of_actions;
		
		central_controller[0].InitializeCentralController();
		int *agents_list;
		agents_list = new int[total_controlled_agents_number];
		int agent_list_ix (0);					


		
		for (int agent_ix = 0; agent_ix < total_controlled_agents_number; ++agent_ix) {
			if(agent_container[agent_ix].agent_centralized) {
				
				agents_list[agent_list_ix] = agent_container[agent_ix].agent_id;
				agent_container[agent_ix].controller_on = central_controller[0].controller_on;
				central_controller[0].num_arms_per_agent[agent_ix] = agent_container[agent_ix].num_arms;





				++agent_list_ix;
			}
		}

		
		central_controller[0].list_of_agents = agents_list;
		
		FILE* stream_cc = fopen(agents_filename, "r");
		char line_agents[CHAR_BUFFER_SIZE];
		char* tmp_cc (strdup(line_agents));
		first_line_skiped_flag = 0;		
		while (fgets(line_agents, CHAR_BUFFER_SIZE, stream_cc)){
			if(!first_line_skiped_flag){
				first_line_skiped_flag = 1;
			} else{
				tmp_cc = strdup(line_agents);
				const char *wlan_code_aux (GetField(tmp_cc, IX_AGENT_WLAN_CODE));
				std::string wlan_code;
				wlan_code.append(ToString(wlan_code_aux));
				
				if (strcmp(wlan_code.c_str(), "NULL") == 0) {
					
					tmp_cc = strdup(line_agents);
					double time_between_requests (atoi(GetField(tmp_cc, IX_AGENT_TIME_BW_REQUESTS)));
					central_controller[0].time_between_requests = time_between_requests;
					
					tmp_cc = strdup(line_agents);
					int type_of_reward (atoi(GetField(tmp_cc, IX_AGENT_TYPE_OF_REWARD)));
					central_controller[0].type_of_reward = type_of_reward;
					
					tmp_cc = strdup(line_agents);
					int learning_mechanism (atoi(GetField(tmp_cc, IX_AGENT_LEARNING_MECHANISM)));
					central_controller[0].learning_mechanism = learning_mechanism;
					
					tmp_cc = strdup(line_agents);
					int action_selection_strategy (atoi(GetField(tmp_cc, IX_AGENT_SELECTED_STRATEGY)));
					central_controller[0].action_selection_strategy = action_selection_strategy;
					
					tmp_cc = strdup(line_agents);
					const char *channel_values_aux (GetField(tmp_cc, IX_AGENT_CHANNEL_VALUES));
					std::string channel_values_text;
					channel_values_text.append(ToString(channel_values_aux));
					const char *channels_aux;
					channels_aux = strtok ((char*)channel_values_text.c_str(),",");
					int num_arms_channels = 0;
					while (channels_aux != NULL) {
						channels_aux = strtok (NULL, ",");
						++ num_arms_channels;
					}
					free(tmp_cc);
					break;	
				} else {
					continue; 
				}
			}
		}

		
		central_controller[0].save_controller_logs = save_agent_logs;
		central_controller[0].print_controller_logs = print_agent_logs;
		central_controller[0].total_nodes_number = total_nodes_number;

	} else {
		printf("%s WARNING: THE CENTRAL CONTROLLER DOES NOT HAVE ANY ATTACHED AGENT! CHECK YOUR AGENTS' INPUT FILE\n", LOG_LVL2);
		central_controller[0].controller_on = FALSE;
	}

	central_controller[0].PrintControllerInfo();

}









#line 1104 "komondor_main.cc"
void compcxx_Komondor_27 :: PrintSystemInfo(){
	if (print_system_logs){
		printf("%s total_nodes_number = %d\n", LOG_LVL3, total_nodes_number);
		printf("%s pdf_backoff = %d\n", LOG_LVL3, pdf_backoff);
		printf("%s pdf_tx_time = %d\n", LOG_LVL3, pdf_tx_time);
		printf("%s backoff_type = %d\n", LOG_LVL3, backoff_type);
		printf("%s path_loss_model = %d\n", LOG_LVL3, path_loss_model);
		printf("%s adjacent_channel_model = %d\n", LOG_LVL3, adjacent_channel_model);
		printf("%s collisions_model = %d\n", LOG_LVL3, collisions_model);
		printf("\n");
	}
}






#line 1121 "komondor_main.cc"
void compcxx_Komondor_27 :: WriteSystemInfo(Logger logger){
	fprintf(logger.file, "%s total_nodes_number = %d\n", LOG_LVL3, total_nodes_number);
	fprintf(logger.file, "%s pdf_backoff = %d\n", LOG_LVL3, pdf_backoff);
	fprintf(logger.file, "%s pdf_tx_time = %d\n", LOG_LVL3, pdf_tx_time);
	fprintf(logger.file, "%s path_loss_model = %d\n", LOG_LVL3, path_loss_model);
	fprintf(logger.file, "%s adjacent_channel_model = %d\n", LOG_LVL3, adjacent_channel_model);
	fprintf(logger.file, "%s collisions_model = %d\n", LOG_LVL3, collisions_model);
}






#line 1134 "komondor_main.cc"
void compcxx_Komondor_27 :: PrintAllNodesInfo(int info_detail_level){
	for(int n = 0; n < total_nodes_number; ++n ){
		node_container[n].PrintNodeInfo(info_detail_level);
	}
}





#line 1143 "komondor_main.cc"
void compcxx_Komondor_27 :: PrintAllWlansInfo(){
	for(int w = 0; w < total_wlans_number; ++w){
		wlan_container[w].PrintWlanInfo();
	}
}





#line 1152 "komondor_main.cc"
void compcxx_Komondor_27 :: PrintMlOperationInfo(){
	printf("%s Agents generated!\n\n", LOG_LVL2);
	for(int a = 0; a < total_agents_number; ++a ){
		agent_container[a].PrintAgentInfo();
	}
	if (central_controller_flag) {
		printf("%s Central Controller generated!\n\n", LOG_LVL2);
		central_controller[0].PrintControllerInfo();
	}
}







#line 1168 "komondor_main.cc"
void compcxx_Komondor_27 :: WriteAllWlansInfo(Logger logger, std::string header_str){
	for(int w = 0; w < total_wlans_number; ++w){
		wlan_container[w].WriteWlanInfo(logger, header_str.c_str());
	}
}








#line 1180 "komondor_main.cc"
void compcxx_Komondor_27 :: WriteAllNodesInfo(Logger logger, int info_detail_level, std::string header_str){
	for(int n = 0; n < total_nodes_number; ++n){
		node_container[n].WriteNodeInfo(logger, info_detail_level, header_str.c_str());
	}
}







#line 1191 "komondor_main.cc"
void compcxx_Komondor_27 :: WriteAllAgentsInfo(Logger logger, std::string header_str){
	for(int n = 0; n < total_agents_number; ++n){
		agent_container[n].WriteAgentInfo(logger, header_str.c_str());
	}
	if (central_controller_flag) {
		central_controller[0].WriteControllerInfo(logger);
	}
}













#line 1228 "komondor_main.cc"
int compcxx_Komondor_27 :: GetNumOfLines(const char *filename){
	int num_lines (0);
	
	FILE* stream = fopen(filename, "r");
	if (!stream){
		printf("Nodes configuration file %s not found!\n", filename);
		exit(-1);
	}
	char line[CHAR_BUFFER_SIZE];
	while (fgets(line, CHAR_BUFFER_SIZE, stream))
	{
		++num_lines;
	}
	num_lines--;
	fclose(stream);
	return num_lines;
}









#line 1253 "komondor_main.cc"
int compcxx_Komondor_27 :: GetNumOfNodes(const char *nodes_filename, int node_type, std::string wlan_code){

	int num_nodes(0);
	char line_nodes[CHAR_BUFFER_SIZE];
	first_line_skiped_flag = 0;
	int type_found;
	std::string wlan_code_found;

	FILE* stream_nodes = fopen(nodes_filename, "r");

	if (!stream_nodes){
		printf("[MAIN] ERROR: Nodes configuration file %s not found!\n", nodes_filename);
		exit(-1);
	}

	if(node_type == NODE_TYPE_UNKWNOW){	

		num_nodes = GetNumOfLines(nodes_filename);

	} else {	

		while (fgets(line_nodes, CHAR_BUFFER_SIZE, stream_nodes)){

			if(!first_line_skiped_flag){

				first_line_skiped_flag = 1;

			} else{

				
				tmp_nodes = strdup(line_nodes);
				type_found = atof(GetField(tmp_nodes, IX_NODE_TYPE));
				free(tmp_nodes);

				
				tmp_nodes = strdup(line_nodes);
				wlan_code_found = ToString(GetField(tmp_nodes, IX_WLAN_CODE));
				free(tmp_nodes);

				if(wlan_code.compare(ToString("")) > 0){
					if(type_found == node_type && strcmp(wlan_code_found.c_str(), wlan_code.c_str()) == 0) ++num_nodes;
				} else {
					if(type_found == node_type) ++num_nodes;
				}
			}
		}
	}

	fclose(stream_nodes);
	return num_nodes;
}








#line 1311 "komondor_main.cc"
int compcxx_Komondor_27 :: CheckCentralController(const char *agents_filename){
	int presence_central_cotnroller(FALSE);
	FILE* stream_agents = fopen(agents_filename, "r");
	char line_agents[CHAR_BUFFER_SIZE];
	first_line_skiped_flag = 0;	
	while (fgets(line_agents, CHAR_BUFFER_SIZE, stream_agents)){
		if(!first_line_skiped_flag){	
			first_line_skiped_flag = 1;
		} else{
			
			char* tmp_agents (strdup(line_agents));
			const char *wlan_code_aux (GetField(tmp_agents, IX_AGENT_WLAN_CODE));
			std::string wlan_code;
			wlan_code.append(ToString(wlan_code_aux));
			
			if (strcmp(wlan_code.c_str(), "NULL") == 0) {
				presence_central_cotnroller = TRUE;
			}
		}
	}
	return presence_central_cotnroller;
}





#line 1337 "komondor_main.cc"
int main(int argc, char *argv[]){

	printf("\n");
	printf("*************************************************************************************\n");
	printf("%s KOMONDOR Wireless Network Simulator\n", LOG_LVL1);
	printf("%s Copyright (C) 2017-2022, and GNU GPL'd, by Sergio Barrachina & Francesc Wilhelmi\n", LOG_LVL1);
	printf("%s GitHub repository: https://github.com/wn-upf/Komondor\n", LOG_LVL2);
	printf("*************************************************************************************\n");
	printf("\n\n");

	
	char *nodes_input_filename;
	char *agents_input_filename;
	std::string script_output_filename;
	std::string simulation_code;
	int save_node_logs;
	int save_agent_logs;
	int print_system_logs;
	int print_node_logs;
	int print_agent_logs;
	double sim_time;
	int seed;
	int agents_enabled;

	total_nodes_number = 0;

	
	if(argc == NUM_FULL_ARGUMENTS_CONSOLE){	
		nodes_input_filename = argv[1];
		agents_input_filename = argv[2];
		script_output_filename = ToString(argv[3]);
		simulation_code = ToString(argv[4]);
		save_node_logs = atoi(argv[5]);
		save_agent_logs = atoi(argv[6]);
		print_system_logs = atoi(argv[7]);
		print_node_logs = atoi(argv[8]);
		print_agent_logs = atoi(argv[9]);
		sim_time = atof(argv[10]);
		seed = atoi(argv[11]);
		
		agents_enabled = TRUE;
		if (print_system_logs) printf("%s FULL configuration entered per console (AGENTS ENABLED).\n", LOG_LVL1);
	} else if(argc == NUM_FULL_ARGUMENTS_CONSOLE_NO_AGENTS){	
		nodes_input_filename = argv[1];
		script_output_filename = ToString(argv[2]);
		simulation_code = ToString(argv[3]);
		save_node_logs = atoi(argv[4]);
		print_system_logs = atoi(argv[5]);
		print_node_logs = atoi(argv[6]);
		sim_time = atof(argv[7]);
		seed = atoi(argv[8]);
		
		agents_enabled = FALSE;
		if (print_system_logs) printf("%s FULL configuration entered per console (AGENTS DISABLED).\n", LOG_LVL1);
	} else if(argc == NUM_PARTIAL_ARGUMENTS_CONSOLE) {	
		nodes_input_filename = argv[1];
		sim_time = atof(argv[2]);
		seed = atoi(argv[3]);
		
		script_output_filename.append(ToString(DEFAULT_SCRIPT_FILENAME));
		simulation_code.append(ToString(DEFAULT_SIMULATION_CODE));
		save_node_logs = DEFAULT_WRITE_NODE_LOGS;
		print_system_logs = DEFAULT_PRINT_SYSTEM_LOGS;
		print_node_logs = DEFAULT_PRINT_NODE_LOGS;
		
		agents_enabled = FALSE;
		if (print_system_logs) printf("%s PARTIAL configuration entered per console. "
			"Some parameters are set by DEFAULT.\n", LOG_LVL1);
	} else if(argc == NUM_PARTIAL_ARGUMENTS_SCRIPT) {	
		nodes_input_filename = argv[1];
		simulation_code = ToString(argv[2]);	
		sim_time = atof(argv[3]);
		seed = atoi(argv[4]);
		
		script_output_filename.append(ToString(DEFAULT_SCRIPT_FILENAME));
		save_node_logs = DEFAULT_WRITE_NODE_LOGS;
		print_system_logs = DEFAULT_PRINT_SYSTEM_LOGS;
		print_node_logs = DEFAULT_PRINT_NODE_LOGS;
		
		agents_enabled = FALSE;
		if (print_system_logs) printf("%s PARTIAL configuration entered per script. "
			"Some parameters are set by DEFAULT.\n", LOG_LVL1);
	} else {
		printf("%sERROR: Console arguments were not set properly!\n "
			" + For FULL configuration setting without agents, execute\n"
			"    ./Komondor -system_input_filename -nodes_input_filename -script_output_filename "
			"-simulation_code -save_node_logs -print_node_logs -print_system_logs "
			"-sim_time -seed\n"
			" + For FULL configuration setting with agents, execute\n"
			"    ./Komondor -system_input_filename -nodes_input_filename -agents_input_filename -script_output_filename "
			"-simulation_code -save_node_logs -save_agent_logs -print_node_logs -print_system_logs "
			"-print_agent_logs -sim_time -seed\n"
			" + For PARTIAL configuration setting, execute\n"
			"    ./KomondorSimulation -system_input_filename -nodes_input_filename -sim_time -seed\n"
			" + For PARTIAL configuration setting (SCRIPTS), execute\n"
			"    ./KomondorSimulation -system_input_filename -nodes_input_filename -simulation_code -sim_time -seed\n", LOG_LVL1);
		return(-1);
	}

	if (print_system_logs) {
		printf("%s Komondor input configuration:\n", LOG_LVL1);
		printf("%s nodes_input_filename: %s\n", LOG_LVL2, nodes_input_filename);
		printf("%s agents_enabled: %d\n", LOG_LVL2, agents_enabled);
		if (agents_enabled) { printf("%s agents_input_filename: %s\n", LOG_LVL2, agents_input_filename); }
		printf("%s script_output_filename: %s\n", LOG_LVL2, script_output_filename.c_str());
		printf("%s simulation_code: %s\n", LOG_LVL2, simulation_code.c_str());
		printf("%s save_node_logs: %d\n", LOG_LVL2, save_node_logs);
		printf("%s print_system_logs: %d\n", LOG_LVL2, print_system_logs);
		printf("%s print_node_logs: %d\n", LOG_LVL2, print_node_logs);
		printf("%s sim_time: %f s\n", LOG_LVL2, sim_time);
		printf("%s seed: %d\n", LOG_LVL2, seed);
	}


	

	struct stat st = {0};

	if (stat("../output/", &st) == -1) {
		printf("- Output folder does not exist --> creating it...\n");
	    mkdir("../output/", 0777);
	    if (stat("../output/", &st) == -1) {
			printf("- Output folder could not be created! Check permissions\n");
			exit(-1);
		} else {
			printf("- Output folder successfully created!\n");
		}
	}


	
	compcxx_Komondor_27 komondor_simulation;
	komondor_simulation.Seed = seed;
	srand(seed); 
	komondor_simulation.StopTime(sim_time);
	komondor_simulation.Setup(sim_time, save_node_logs, save_agent_logs, print_system_logs,
		print_node_logs, print_agent_logs, nodes_input_filename, script_output_filename.c_str(),
		simulation_code.c_str(), seed, agents_enabled, agents_input_filename);

	printf("------------------------------------------\n");
	printf("%s SIMULATION '%s' STARTED\n", LOG_LVL1, simulation_code.c_str());

	komondor_simulation.Run();

	return(0);
};

